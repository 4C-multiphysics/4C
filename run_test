#!/bin/sh
#==========================================
# bash script to compile ccarat for each
# commented input file, run the file and
# analyze the output.
#
#                           (C) by mn 02/04
#==========================================

# defaults
numproc=2  # number of processing elements (CPUs)

# message about use of this shell script
function helpmessage
{
  echo "usage: $0 [-j <number>] type config-file-name [input-file]"
  echo "       type = all, rel, reldrt, restart, single"
  echo "       -j <number> = number of processors (default $numproc)"
}

# option loop
while getopts :j: OPT; do
    case $OPT in
	j|+j)
	    # number of CPUs
	    numproc=$OPTARG
	;;*)
	helpmessage
	exit 2
    esac
done
shift `expr $OPTIND - 1`

# some usability tests
if [ "x$1" = "x" ]; then
  helpmessage
  exit 1
fi

if [ "x$2" = "x" ]; then
  helpmessage
  exit 1
fi

if [ ! -s "$2" ]; then
  echo $0: file not found: $2
  exit 1
fi

SRC=`dirname $0`
DEST=.

# initialize some counters
fail1files=""
fail1=0
pass1=0
fail2files=""
fail2=0
pass2=0
total=0
number=0
s_time=0
e_time=0

# variables used for creating the makefile
makefile="$SRC/Makefile.test"
#definefile="$SRC/config/defines.test"
definefile="$DEST/defines.test"
if [ "x$1" = "xrel" ]; then
  # this is for CCARAT exe
  reldefinefile="$SRC/config/release_defs"
  maketarget="all"
elif [ "x$1" = "xreldrt" ]; then
  # this is for BACI exe
  reldefinefile="$SRC/config/defines.drt.rel"
  maketarget=""
else
  reldefinefile=""
fi
if [ -n "$reldefinefile" ]; then
  if [ ! -r $reldefinefile ]; then
     echo "definition file $reldefinefile does not exist"
     exit 1
  fi
fi
configfile="$2"
NODEPS=yes


# prepare clean up
function cleanup
{
    #echo cleanup
    make -f $makefile clean >/dev/null
    rm -f test.tmp test2.tmp  test_out* $exe make.log $makefile $definefile restart_input.dat

    # remove hook
    trap "echo" 0 1 2 15
}

function exittrap
{
    cleanup

    # If we exit here something went wrong.
    # (It might have been a user interrupt.)
    exit 1
}

trap "exittrap" 0 1 2 15


# remove all output files from previous runs
rm -f *.dat.scr *.dat.make.log

# figure out whether we are parallel or not
touch "$definefile"
. "$configfile"



# create the list of files for the different types of testing
if [ "x$1" = "xall" ]; then

  # test all files
  if [ "x$PARALLEL" = "xno" ]; then
    typ=2
  else
    typ=3
  fi

  # create the list
  liste=`awk '{ if ($'$typ' ~ /[xX]/) print "'$SRC/'"$1 }' $SRC/testing/list_of_files`

elif [ "x$1" = "xrel" ]; then

  # test all files using one CCARAT exe
  cat $reldefinefile > $definefile
  if [ "x$PARALLEL" = "xno" ]; then
    typ=4
  else
    typ=5
  fi

  # create the list; we look for 'x' or 'X' in column $typ and ...
  liste=`awk '{ if ($'$typ' ~ /[xX]/) print "'$SRC/'"$1 }' $SRC/testing/list_of_files`
  # ... select those which do NOT define CCADISCRET 
  liste=`grep -L CCADISCRET $liste`

elif [ "x$1" = "xreldrt" ]; then

  # test all files using one BACI exe
  cat $reldefinefile > $definefile
  if [ "x$PARALLEL" = "xno" ]; then
    typ=4
  else
    typ=5
  fi

  # create the list; we look for 'x' or 'X' in column $typ and ...
  liste=`awk '{ if ($'$typ' ~ /[xX]/) print "'$SRC/'"$1 }' $SRC/testing/list_of_files`
  # ... select those which define CCADISCRET 
  liste=`grep -l CCADISCRET $liste`

elif [ "x$1" = "xrestart" ]; then

  # test all files with restart
  if [ "x$PARALLEL" = "xno" ]; then
    typ=6
  else
    typ=7
  fi

  # create the list
  liste=`awk '{ if ($'$typ' ~ /[xX]/) print "'$SRC/'"$1 }' $SRC/testing/list_of_files`

elif [ "x$1" = "xsingle" ]; then

  # test only one file

  # check whether the name of the input file was given
  if [ "x$3" = "x" ]; then
    echo "usage: $0 single config-file-name input-file"
    exit 1
  fi
  # check whether the input file exists
  if [ ! -s "$3" ]; then
    echo $0: file not found: $3
    exit 1
  fi

  # create the list
  liste=$3

else
  # unknown test typ
  echo "ERROR: Unknown type of testing!!"
  helpmessage
  exit 1
fi

# count files in list
for file in $liste; do
  total=`expr $total + 1`
done


# get the start-time in seconds:
h=`date +"%H"`
m=`date +"%M"`
s=`date +"%S"`
st_time=`expr $s + 60 \* $m + 60 \* 60 \* $h`


# print out some information
echo
echo $0 $1 $2 $3
echo `whoami`@`hostname`
date
echo $configfile
echo
echo 'BEGIN OF TEST ========================================'


# select the correct testing procedure
if [ "x$1" = "xall" ]; then

  # test all files
  . $SRC/testing/loop_all.sh

elif [ "x$1" = "xrel" ] || [ "x$1" = "xreldrt" ]; then

  # test all files using one CCARAT or BACI exe
  . $SRC/testing/loop_rel.sh

elif [ "x$1" = "xrestart" ]; then

  # test all files with restart
  . $SRC/testing/loop_restart.sh

elif [ "x$1" = "xsingle" ]; then

  # test only one file
  . $SRC/testing/loop_all.sh

else

  # unknown test type
  echo "ERROR: Unknown type of testing!!"
  helpmessage
  exit 1

fi


# write final time to the screen
echo
echo 'END OF TEST =========================================='
echo

# get the end-time in seconds:
h=`date +"%H"`
m=`date +"%M"`
s=`date +"%S"`
et_time=`expr $s + 60 \* $m + 60 \* 60 \* $h`
ttime=`expr $et_time - $st_time`
mins=`expr $ttime / 60`
secs=`expr $ttime % 60`
echo 'Total time:'
if [ $secs -le 9 ]; then
  echo ''$mins':0'$secs' mins:secs'
else
  echo ''$mins':'$secs' mins:secs'
fi
echo


# write table with result to the screen
echo 'Summary'
echo '-----------------------------'
printf '| '
printf $total' files    '
if [ $total -le 9 ]; then
  printf ' '
fi
printf '| pass | fail |\n'
echo '|-------------|------|------|'
printf "| compilation |  "
if [ $pass1 -le 9 ]; then
  printf ' '
fi
printf $pass1'  |  '
if [ $fail1 -le 9 ]; then
  printf ' '
fi
printf $fail1'  |\n'
echo '|-------------|------|------|'
printf "| running     |  "
if [ $pass2 -le 9 ]; then
  printf ' '
fi
printf $pass2'  |  '
if [ $fail2 -le 9 ]; then
  printf ' '
fi
printf $fail2'  |\n'
echo '-----------------------------'
echo

# write input files which failed to build
if [ $fail1 -ge 1 ] && [ -n "$fail1files" ]
then
    echo "Compilation failed for $fail1 file(s):"
    for file1 in $fail1files
    do
      echo "    "`basename $file1`
    done
    echo ""
fi

# write input files which failed to run
if [ $fail2 -ge 1 ] && [ -n "$fail2files" ]
then
    echo "Running failed for $fail2 file(s):"
    for file2 in $fail2files
    do
      echo "    "`basename $file2`
    done
    echo ""
fi

# We are done. Clean up and remove the exit trap.
cleanup

# exit with non-zero return code if something went wrong
if [ $fail1 -ge 1 ]; then
  exit 1
fi
if [ $fail2 -ge 1 ]; then
  exit 1
fi
