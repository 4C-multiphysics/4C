#include "../headers/standardtypes.h"
/*----------------------------------------------------------------------*
 | global dense matrices for element routines             m.gee 9/01    |
 | (defined in global_calelm.c, so they are extern here)                |                
 *----------------------------------------------------------------------*/
extern struct _ARRAY estif_global;
extern struct _ARRAY emass_global;
/*----------------------------------------------------------------------*
 |  routine to create the pointer array assemble         m.gee 9/01     |
 |  and to allocate the send and recv buffers for                       |
 |  coupling conditions                                                 |
 *----------------------------------------------------------------------*/
void mg_init_assembly(
                       struct _PARTITION      *actpart,
                       struct _SOLVAR         *actsolv
                     )
{
int         i,j,k;
int         numsend;
int         numrecv;
ARRAY      *coupledofs;
ELEMENT    *actele;
#ifdef DEBUG 
mg_dstrc_enter("mg_init_assembly");
#endif
/*---------------- now check for coupling dofs and interdomain coupling */
coupledofs = &(actpart->coupledofs);
numsend=0;
numrecv=0;
/* 
   An inter-proc coupled equation produces communications calculating the 
   sparsity mask of the matrix
   An inter-proc coupled equation produces communications adding element
   matrices to the system matrix
   An inter-proc coupled equation ruins the bandwith locally
   ->
   Now one processor has to be owner of the coupled equation. 
   Try to distribute the coupled equations equally over the processors

   The matrix has the following style (after allreduce on all procs the same):
   
               ----------------------
               | 12 | 2 | 0 | 1 | 0 |
               | 40 | 2 | 0 | 0 | 0 |
               | 41 | 1 | 2 | 1 | 1 |
               | 76 | 0 | 1 | 2 | 0 |
               ----------------------
               
               column 0                : number of the coupled equation
               column 1 - par.nprocs+1 : proc has coupled equation or not
                                         2 indicates owner of equation
*/
/* calculate the number of sends and receives to expect during assemblage */
for (i=0; i<coupledofs->fdim; i++)
{
   /*------------------------------------ check for master owner of dof */
   if (coupledofs->a.ia[i][par.myrank+1]==2)
   {
      /*------------------------- check whether other procs have slaves */
      for (j=1; j<coupledofs->sdim; j++)
      {
         if (coupledofs->a.ia[i][j]==1) numrecv++;
      }
   }
   /*------------------------------------- check for slave owners of dof */
   if (coupledofs->a.ia[i][par.myrank+1]==1) numsend++;
}
actsolv->ncouplesend = numsend;
actsolv->ncouplerecv = numrecv;
/*-------------------------- allocate the necessary send and recv buffs */
/*----------------------------------------------------------------------*/
#ifdef DEBUG 
mg_dstrc_exit();
#endif
return;
} /* end of mg_init_assembly */




/*----------------------------------------------------------------------*
 |  routine to assemble element arrays to global sparse arrays m.gee 9/01|
 *----------------------------------------------------------------------*/
void mg_assemble(int                sysarray1,
                 struct _ARRAY     *elearray1,
                 int                sysarray2,
                 struct _ARRAY     *elearray2,
                 struct _PARTITION *actpart,
                 struct _SOLVAR    *actsolv,
                 struct _ELEMENT   *actele)
{
int         i,j,k;
enum  _SPARSE_TYP    sysa1_typ;
union _SPARSE_ARRAY *sysa1;
enum  _SPARSE_TYP    sysa2_typ;
union _SPARSE_ARRAY *sysa2;
#ifdef DEBUG 
mg_dstrc_enter("mg_assemble");
#endif
/*----------------------------------------------------------------------*/
/*----------------------- check for presence and typ of system matrices */
if (sysarray1>=0) 
{
   sysa1       = &(actsolv->sysarray[sysarray1]);
   sysa1_typ   =   actsolv->sysarray_typ[sysarray1]; 
}
else              
{
   sysa1     = NULL;
   sysa1_typ = sparse_none; 
}
if (sysarray2>=0) 
{
   sysa2     = &(actsolv->sysarray[sysarray2]);
   sysa2_typ =   actsolv->sysarray_typ[sysarray2];
}
else              
{
   sysa2     = NULL;
   sysa2_typ = sparse_none;
}
/*------------------------------------------------ switch typ of matrix */
switch(sysa1_typ)
{
case msr:
   mg_add_msr(actpart,actsolv,actele,sysa1->msr);
break;
case sparse_none:
   dserror("Unspecified typ of system matrix");
break;
default:
   dserror("Unspecified typ of system matrix");
break;
}
/*----------------------------------------------------------------------*/
#ifdef DEBUG 
mg_dstrc_exit();
#endif
return;
} /* end of mg_assemble */





/*----------------------------------------------------------------------*
 |  routine to assemble element array to global DMSR-matrix             |
 |  in parallel and sequentiell,taking care of coupling conditions      |
 |                                                                      |
#ifdef PARALLEL                                                         |
    ...assembling a distributed sparse matrix is an art !!!             |
#endif                                                                  |
 |                                                                      |
 |                                                         m.gee 9/01   |
 *----------------------------------------------------------------------*/
int  mg_add_msr(struct _PARTITION     *actpart,
                struct _SOLVAR        *actsolv,
                struct _ELEMENT       *actele,
                struct _AZ_ARRAY_MSR  *msr)
{
int         i,j,k,l,counter;          /* some counter variables */
int         start,index,lenght;       /* some more special-purpose counters */
int         ii,jj;                    /* counter variables for system matrix */
int         ii_iscouple;              /* flag whether ii is a coupled dof */
int         jj_iscouple;              /* flag whether jj is a coupled dof */
int         ii_owner;                 /* who is owner of dof ii -> procnumber */
int         jj_owner;                 /* who is owner of dof jj -> procnumber */
int         nd,ndnd;                  /* size of estif */
int         nnz;                      /* number of nonzeros in sparse system matrix */
int         numeq_total;              /* total number of equations */
int         lm[MAXDOFPERELE];         /* location vector for this element */
int         owner[MAXDOFPERELE];      /* the owner of every dof */
int         myrank;                   /* my proc number */
double    **estif;                    /* element matrix to be added to system matrix */
int        *update;                   /* msr-vector update see AZTEC manual */
int        *bindx;                    /*    "       bindx         "         */
double     *val;                      /*    "       val           "         */
int       **cdofs;                    /* list of coupled dofs and there owners, see mg_init_assembly */
int         ncdofs;                   /* total number of coupled dofs */
#ifdef DEBUG 
mg_dstrc_enter("mg_add_msr");
#endif
/*----------------------------------------------------------------------*/
/*------------------------------------- set some pointers and variables */
myrank     = par.myrank;
estif      = estif_global.a.da;
nd         = actele->numnp * actele->node[0]->numdf;
ndnd       = nd*nd;
nnz        = msr->nnz;
numeq_total= msr->numeq_total;
update     = msr->update.a.iv;
bindx      = msr->bindx.a.iv;
val        = msr->val.a.dv;
cdofs      = actpart->coupledofs.a.ia;
ncdofs     = actpart->coupledofs.fdim;
/*---------------------------------------------- make location vector lm*/
counter=0;
for (i=0; i<actele->numnp; i++)
{
   if (actele->node[i]->proc == myrank)
   {
      for (j=0; j<actele->node[i]->numdf; j++)
      {
         lm[counter] = actele->node[i]->dof[j];
         counter++;
      }
   }
   /*
       if the element's node does not belong to this processor, 
       the nodes's dofs are temporarily given dof-numbers above numeq, 
       so the assembly thinks, that they are Dirichlet-conditioned 
   */
   else
   {
      for (j=0; j<actele->node[i]->numdf; j++)
      {
         lm[counter] = numeq_total;
         counter++;
      }
   }
}/* end of loop over element nodes */
if (counter != nd) dserror("assemblage failed due to wrong dof numbering");
/*========================================== now start looping the dofs */
/*--------------------------------------- loop over i (the element row) */
for (i=0; i<nd; i++)
{
   /* the system row */
   ii = lm[i];
   if (ii >= numeq_total) continue;
   ii_iscouple=0;ii_owner=-1;
   /*====================================== check for coupling of ii */
   /* 
       This is only important in the parallel case, in sequentiell 
       calculation, the assembly is correct, whether the dofs are
       coupled or not
   */
   for (k=0; k<ncdofs; k++)
   {
      /*---------------------------------------- ii is a coupled dof */ 
      if (ii == cdofs[k][0]) 
      {
         ii_iscouple=1;
         /*------------------------------------ find the owner of ii */
         for (l=1; l<=par.nprocs; l++) 
            if (cdofs[k][l]==2){ii_owner=l-1; break;}
      }
   }
/*------------------------------------ loop over j (the element column) */   
   for (j=i; j<nd; j++)
   {
      /* the system column */
      jj = lm[j];
      if (jj >= numeq_total) continue;
      jj_iscouple=0;jj_owner=-1;
      /*====================================== check for coupling of jj */
      for (k=0; k<ncdofs; k++)
      {
         /*---------------------------------------- jj is a coupled dof */ 
         if (jj == cdofs[k][0]) 
         {
            jj_iscouple=1;
            /*------------------------------------ find the owner of jj */
            for (l=1; l<=par.nprocs; l++) 
               if (cdofs[k][l]==2){jj_owner=l-1; break;}
         }
      }
/*===================================================== do the assembly */
      /*============================================== diagonal element */
      if (i == j)
      {
         /*-------------------------- not a coupled main diagonal entry */
         if (!ii_iscouple) 
         {
            val[ii] += estif[i][j];
         }
         /*----- coupled main diagonal entry and I am owner of this row */
         else if (ii_iscouple && ii_owner==myrank)
         {                                            
            val[ii] += estif[i][j];
         }
         /* coupled main diagonal entry  and I am not owner of this row */
         /*                                 -> communication for row ii */
         else                                         
         {                                            
         } 
      }
      /*========================================== off-diagonal element */
      else
      {
         /*------------------------- neither ii nor jj are coupled dofs */
         if (!ii_iscouple && !jj_iscouple)
         {
            /*------------------------------------------- add to row ii */
            start  = bindx[ii];
            lenght = bindx[ii+1]-bindx[ii];
            index  = AZ_find_index(jj,&(bindx[start]),lenght);
            if (index==-1) dserror("error in off-diagonal indize in bindx");
            index += start;
            val[index] += estif[i][j];
            /*------------------------------------------- add to row jj */
            start  = bindx[jj];
            lenght = bindx[jj+1]-bindx[jj];
            index  = AZ_find_index(ii,&(bindx[start]),lenght);
            if (index==-1) dserror("error in off-diagonal indize in bindx");
            index += start;
            val[index] += estif[i][j];
         }
         /*----------------------------- ii is a coupled dof, jj is not */
         else if (ii_iscouple && !jj_iscouple)
         {
            /*--------------------------------- I am owner of ii and jj */
            if (ii_owner==myrank)
            {
               /*---------------------------------------- add to row ii */
               start  = bindx[ii];
               lenght = bindx[ii+1]-bindx[ii];
               index  = AZ_find_index(jj,&(bindx[start]),lenght);
               if (index==-1) dserror("error in off-diagonal indize in bindx");
               index += start;
               val[index] += estif[i][j];
               /*---------------------------------------- add to row jj */
               start  = bindx[jj];
               lenght = bindx[jj+1]-bindx[jj];
               index  = AZ_find_index(ii,&(bindx[start]),lenght);
               if (index==-1) dserror("error in off-diagonal indize in bindx");
               index += start;
               val[index] += estif[i][j];
            }
            /*-------------------- I am owner of jj but not owner of ii */ 
            /*                              -> communication for row ii */
            else
            {
            }
         }
         /*--------------------------- ii is not coupled, jj is coupled */
         else if (!ii_iscouple && jj_iscouple)
         {
            /*--------------------------------- I am owner of ii and jj */
            if (jj_owner==myrank)
            {
               /*---------------------------------------- add to row ii */
               start  = bindx[ii];
               lenght = bindx[ii+1]-bindx[ii];
               index  = AZ_find_index(jj,&(bindx[start]),lenght);
               if (index==-1) dserror("error in off-diagonal indize in bindx");
               index += start;
               val[index] += estif[i][j];
               /*---------------------------------------- add to row jj */
               start  = bindx[jj];
               lenght = bindx[jj+1]-bindx[jj];
               index  = AZ_find_index(ii,&(bindx[start]),lenght);
               if (index==-1) dserror("error in off-diagonal indize in bindx");
               index += start;
               val[index] += estif[i][j];
            }
            /*-------------------- I am owner of ii but not owner of jj */
            /*                              -> communication for row jj */
            else
            {
            }
         }
         /*---------------------------- ii and jj both are coupled dofs */
         else                                 
         {
            /*---------------------- Good luck, I am owner of ii and jj */
            if (ii_owner==myrank && jj_owner==myrank)
            {
               /*---------------------------------------- add to row ii */
               start  = bindx[ii];
               lenght = bindx[ii+1]-bindx[ii];
               index  = AZ_find_index(jj,&(bindx[start]),lenght);
               if (index==-1) dserror("error in off-diagonal indize in bindx");
               index += start;
               val[index] += estif[i][j];
               /*---------------------------------------- add to row jj */
               start  = bindx[jj];
               lenght = bindx[jj+1]-bindx[jj];
               index  = AZ_find_index(ii,&(bindx[start]),lenght);
               if (index==-1) dserror("error in off-diagonal indize in bindx");
               index += start;
               val[index] += estif[i][j];
            }
            /*-------------- I am owner of ii, but I am not owner of jj */
            /*                                -> communicate for row jj */
            else if (ii_owner==myrank && jj_owner!=myrank)
            {
            }
            /*-------------- I am owner of jj, but I am not owner of ii */
            /*                                -> communicate for row ii */
            else if (ii_owner!=myrank && jj_owner==myrank)
            {
            }
            /*--------- I am not sure, whether this is possible at all: */
            /*  I am not owner of ii and not owner of jj , so what am I */
            /*                                             doing here ? */
            /* 
               This could eventually happen, if I a slave owner of two dofs,
               that are coupled to dofs on other procs and both dofs are on
               the same element here on this proc
            */
            else
            {
              dserror("ELEMENT ASSEMBLY TO FOREIGN COUPLED DOFS II AND JJ -> REWRITE mg_add_msr");
            }
         }
      }/* end of off-diagonal entry */
   }/* loop over j */
}/* loop over i */
/*----------------------------------------------------------------------*/
#ifdef DEBUG 
mg_dstrc_exit();
#endif
return(0);
} /* end of mg_add_msr */
