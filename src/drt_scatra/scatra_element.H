/*!
\file scatra_element.H

\brief The scalar transport element

This file contains the element specific service routines like
Pack, Unpack, NumDofPerNode etc.

<pre>
Maintainer: Andreas Ehrl
            ehrl@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15252
</pre>
*/
#ifndef DRT_SCATRA_ELEMENT_H
#define DRT_SCATRA_ELEMENT_H


#include "../drt_lib/drt_element.H"
#include "../drt_lib/drt_elementtype.H"
#include "../drt_lib/drt_parobjectfactory.H"


namespace DRT
{
// forward declarations
class Discretization;

namespace ELEMENTS
{
// forward declarations
class TransportBoundary;


class TransportType : public DRT::ElementType
{
public:

  std::string Name() const { return "TransportType"; }

  static TransportType & Instance() { return instance_; };

  virtual DRT::ParObject* Create( const std::vector<char> & data );

  virtual Teuchos::RCP<DRT::Element> Create( const std::string eletype,
                                             const std::string eledistype,
                                             const int id,
                                             const int owner );

  virtual Teuchos::RCP<DRT::Element> Create( const int id, const int owner );

  virtual void NodalBlockInformation( DRT::Element * dwele, int & numdf, int & dimns, int & nv, int & np );

  virtual void ComputeNullSpace( DRT::Discretization & dis, std::vector<double> & ns, const double * x0, int numdf, int dimns );

  virtual void SetupElementDefinition( std::map<std::string,std::map<std::string,DRT::INPUT::LineDefinition> > & definitions );

private:

  static TransportType instance_;
};

/*!
\brief The Transport element

\author Georg Bauer (bauer@lnm.mw.tum.de)
*/
class Transport : public DRT::Element
{
public:

  //@}
  //! @name Constructors and destructors and related methods

  /*!
  \brief Standard Constructor
  */
  Transport(
    int id,    ///< A unique global id of this element
    int owner  ///< processor id who owns a certain instance of this class
    );

  /*!
  \brief Copy Constructor

  Makes a deep copy of a Element

  */
  Transport(const Transport& old);

  /*!
  \brief Deep copy this instance of Transport and return pointer to the copy

  The Clone() method is used from the virtual base class Element in cases
  where the type of the derived class is unknown and a copy-ctor is needed

  */
  DRT::Element* Clone() const;

  /// Set element material
  /*!
    Material numbers are read from the input file. The element stores
    a corresponding material object. These material objects can be
    anything from very simple (just a little calculation) to highly
    sophisticated with history data. The material is packed and
    unpacked along with its element.

    \param matnum : material number from input file

    \note reimplementation of this method, due to initialising
          numdofpernode_, since the material is known now.
   */
  virtual void SetMaterial(int matnum);

  virtual void SetMaterial(int matnum,DRT::Element* oldele);

  /*!
  \brief Get shape type of element
  */
  virtual DiscretizationType Shape() const;

  /*!
  \brief set discretization type of element
  */
  virtual void SetDisType(DRT::Element::DiscretizationType shape)
  {
    distype_ = shape;
    return;
  };

  /*!
  \brief Return number of lines of this element
  */
  virtual int NumLine() const;

  /*!
  \brief Return number of surfaces of this element
  */
  virtual int NumSurface() const;

  /*!
  \brief Return number of volumes of this element
  */
  virtual int NumVolume() const;

  /*!
  \brief Get vector of RCPs to the lines of this element
  */
  virtual std::vector<Teuchos::RCP<DRT::Element> > Lines();

  /*!
  \brief Get vector of RCPs to the surfaces of this element
  */
  virtual std::vector<Teuchos::RCP<DRT::Element> > Surfaces();

  /*!
  \brief Get vector of RCPs to the volume of this element
  */
  virtual std::vector<Teuchos::RCP<DRT::Element> > Volumes();

  /*!
  \brief Return unique ParObject id

  every class implementing ParObject needs a unique id defined at the
  top of this file.
  */
  virtual int UniqueParObjectId() const { return TransportType::Instance().UniqueParObjectId(); }

  /*!
  \brief Pack this class so it can be communicated

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Pack(DRT::PackBuffer& data) const;

  /*!
  \brief Unpack data from a char vector into this class

  \ref Pack and \ref Unpack are used to communicate this element
  */
  virtual void Unpack(const std::vector<char>& data);

  /*!
  \brief Destructor

  */
  virtual ~Transport();

  //@}

  //! @name Access methods


  /*!
  \brief Get number of degrees of freedom of a certain node
         (implements pure virtual DRT::Element)

  The element decides how many degrees of freedom its nodes must have.
  As this may vary along a simulation, the element can re-decide the
  number of degrees of freedom per node along the way for each of it's nodes
  separately.
  */
  virtual int NumDofPerNode(const DRT::Node& node) const
  {
    if(numdofpernode_<1) dserror("NumDofPerNode is < 1");
    return numdofpernode_;
  }

  /*!
  \brief Get number of degrees of freedom of a certain node
         (implements pure virtual DRT::Element)

  The element decides how many degrees of freedom its nodes must have.
  As this may vary along a simulation, the element can redecide the
  number of degrees of freedom per node along the way for each of it's nodes
  separately.

  This is the version for a coupling to fluid flow with a second dof set.
  */
  virtual int NumDofPerNode(const unsigned nds, const DRT::Node& node, const std::string disname = std::string("dummy") ) const
  {
    // number of dofs for fluid (based on similar discretization)
    if (nds==1)
    {
      switch(distype_)
      {
      case DRT::Element::hex8:
      case DRT::Element::hex20:
      case DRT::Element::hex27:
      case DRT::Element::tet4:
      case DRT::Element::tet10:
      case DRT::Element::wedge6:
      case DRT::Element::wedge15:
      case DRT::Element::pyramid5:
      case DRT::Element::nurbs8:
      case DRT::Element::nurbs27:
        return 4;
        break;
      case DRT::Element::quad4:
      case DRT::Element::quad8:
      case DRT::Element::quad9:
      case DRT::Element::nurbs4:
      case DRT::Element::nurbs9:
      case DRT::Element::tri3:
      case DRT::Element::tri6:
        return 3;
        break;
      case DRT::Element::line2:
      case DRT::Element::line3:
        dserror("1D Fluid elements are not supported");
        break;
      default:
        dserror("discretization type %s not yet implemented", (DRT::DistypeToString(distype_)).c_str());
        break;
      }
    }
    if(nds > 1)
      dserror("Case nsd > 1 not implemented.");

    return NumDofPerNode(node);
  }

  /*!
  \brief Get number of degrees of freedom per element
         (implements pure virtual DRT::Element)

  The element decides how many element degrees of freedom it has.
  It can re-decide along the way of a simulation.

  \note Element degrees of freedom mentioned here are dofs that are visible
        at the level of the total system of equations. Purely internal
        element dofs that are condensed internally should NOT be considered.
  */
  virtual int NumDofPerElement() const { return 0; }

  /*!
  \brief Print this element
  */
  void Print(std::ostream& os) const;

  /*!
  \brief Return ElementType
  */
  virtual DRT::ElementType & ElementType() const
  { return TransportType::Instance(); }

  /*!
  \brief Query names of element data to be visualized using BINIO

  The element fills the provided map with key names of
  visualization data the element wants to visualize AT THE CENTER
  of the element geometry. The values is supposed to be dimension of the
  data to be visualized. It can either be 1 (scalar), 3 (vector), 6 (sym. tensor)
  or 9 (nonsym. tensor)

  Example:
  \code
    // Name of data is 'Owner', dimension is 1 (scalar value)
    names.insert(std::pair<std::string,int>("Owner",1));
    // Name of data is 'StressesXYZ', dimension is 6 (sym. tensor value)
    names.insert(std::pair<std::string,int>("StressesXYZ",6));
  \endcode

  \param names (out): On return, the derived class has filled names with
                      key names of data it wants to visualize and with int dimensions
                      of that data.
  */
  virtual void VisNames(std::map<std::string,int>& names);

  /*!
  \brief Query data to be visualized using BINIO of a given name

  The method is supposed to call this base method to visualize the owner of
  the element.
  If the derived method recognizes a supported data name, it shall fill it
  with corresponding data.
  If it does NOT recognizes the name, it shall do nothing.

  \warning The method must not change size of data

  \param name (in):   Name of data that is currently processed for visualization
  \param data (out):  data to be filled by element if element recognizes the name
  */
  virtual bool VisData(const std::string& name, std::vector<double>& data);

  /*!
  \brief Add values to the data_ container
  */
  virtual void AddToData(const std::string& name, std::vector<double> data)
  {data_.Add(name,data);};

  //@}

  //! @name Input and Creation

  /*!
  \brief Read input for this element
  */
  bool ReadElement(const std::string& eletype,
                   const std::string& distype,
                   DRT::INPUT::LineDefinition* linedef);

  //@}

  //! @name Evaluation

  /*!
  \brief Evaluate an element, i.e. call the implementation to evaluate Transport
  element stiffness, mass, internal forces or evaluate errors, statistics or updates
  etc. directly.

  Following implementations of the element are allowed:
  <pre>
    o Evaluation of system matrix and residual for the One-Step-Theta or BDF2
      method

    o Evaluation of system matrix and residual for the stationary fluid solver
  </pre>

  \param params (in/out): ParameterList for communication between control routine
                          and elements
  \param discretization (in): A reference to the underlying discretization
  \param lm (in):         location vector of this element
  \param elemat1 (out)  : matrix to be filled by element. If NULL on input,
                          the controling method does not epxect the element to fill
                          this matrix.
  \param elemat2 (out)  : matrix to be filled by element. If NULL on input,
                          the controling method does not epxect the element to fill
                          this matrix.
  \param elevec1 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \param elevec2 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \param elevec3 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \return 0 if successful, negative otherwise
  */
  int Evaluate(Teuchos::ParameterList& params,
               DRT::Discretization&      discretization,
               std::vector<int>&         lm,
               Epetra_SerialDenseMatrix& elemat1,
               Epetra_SerialDenseMatrix& elemat2,
               Epetra_SerialDenseVector& elevec1,
               Epetra_SerialDenseVector& elevec2,
               Epetra_SerialDenseVector& elevec3);


  /*!
  \brief Evaluate a Neumann boundary condition

  this method evaluates a surfaces Neumann condition on the shell element

  \param params (in/out)    : ParameterList for communication between control routine
                              and elements
  \param discretization (in): A reference to the underlying discretization
  \param condition (in)     : The condition to be evaluated
  \param lm (in)            : location vector of this element
  \param elevec1 (out)      : vector to be filled by element. If NULL on input,

  \return 0 if successful, negative otherwise
  */
  virtual int EvaluateNeumann(Teuchos::ParameterList& params,
                              DRT::Discretization&      discretization,
                              DRT::Condition&           condition,
                              std::vector<int>&         lm,
                              Epetra_SerialDenseVector& elevec1,
                              Epetra_SerialDenseMatrix* elemat1 = NULL);


  //@}

  //@}

private:

  //! container containing all kind of element thisandthat
  DRT::Container            data_;

  /*!
   * \brief number of dofs per node (for systems of transport equations)
   * (storage neccessary because we dont know the material in the post filters anymore)
   */
  int                       numdofpernode_;

  //! the element discretization type (shape)
  DRT::Element::DiscretizationType distype_;


  //! don't want = operator
  Transport& operator = (const Transport& old);


}; // class Transport


//=======================================================================
//=======================================================================
//=======================================================================
//=======================================================================

class TransportBoundaryType : public DRT::ElementType
{
public:

  std::string Name() const { return "TransportBoundaryType"; }

  static TransportBoundaryType & Instance() { return instance_; };

  virtual Teuchos::RCP<DRT::Element> Create( const int id, const int owner );

  virtual void NodalBlockInformation( DRT::Element * dwele, int & numdf, int & dimns, int & nv, int & np ) {}

  virtual void ComputeNullSpace( DRT::Discretization & dis, std::vector<double> & ns, const double * x0, int numdf, int dimns ) {}

private:

  static TransportBoundaryType instance_;
};


/*!
\brief An element representing a boundary element of a Transport element

\note This is a pure boundary condition element. Its only
      purpose is to evaluate certain boundary conditions that might be
      adjacent to a parent Transport element.

\author Georg Bauer (bauer@lnm.mw.tum.de)
*/
class TransportBoundary : public DRT::Element
{
public:

  //! @name Constructors and destructors and related methods

  /*!
  \brief Standard Constructor

  \param id : A unique global id
  \param owner: Processor owning this surface
  \param nnode: Number of nodes attached to this element
  \param nodeids: global ids of nodes attached to this element
  \param nodes: the discretizations map of nodes to build ptrs to nodes from
  \param parent: The parent fluid element of this surface
  \param lsurface: the local surface number of this surface w.r.t. the parent element
  */
  TransportBoundary(
      int id,
      int owner,
      int nnode,
      const int* nodeids,
      DRT::Node** nodes,
      DRT::ELEMENTS::Transport* parent,
      const int lsurface
    );

  /*!
  \brief Copy Constructor

  Makes a deep copy of a Element

  */
  TransportBoundary(const TransportBoundary& old);

  /*!
  \brief Deep copy this instance of an element and return pointer to the copy

  The Clone() method is used from the virtual base class Element in cases
  where the type of the derived class is unknown and a copy-ctor is needed

  */
  DRT::Element* Clone() const;

  /*!
  \brief Get shape type of element
  */
  virtual DiscretizationType Shape() const;

  /*!
  \brief Return number of lines of boundary element
  */
  virtual int NumLine() const;

  /*!
  \brief Return number of surfaces of boundary element
   */
  virtual int NumSurface() const;

  /*!
  \brief Get vector of RCPs to the lines of this element

  */
  virtual std::vector<Teuchos::RCP<DRT::Element> > Lines();

  /*!
  \brief Get vector of RCPs to the surfaces of this element
  */
  virtual std::vector<Teuchos::RCP<DRT::Element> > Surfaces();

  /*!
  \brief Return unique ParObject id

  every class implementing ParObject needs a unique id defined at the
  top of the drt_parobject.H file.
  */
  virtual int UniqueParObjectId() const { return TransportBoundaryType::Instance().UniqueParObjectId(); }

  /*!
  \brief Pack this class so it can be communicated

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Pack(DRT::PackBuffer& data) const;

  /*!
  \brief Unpack data from a char vector into this class

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Unpack(const std::vector<char>& data);

  /*!
  \brief Destructor

  */
  virtual ~TransportBoundary();

  //@}

  //! @name Access methods


  /*!
  \brief Get number of degrees of freedom of a certain node
         (implements pure virtual DRT::Element)

  The element decides how many degrees of freedom its nodes must have.
  As this may vary along a simulation, the element can re-decide the
  number of degrees of freedom per node along the way for each of it's nodes
  separately.
  */
  virtual int NumDofPerNode(const DRT::Node& node) const
  {return parent_->NumDofPerNode(node);}

  virtual int NumDofPerNode(const unsigned nds,const DRT::Node& node,  const std::string disname = std::string("dummy")) const
  {return parent_->NumDofPerNode(nds,node,disname);}

  //! Return a pointer to the parent element of this boundary element
  virtual DRT::ELEMENTS::Transport* ParentElement() const
  {return parent_;}

  //! Return a boundary element id of this boundary element
  virtual int BeleNumber()
  {
    return lbeleid_;
  }


  /*!
  \brief Get number of degrees of freedom per element
         (implements pure virtual DRT::Element)

  The element decides how many element degrees of freedom it has.
  It can re-decide along the way of a simulation.

  \note Element degrees of freedom mentioned here are dofs that are visible
        at the level of the total system of equations. Purely internal
        element dofs that are condensed internally should NOT be considered.
  */
  virtual int NumDofPerElement() const { return 0; }

  /*!
  \brief Print this element
  */
  void Print(std::ostream& os) const;

  /*!
  \brief Return ElementType
  */
  virtual DRT::ElementType & ElementType() const
  { return TransportBoundaryType::Instance(); }

  //@}

  //! @name Evaluation

  /*!
  \brief Evaluate an element

  Evaluate Transport element stiffness, mass, internal forces etc

  \param params (in/out): ParameterList for communication between control routine
                          and elements
  \param discretization (in): A reference to the underlying discretization
  \param lm (in):         location vector of this element
  \param elemat1 (out)  : matrix to be filled by element. If NULL on input,
                          the controling method does not epxect the element to fill
                          this matrix.
  \param elemat2 (out)  : matrix to be filled by element. If NULL on input,
                          the controling method does not epxect the element to fill
                          this matrix.
  \param elevec1 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \param elevec2 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \param elevec3 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \return 0 if successful, negative otherwise
  */
  int Evaluate(Teuchos::ParameterList& params,
               DRT::Discretization&      discretization,
               std::vector<int>&         lm,
               Epetra_SerialDenseMatrix& elemat1,
               Epetra_SerialDenseMatrix& elemat2,
               Epetra_SerialDenseVector& elevec1,
               Epetra_SerialDenseVector& elevec2,
               Epetra_SerialDenseVector& elevec3);

  //@}

  //! @name Evaluate methods

  /*!
  \brief Evaluate a Neumann boundary condition

  this method evaluates a surface Neumann condition on the Transport element

  \param params (in/out)    : ParameterList for communication between control routine
                              and elements
  \param discretization (in): A reference to the underlying discretization
  \param condition (in)     : The condition to be evaluated
  \param lm (in)            : location vector of this element
  \param elevec1 (out)      : vector to be filled by element. If NULL on input,

  \return 0 if successful, negative otherwise
  */
  virtual int EvaluateNeumann(Teuchos::ParameterList& params,
                              DRT::Discretization&      discretization,
                              DRT::Condition&           condition,
                              std::vector<int>&         lm,
                              Epetra_SerialDenseVector& elevec1,
                              Epetra_SerialDenseMatrix* elemat1 = NULL);

  //@}

  /*!
  \brief Return the location vector of this element

  The method computes degrees of freedom this element adresses.
  Degree of freedom ordering is as follows:<br>
  First all degrees of freedom of adjacent nodes are numbered in
  local nodal order, then the element internal degrees of freedom are
  given if present.<br>
  If a derived element has to use a different ordering scheme,
  it is welcome to overload this method as the assembly routines actually
  don't care as long as matrices and vectors evaluated by the element
  match the ordering, which is implicitly assumed.<br>
  Length of the output vector matches number of degrees of freedom
  exactly.<br>
  This version is intended to fill the LocationArray with the dofs
  the element will assemble into. In the standard case these dofs are
  the dofs of the element itself. For some special conditions (e.g.
  the weak dirichlet boundary condtion) a surface element will assemble
  into the dofs of a volume element.<br>

  \note The degrees of freedom returned are not neccessarily only nodal dofs.
        Depending on the element implementation, output might also include
        element dofs.

  \param dis (in)      : the discretization this element belongs to
  \param la (out)      : location data for all dofsets of the discretization
  \param doDirichlet (in): whether to get the Dirichlet flags
  \param condstring (in): Name of condition to be evaluated
  \param condstring (in):  List of parameters for use at element level
  */
  virtual void LocationVector(const Discretization& dis,
                              LocationArray&        la,
                              bool                  doDirichlet,
                              const std::string&    condstring,
                              Teuchos::ParameterList& params
                              ) const;

private:

  // don't want = operator
  TransportBoundary& operator = (const TransportBoundary& old);

  //! The parent element of this boundary element
  DRT::ELEMENTS::Transport* parent_;

  //! The local boundary element number of this surface w.r.t to the parent_ element
  int                       lbeleid_;

}; // class TransportBoundary


} // namespace ELEMENTS
} // namespace DRT


#endif  // #ifndef DRT_SCATRA_ELEMENT_H
