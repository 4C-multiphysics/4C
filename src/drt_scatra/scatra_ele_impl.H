/*----------------------------------------------------------------------*/
/*!
\file scatra_ele_impl.H

\brief Internal implementation of scalar transport elements

<pre>
Maintainer: Georg Bauer
            bauer@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15252
</pre>
*/
/*----------------------------------------------------------------------*/

#if defined(D_FLUID2) || defined(D_FLUID3)
#ifdef CCADISCRET

#ifndef SCATRA_ELE_IMPL_H
#define SCATRA_ELE_IMPL_H


#include "scatra_ele_impl_utils.H"
#include "../drt_fem_general/drt_utils_local_connectivity_matrices.H"
#include "../drt_inpar/inpar_scatra.H"
#include <Epetra_IntSerialDenseVector.h>

namespace DRT
{
namespace ELEMENTS
{

/// Interface base class for ScaTraImpl
/*!
  This class exists to provide a common interface for all template
  versions of ScaTraImpl. The only function
  this class actually defines is Impl, which returns a pointer to
  the appropriate version of ScaTraImpl.
 */
class ScaTraImplInterface
{

public:
  /// Empty constructor
  ScaTraImplInterface() {}
  /// Empty destructor
  virtual ~ScaTraImplInterface() {}
  /// Evaluate the element
  /*!
    This class does not provide a definition for this function, it
    must be defined in ScaTraImpl.
   */
  virtual int Evaluate(DRT::Element*              ele,
                       ParameterList&             params,
                       DRT::Discretization&       discretization,
                       vector<int>&               lm,
                       Epetra_SerialDenseMatrix&  elemat1_epetra,
                       Epetra_SerialDenseMatrix&  elemat2_epetra,
                       Epetra_SerialDenseVector&  elevec1_epetra,
                       Epetra_SerialDenseVector&  elevec2_epetra,
                       Epetra_SerialDenseVector&  elevec3_epetra
                       ) = 0;

  /// Internal implementation class for scalar transport elements
  static ScaTraImplInterface* Impl(
      const DRT::Element* ele,
      const enum INPAR::SCATRA::ScaTraType scatratype);

};

  /// Internal Scalar transport element implementation
  /*!
    This internal class keeps all the working arrays needed to
    calculate the transport element. Additionally the method Sysmat()
    provides a clean and fast element implementation.

    <h3>Purpose</h3>

    The idea is to separate the element maintenance (class Transport)
    from the mathematical contents (this class). Of course there are
    different implementations of the Transport element, this is just one
    such implementation.

    The Transport element will allocate exactly one object of this class
    for all transport elements with the same number of nodes in the mesh.
    This allows us to use exactly matching working arrays (and keep them
    around.)

    The code is meant to be as clean as possible. This is the only way
    to keep it fast. The number of working arrays has to be reduced to
    a minimum so that the element fits into the cache. (There might be
    room for improvements.)

    <h3>History</h3>

    The implementation here is the standard convection-diffusion element
    capable of dealing with systems of transported scalars.

    Right now we do not read any stabilization parameters from the
    input file but have a fixed version.

    \author gjb
    \date 08/08
  */
template<DRT::Element::DiscretizationType distype>
class ScaTraImpl: public ScaTraImplInterface
{
public:
  /// Constructor
  ScaTraImpl(int numdofpernode, int numscal);

  //! number of element nodes (nomenclature: T. Hughes, The finite element method)
  static const int nen_ = DRT::UTILS::DisTypeToNumNodePerEle<distype>::numNodePerElement;

  //! number of space dimensions
  static const int nsd_ = DRT::UTILS::DisTypeToDim<distype>::dim;

  //! element-type specific flag if second derivatives are needed
  static const bool use2ndderiv_ = SCATRA::Use2ndDerivs<distype>::use;

  //! number of components necessary to store second derivatives
  // 1 component  for nsd=1:  (N,xx)
  // 3 components for nsd=2:  (N,xx ; N,yy ; N,xy)
  // 6 components for nsd=3:  (N,xx ; N,yy ; N,zz ; N,xy ; N,xz ; N,yz)
  static const int numderiv2_ = DRT::UTILS::DisTypeToNumDeriv2<distype>::numderiv2;

  //! Evaluate
  virtual int Evaluate(DRT::Element*              ele,
                       ParameterList&             params,
                       DRT::Discretization&       discretization,
                       vector<int>&               lm,
                       Epetra_SerialDenseMatrix&  elemat1_epetra,
                       Epetra_SerialDenseMatrix&  elemat2_epetra,
                       Epetra_SerialDenseVector&  elevec1_epetra,
                       Epetra_SerialDenseVector&  elevec2_epetra,
                       Epetra_SerialDenseVector&  elevec3_epetra
                       );

  private:

    //! Calculate matrix and rhs. Here the whole thing is hidden.
    virtual void Sysmat(
        DRT::Element*                         ele, ///< the element those matrix is calculated
        Epetra_SerialDenseMatrix&             sys_mat,///< element matrix to calculate
        Epetra_SerialDenseVector&             residual, ///< element rhs to calculate
        Epetra_SerialDenseVector&             subgrdiff, ///< subgrid-diff.-scaling vector
        const double                          time, ///< current simulation time
        const double                          dt, ///< current time-step length
        const double                          timefac, ///< time discretization factor
        const double                          alphaF, ///< factor for generalized-alpha time integration
        const enum INPAR::SCATRA::TauType     whichtau, ///< stabilization parameter definition
        const enum INPAR::SCATRA::AssgdType   whichassgd, ///< all-scale subgrid-diffusivity definition
        const enum INPAR::SCATRA::FSSUGRDIFF  whichfssgd, ///< fine-scale subgrid-diffusivity definition
        const bool                            assgd, ///< all-scale subgrid-diff. flag
        const bool                            fssgd, ///< fine-scale subgrid-diff. flag
        const bool                            turbmodel, ///< flag for turbulence model
        const bool                            reinitswitch,
        const double                          Cs, ///< Smagorinsky constant
        const double                          tpn, ///< turbulent Prandtl number
        const double                          frt, ///< factor F/RT needed for ELCH calculations
        const enum INPAR::SCATRA::ScaTraType  scatratype ///< type of scalar transport problem
    );

    //! calculate mass matrix and rhs for determining initial time derivative
    virtual void InitialTimeDerivative(
        DRT::Element*                         ele,  ///< the element
        Epetra_SerialDenseMatrix&             emat, ///< element matrix to calculate
        Epetra_SerialDenseVector&             erhs, ///< element rhs to calculate
        const bool                            reinitswitch,
        const double                          frt ///< factor F/RT needed for ELCH calculations
    );

    //! calculate mass matrix and rhs for determining initial time derivative
    virtual void TimeDerivativeReinit(
        DRT::Element*                         ele, ///< the element
        Epetra_SerialDenseMatrix&             emat, ///< element matrix to calculate
        Epetra_SerialDenseVector&             erhs, ///< element rhs to calculate
        const enum INPAR::SCATRA::TauType     whichtau, ///< stabilization parameter definition
        const double                          dt, ///< current time-step length
        const double                          timefac ///< time discretization factor
//        const bool                            reinitswitch,
//        const double                          frt ///< factor F/RT needed for ELCH calculations
    );

    //! calculate normalized subgrid-diffusivity matrix
    virtual void CalcSubgridDiffMatrix(
        const DRT::Element*           ele,
        Epetra_SerialDenseMatrix&     sys_mat_sd,
        const double                  timefac
    );

    //! get the body force
    virtual void BodyForce(
        const DRT::Element*    ele,  ///< the element we are dealing with
        const double           time  ///< current simulation time
    );

//REINHARD
    //! get the body force for the sign function on the right hand side in reinitialization
    virtual void BodyForceReinit(
        const DRT::Element*    ele, ///< the element we are dealing with
        const double           time ///< current simulation time
    );
//end REINHARD

    //! get the material parameters
    virtual void GetMaterialParams(const DRT::Element* ele);

    //! calculate stabilization parameter
    virtual void CalTau(
        DRT::Element*                         ele,
        double                                diffus,
        const double                          dt,
        const double                          timefac,
        const enum INPAR::SCATRA::TauType     whichtau,
        const double                          vol,
        const int                             k,
        const double                          frt,
        const bool                            migrationintau
    );

    //! calculate all-scale subgrid diffusivity
    virtual void CalcSubgrDiff(
        const double                          dt,
        const double                          timefac,
        const enum INPAR::SCATRA::AssgdType   whichassgd,
        const bool                            assgd,
        const bool                            turbmodel,
        const double                          Cs,
        const double                          tpn,
        const double                          vol,
        const int                             k
    );

    //! calculate fine-scale subgrid diffusivity
    virtual void CalcFineScaleSubgrDiff(
        DRT::Element*                         ele,
        Epetra_SerialDenseVector&             subgrdiff,
        const enum INPAR::SCATRA::FSSUGRDIFF  whichfssgd,
        const double                          Cs,
        const double                          tpn,
        const double                          vol,
        const int                             k
    );

    //! calculate subgrid-scale velocity
    virtual void CalcSubgrVelocity(
        DRT::Element* ele,
        const double  time,
        const double  dt,
        const double  timefac,
        const int     k
    );

    //! calculate subgrid-scale velocity for level set / two-phase flow problems
    virtual void CalcSubgrVelocityLevelSet(
        DRT::Element* ele,
        const double  time,
        const double  dt,
        const double  timefac,
        const int     k
//        const int id,
//        const int gp,
//        const DRT::UTILS::IntPointsAndWeights<nsd_>& intpoints,  ///< integration points
//        const int                                    iquad       ///< id of current Gauss point
    );

    //! evaluate shape functions and their derivatives at current integration point
    virtual double EvalShapeFuncAndDerivsAtIntPoint(
        const DRT::UTILS::IntPointsAndWeights<nsd_>& intpoints, ///< integration points
        const int                                    iquad,     ///< id of current Gauss point
        const int                                    eleid       ///< the element id
    );

    //! calculate element matrix and rhs vector (One-Step-Theta, BDF2, Gen.-alpha)
    virtual void CalMatAndRHS(
        Epetra_SerialDenseMatrix&             emat,
        Epetra_SerialDenseVector&             erhs,
        const double                          fac,      ///< integration factor
        const bool                            fssgd,
        const double                          timefac,
        const double                          alphaF,
        const int                             dofindex
    );

    //! calculate element matrix and rhs vector (Electrochemistry problems)
    virtual void CalMatElch(
        Epetra_SerialDenseMatrix&             emat,   ///< element matrix
        Epetra_SerialDenseVector&             erhs,   ///< element rhs
        const double                          frt,    ///< factor F/RT
        const double                          timefac,///< time discretization factor
        const double                          fac     ///< integration factor
    );

    //! calculate error compared to analytical solutions
    virtual void CalErrorComparedToAnalytSolution(
        const DRT::Element*          ele, ///< the element
        ParameterList&               params, ///< parameter list
        Epetra_SerialDenseVector&    errors
    );

    //! calculate flux vector for actual solution
    virtual void CalculateFlux(
        LINALG::Matrix<3,nen_>&         flux,
        const DRT::Element*             ele,
        const double                    frt,
        const INPAR::SCATRA::FluxType   fluxtype,
        const int                       dofindex
    );

    //! calculate scalars and domain integral
   virtual void CalculateScalars(
        const DRT::Element*       ele,      ///< pointer to the element
        const vector<double>&     ephinp,   ///< current scalar field
        Epetra_SerialDenseVector& scalars,  ///< vector for computed integrals
        const bool                inverting ///< flag for invertuing
        );

    //! calculate domain and bodyforce integral
   virtual void CalculateDomainAndBodyforce(
        Epetra_SerialDenseVector&  scalars, ///< vector for the computed integrals
        const DRT::Element*        ele,     ///< pointer to the element
        const double               time,    ///< current simulation time
        const bool                 reinitswitch
        );

   //! integral of shape functions over the element
   void IntegrateShapeFunctions(
       const DRT::Element*                ele,    ///< the current element
       Epetra_SerialDenseVector&          elevec1,///< result vector (to be assembled)
       const Epetra_IntSerialDenseVector& dofids  ///< for which dof we need to integrate?
   );

   //! calculate conductivity of electrolyte solution
   void CalculateConductivity(
       const DRT::Element*       ele,  ///< the current element
       const double              frt,  ///< factor F/RT needed for ELCH calculations
       Epetra_SerialDenseVector& sigma ///< values for different conductivity expressions
       );

   //! calculate el. potential field based on ion concentrations
   void CalculateElectricPotentialField(
       const DRT::Element*         ele,  ///<the current element
       const double                frt,  ///< factor F/RT needed for ELCH calculations
       Epetra_SerialDenseMatrix&   emat, ///< matrix (to be assembled)
       Epetra_SerialDenseVector&   erhs  ///< rhs-vector (to be assembled)
   );

    //! calculate the Laplacian for all shape functions(strong form)
    inline void GetLaplacianStrongForm
    (
      LINALG::Matrix<nen_,1>& diff,
      const LINALG::Matrix<numderiv2_,nen_>& deriv2
     )
    {
      diff.Clear();
      // compute N,xx  +  N,yy +  N,zz for each shape function at integration point
      for (int i=0; i<nen_; ++i)
      {
        for (int j = 0; j<nsd_; ++j)
        {
          diff(i) += deriv2(j,i);
        }
      }
      return;
    };

    //! calculate the Laplacian (weak form)
    inline void GetLaplacianWeakForm(
        double& val,
        const LINALG::Matrix<nsd_,nen_>& derxy,
        const int vi,
        const int ui)
    {
      val = 0.0;
      for (int j = 0; j<nsd_; j++)
      {
        val += derxy(j, vi)*derxy(j, ui);
      }
      return;
    };

    //! calculate the Laplacian (weak form)
    inline void GetLaplacianWeakFormRHS(
        double& val,
        const LINALG::Matrix<nsd_,nen_>& derxy,
        const LINALG::Matrix<nsd_,1>&   gradphi,
        const int vi)
    {
      val = 0.0;
      for (int j = 0; j<nsd_; j++)
      {
        val += derxy(j,vi)*gradphi(j);
      }
      return;
    };

    //! calculate divergence of vector field (e.g., velocity)
    inline void GetDivergence(double&                               vdiv,
                                      const LINALG::Matrix<nsd_,nen_>&       evel,
                                      const LINALG::Matrix<nsd_,nen_>&       derxy)
    {
      LINALG::Matrix<nsd_,nsd_> vderxy;
      vderxy.MultiplyNT(evel,derxy);

      vdiv = 0.0;
      // compute vel x,x  + vel y,y +  vel z,z at integration point
      for (int j = 0; j<nsd_; ++j)
      {
        vdiv += vderxy(j,j);
      }
      return;
    };

    //! calculate rate of strain of (fine-scale) velocity
    inline double GetStrainRate(const LINALG::Matrix<nsd_,nen_>& evel,
                                const LINALG::Matrix<nsd_,nen_>& derxy,
                                LINALG::Matrix<nsd_,nsd_>     & velderxy)
    {
      double rateofstrain=0;

      // get velocity derivatives at integration point
      //
      //              +-----  dN (x)
      //   dvel (x)    \        k
      //   -------- =   +     ------ * vel
      //      dx       /        dx        k
      //        j     +-----      j
      //              node k
      //
      // j : direction of derivative x/y/z
      //
      velderxy.MultiplyNT(evel,derxy);

      // compute (resolved) rate of strain
      //
      //          +-                                 -+ 1
      //          |          /   \           /   \    | -
      //          | 2 * eps | vel |   * eps | vel |   | 2
      //          |          \   / ij        \   / ij |
      //          +-                                 -+
      //
      LINALG::Matrix<nsd_,nsd_> two_epsilon;
      for(int rr=0;rr<nsd_;++rr)
      {
        for(int mm=0;mm<nsd_;++mm)
        {
          two_epsilon(rr,mm) = velderxy(rr,mm) + velderxy(mm,rr);
        }
      }

      for(int rr=0;rr<nsd_;rr++)
      {
        for(int mm=0;mm<nsd_;mm++)
        {
          rateofstrain += two_epsilon(rr,mm)*two_epsilon(mm,rr);
        }
      }

      // sqrt(two_epsilon(rr,mm)*two_epsilon(mm,rr)/4.0*2.0)

      return(sqrt(rateofstrain/2.0));
    }


    // Finite difference check for debugging purposes
    void FDcheck(
        DRT::Element*                         ele, ///< the element those matrix is calculated
        Epetra_SerialDenseMatrix&             sys_mat,///< element matrix to calculate
        Epetra_SerialDenseVector&             residual, ///< element rhs to calculate
        Epetra_SerialDenseVector&             subgrdiff, ///< subgrid-diff.-scaling vector
        const double                          time, ///< current simulation time
        const double                          dt, ///< current time-step length
        const double                          timefac, ///< time discretization factor
        const double                          alphaF, ///< factor for generalized-alpha time integration
        const enum INPAR::SCATRA::TauType     whichtau, ///< stabilization parameter definition
        const enum INPAR::SCATRA::AssgdType   whichassgd, ///< all-scale subgrid-diffusivity definition
        const enum INPAR::SCATRA::FSSUGRDIFF  whichfssgd, ///< fine-scale subgrid-diffusivity definition
        const bool                            assgd, ///< all-scale subgrid-diff. flag
        const bool                            fssgd, ///< fine-scale subgrid-diff. flag
        const bool                            turbmodel, ///< turbulence model flag
        const bool                            reinitswitch,
        const double                          Cs, ///< Smagorinsky constant
        const double                          tpn, ///< turbulent Prandtl number
        const double                          frt, ///< factor F/RT needed for ELCH calculations
        const enum INPAR::SCATRA::ScaTraType  scatratype ///< type of scalar transport problem
      );


    //! number of dof per node
    const int numdofpernode_;
    //! number of transported scalars (numscal_ <= numdofpernode_)
    const int numscal_;

    //! flag for electrochemistry problems (ELCH)
    const bool iselch_;
    //! flag for using ALE formulation
    bool isale_;
    //! flag for inclusion of reactive terms
    bool reaction_;
    //! (sign) factor for diffusive and reactive stabilization terms
    double diffreastafac_;
    //! flag for stationary algorithm
    bool is_stationary_;
    //! flag for generalized-alpha time integration
    bool is_genalpha_;
    //! flag for incremental solver
    bool is_incremental_;
    //! flag for conservative form of convective term
    bool conservative_;
    //! flag for inclusion of subgrid-scale velocity
    bool sgvel_;
    //! flag for material evaluation at Gaussian integration points
    bool mat_gp_;
    //! flag for stabilization parameter evaluation at Gaussian integration points
    bool tau_gp_;

    //! nodal velocity values at t_(n+1) or t_(n+alpha_F)
    LINALG::Matrix<nsd_,nen_> evelnp_;
    //! nodal acceleration values at t_(n+1) or t_(n+alpha_F)
    LINALG::Matrix<nsd_,nen_> eaccnp_;
    //! nodal pressure values at t_(n+1) or t_(n+alpha_F)
    LINALG::Matrix<nen_,1> eprenp_;
    //! scalar at t_(n)
    vector<LINALG::Matrix<nen_,1> > ephin_;
    //! scalar at t_(n+1) or t_(n+alpha_F)
    vector<LINALG::Matrix<nen_,1> > ephinp_;
    //! scalar at t_(n+alpha_M)
    vector<LINALG::Matrix<nen_,1> > ephiam_;
    //! history vector of transported scalars
    vector<LINALG::Matrix<nen_,1> > ehist_;
    //! electric potential (ELCH)
    LINALG::Matrix<nen_,1> epotnp_;
    //! magnetic field at t_(n+1) (ELCH)
    LINALG::Matrix<nsd_,nen_> emagnetnp_;
    //! fine-scale solution
    vector<LINALG::Matrix<nen_,1> > fsphinp_;
    //! nodal displacement values for ALE
    LINALG::Matrix<nsd_,nen_> edispnp_;

    //! node coordinates
    LINALG::Matrix<nsd_,nen_> xyze_;
    //! weights for nurbs elements
    LINALG::Matrix<nen_,1> weights_;
    //! knot vector for nurbs elements
    std::vector<Epetra_SerialDenseVector> myknots_;
    //! bodyforce in element nodes
    vector<LINALG::Matrix<nen_,1> > bodyforce_;
    //! density at t_(n)
    vector<double> densn_;
    //! density at t_(n+1) or t_(n+alpha_F)
    vector<double> densnp_;
    //! density at t_(n+alpha_M)
    vector<double> densam_;
    //! factor for density derivative (at t_(n+1) or t_(n+alpha_F))
    vector<double> densgradfac_;
    //! diffusivity / diffusivities (in case of systems) / thermal conductivity
    vector<double> diffus_;
    //! reaction coefficient
    vector<double> reacoeff_;
    //! charge numbers of all ion species (ELCH specific)
    vector<double> valence_;
    //! diffusivity times valence for each ion species (ELCH specific)
    vector<double> diffusvalence_;
    //! specific heat capacity at constant pressure (in case of temp. or react. eq.)
    double shcacp_;
    //! fluid viscosity
    double visc_;
    //! coordinates of current integration point in reference coordinates
    LINALG::Matrix<nsd_,1> xsi_;
    //! array for shape functions
    LINALG::Matrix<nen_,1> funct_;
    //! array for shape function derivatives w.r.t r,s,t
    LINALG::Matrix<nsd_,nen_> deriv_;
    //! array for second derivatives of shape function w.r.t r,s,t
    LINALG::Matrix<numderiv2_,nen_> deriv2_;
    //! transposed jacobian "dx/ds"
    LINALG::Matrix<nsd_,nsd_> xjm_;
    //! inverse of transposed jacobian "ds/dx"
    LINALG::Matrix<nsd_,nsd_> xij_;
    //! global derivatives of shape functions w.r.t x,y,z
    LINALG::Matrix<nsd_,nen_> derxy_;
    //! global second derivatives of shape functions w.r.t x,y,z
    LINALG::Matrix<numderiv2_,nen_> derxy2_;
    //! global velocity derivatives in gausspoint w.r.t x,y,z
    LINALG::Matrix<nsd_,nsd_> vderxy_;
    //! rhs force in Gauss point
    vector<double> rhs_;
    //! rhs of temperature equation in case of reactive equation system
    vector<double> reatemprhs_;
    //! vector containing all values from previous timelevel n in gausspoint
    vector<double> hist_;
    //! velocity vector in gausspoint
    LINALG::Matrix<nsd_,1> velint_;
    //! subgrid-scale velocity vector in gausspoint
    LINALG::Matrix<nsd_,1> sgvelint_;
    //! migration velocity vector (divided by D_k*z_k) in gausspoint (ELCH)
    LINALG::Matrix<nsd_,1> migvelint_;
    //! velocity divergence
    double vdiv_;
    //! the stabilisation parameters (one per transported scalar)
    vector<double> tau_;
    //! corner stabilisation parameters (one per transported scalar)
    vector<double> tau_corner_;
    //! all-scale or fine-scale subgrid diffusivities (one per transported scalar)
    vector<double> sgdiff_;
    //! 2nd derivatives of coord.-functions w.r.t r,s,t
    LINALG::Matrix<numderiv2_,nsd_> xder2_;
    //! convective term
    LINALG::Matrix<nen_,1> conv_;
    //! subgrid-scale convective term
    LINALG::Matrix<nen_,1> sgconv_;
    //! diffusive part used in stabilization terms
    LINALG::Matrix<nen_,1> diff_;
    //! convective part of migration term (divided by D_k*z_k) used in stabilization terms (ELCH)
    LINALG::Matrix<nen_,1> migconv_;
    // reactive part of migration term used in stabilization terms
    LINALG::Matrix<nen_,1> migrea_;
    //! (global) gradient of el. potential at integration point (ELCH)
    LINALG::Matrix<nsd_,1> gradpot_;
    //! values of all transported scalars in gausspoint (ELCH)
    vector<double> conint_;
    //! (global) gradient of transported scalar at integration point
    LINALG::Matrix<nsd_,1> gradphi_;
    //! (global) gradient of fine-scale part of scalar at integration point
    LINALG::Matrix<nsd_,1> fsgradphi_;
    //! (global) Laplacian of shape functions at integration point
    LINALG::Matrix<nen_,1> laplace_;
    //! thermodynamic pressure at t_(n+1) or t_(n+alpha_F) (LOMA specific)
    double thermpressnp_;
    //! thermodynamic pressure at t_(n+alpha_M) (LOMA specific)
    double thermpressam_;
    //! time derivative of thermodynamic pressure (LOMA specific)
    double thermpressdt_;
    //! reconstructed flux values via L2 projection
    vector<LINALG::Matrix<nsd_,nen_> > efluxreconstr_;
    //! flag whether consistency of stabilized method should be improved or not
    bool betterconsistency_;
    //! derivative of stabilization parameter with respect to el. potential (ELCH)
    vector<LINALG::Matrix<nen_,1> > tauderpot_;
    //! use migration velocity in formula for stabilization parameter (ELCH)
    bool migrationintau_;
    //! use migration velocity in the stabilization operator (ELCH)
    bool migrationstab_;

  };

}
}

#endif

#endif // CCADISCRET
#endif // D_FLUID3 or D_FLUID2

