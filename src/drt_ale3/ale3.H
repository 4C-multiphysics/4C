//-----------------------------------------------------------------------
/*!
\file ale3.H

<pre>

</pre>
*/
//-----------------------------------------------------------------------
#ifdef D_ALE
#ifdef CCADISCRET

#ifndef ALE3_H
#define ALE3_H

#include <Teuchos_RefCountPtr.hpp>
#include <Epetra_Vector.h>

using namespace std;
using namespace Teuchos;

#include "../drt_lib/drt_element.H"
#include "../drt_lib/drt_elementregister.H"
#include "../drt_lib/drt_node.H"
#include "../drt_fem_general/drt_utils_integration.H"

struct _MATERIAL;

namespace DRT
{

class Discretization;
class Ale3Register;

namespace ELEMENTS
{

class Ale3Surface;



/*!
\brief A C++ wrapper for the ale3 element
*/
class Ale3 : public DRT::Element
{
public:

  //! @name Friends
  friend class Ale3Register;
  friend class Ale3Surface;

  //@}
  //! @name Constructors and destructors and related methods

  /*!
  \brief Standard Constructor

  \param id : A unique global id
  */
  Ale3(int id, int owner);

  /*!
  \brief Copy Constructor

  Makes a deep copy of a Element

  */
  Ale3(const Ale3& old);

  /*!
  \brief Deep copy this instance of Ale3 and return pointer to the copy

  The Clone() method is used from the virtual base class Element in cases
  where the type of the derived class is unknown and a copy-ctor is needed

  */
  DRT::Element* Clone() const;

  /*!
  \brief Get shape type of element
  */
  virtual DiscretizationType Shape() const;

  /*!
  \brief Return number of lines of this element
  */
  virtual int NumLine() const {return 0;}

  /*!
  \brief Return number of surfaces of this element
  */
  virtual int NumSurface() const
  {if (NumNode()==8 || NumNode()==20 || NumNode()==27) return 6;
   else if (NumNode()==4 || NumNode()==10) return 4;
   else if (NumNode()==6 || NumNode()==15 || NumNode()==5) return 5;
   else {
   	dserror("Could not determine number of surfaces");
   	return -1;
	}
  }

  /*!
  \brief Return number of volumes of this element (always 1)
  */
  virtual int NumVolume() const {return 1;}

  /*!
  \brief Get vector of RefCountPtrs to the surfaces of this element

  */
  virtual vector<RCP<DRT::Element> > Surfaces();

  /*!
  \brief Get vector of RefCountPtrs to the volume of this element

  */
  virtual vector<RCP<DRT::Element> > Volumes();

  /*!
  \brief Return unique ParObject id

  every class implementing ParObject needs a unique id defined at the
  top of this file.
  */
  virtual int UniqueParObjectId() const { return ParObject_Ale3;}

  /*!
  \brief Pack this class so it can be communicated

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Pack(vector<char>& data) const;

  /*!
  \brief Unpack data from a char vector into this class

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Unpack(const vector<char>& data);

  /*!
  \brief Destructor

  */
  virtual ~Ale3();

  //@}

  //! @name Acess methods


  /*!
  \brief Get number of degrees of freedom of a certain node
         (implements pure virtual DRT::Element)

  The element decides how many degrees of freedom its nodes must have.
  As this may vary along a simulation, the element can redecide the
  number of degrees of freedom per node along the way for each of it's nodes
  separately.
  */
  virtual int NumDofPerNode(const DRT::Node& node) const {return 3;}

  /*!
  \brief Get number of degrees of freedom per element
         (implements pure virtual DRT::Element)

  The element decides how many element degrees of freedom it has.
  It can redecide along the way of a simulation.

  \note Element degrees of freedom mentioned here are dofs that are visible
        at the level of the total system of equations. Purely internal
        element dofs that are condensed internally should NOT be considered.
  */
  virtual int NumDofPerElement() const { return 0; }

  /*!
  \brief Print this element
  */
  void Print(ostream& os) const;

  /*!
  \brief Allocate and return a DesignElementRegister class

  Every implementation of DRT::Element must also implement
  an DRT::ElementRegister. This method allocates and returns
  an instance of a matching DRT::ElementRegister.
  */
  virtual RefCountPtr<DRT::ElementRegister> ElementRegister() const;

  //@}

  //! @name Input and Creation

  /*!
  \brief Read input for this element
  */
  bool ReadElement();

  //@}

  //! @name Evaluation

  /*!
  \brief Evaluate an element

  Evaluate ale3 element stiffness, mass, internal forces etc

  \param params (in/out): ParameterList for communication between control routine
                          and elements
  \param elemat1 (out)  : matrix to be filled by element. If NULL on input,
                          the controling method does not epxect the element to fill
                          this matrix.
  \param elemat2 (out)  : matrix to be filled by element. If NULL on input,
                          the controling method does not epxect the element to fill
                          this matrix.
  \param elevec1 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \param elevec2 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \param elevec3 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \return 0 if successful, negative otherwise
  */
  int Evaluate(ParameterList& params,
               DRT::Discretization&      discretization,
               vector<int>&              lm,
               Epetra_SerialDenseMatrix& elemat1,
               Epetra_SerialDenseMatrix& elemat2,
               Epetra_SerialDenseVector& elevec1,
               Epetra_SerialDenseVector& elevec2,
               Epetra_SerialDenseVector& elevec3);


  /*!
  \brief Evaluate a Neumann boundary condition

  this method evaluates a surfaces Neumann condition on the shell element

  \param params (in/out)    : ParameterList for communication between control routine
                              and elements
  \param discretization (in): A reference to the underlying discretization
  \param condition (in)     : The condition to be evaluated
  \param lm (in)            : location vector of this element
  \param elevec1 (out)      : vector to be filled by element. If NULL on input,

  \return 0 if successful, negative otherwise
  */
  virtual int EvaluateNeumann(ParameterList& params,
                              DRT::Discretization&      discretization,
                              DRT::Condition&           condition,
                              vector<int>&              lm,
                              Epetra_SerialDenseVector& elevec1);


  //@}

  //! @name Other

  //@}


private:

  void ale3_edge_geometry(int i, int j, const Epetra_SerialDenseMatrix& xyze,
                          double* length,
                          double* edge_x,
                          double* edge_y,
                          double* edge_z);
  double ale3_area_tria(const Epetra_SerialDenseMatrix& xyze,
                        int i, int j, int k);

  /*!
  \brief Calculates stiffness for triangle ijk with torsional springs.

  According to Farhat et al.

  \param i, j, k (in)    : Nodes
  \param xyze (in)     : The actual element coordinates (2D). Values for given
  nodes in columns i, j, k.
  \param k_torsion (out): 2-dimensional stiffness-matrix. Succession i, j, k.
  */
  void ale3_torsional(int i, int j, int k,
                      const Epetra_SerialDenseMatrix& xyze,
                      Epetra_SerialDenseMatrix* k_torsion);

  /*!
  \brief Prevents node s from penetrating face pqr.

  The calculated dynamic triangle sjq is perpendicular to edge pr and face
  pqr. According to Farhat et al.

  \param node_i (in)    : Determine position of triangle sjq in
  tetrahedra.
  \param sysmat (in/out): The element's sys_mat
  \param xyze (in)     : The actual element coordinates
  */
  void ale3_add_tria_stiffness(int node_p, int node_q, int node_r, int node_s,
                               Epetra_SerialDenseMatrix* sys_mat,
                               const Epetra_SerialDenseMatrix& xyze);

  /*!
  \brief Prevents node-face-penetration for given nodes.

  Twelve-triangle configuration. According to Farhat et al.

  \param tet_i (in)    : Nodes. Arbitrary succession.
  \param sysmat (in/out): The element's sys_mat
  \param xyze (in)     : The actual element coordinates
  */
  void ale3_add_tetra_stiffness(int tet_0, int tet_1, int tet_2, int tet_3,
                                Epetra_SerialDenseMatrix* sys_mat,
                                const Epetra_SerialDenseMatrix& xyze);
  void ale3_tors_spring_tet4(Epetra_SerialDenseMatrix* sys_mat,
                             const Epetra_SerialDenseMatrix& xyze);
  void ale3_tors_spring_pyramid5(Epetra_SerialDenseMatrix* sys_mat,
                                 const Epetra_SerialDenseMatrix& xyze);
  void ale3_tors_spring_wedge6(Epetra_SerialDenseMatrix* sys_mat,
                               const Epetra_SerialDenseMatrix& xyze);
  void ale3_tors_spring_hex8(Epetra_SerialDenseMatrix* sys_mat,
                             const Epetra_SerialDenseMatrix& xyze);
  void static_ke_spring(Epetra_SerialDenseMatrix* sys_mat,
                        vector<double>& displacements);
  void static_ke(vector<int>&              lm,
                 Epetra_SerialDenseMatrix* sys_mat,
                 Epetra_SerialDenseVector* residual,
                 RefCountPtr<MAT::Material> material,
                 ParameterList& 	   params);

  //! action parameters recognized by ale3
  enum ActionType
  {
    none,
    calc_ale_lin_stiff,
    calc_ale_spring
  };

  //! Gaussrule
  //DRT::UTILS::GaussRule3D                         gaussrule_;

  //! container containing all kind of ale3 thisandthat
  DRT::Container                                  data_;


  // internal calculation methods

  // don't want = operator
  Ale3& operator = (const Ale3& old);

  // get optimal gaussrule for given discretization type
  DRT::UTILS::GaussRule3D getOptimalGaussrule(const DiscretizationType& distype);
};


//=======================================================================
//=======================================================================
//=======================================================================
//=======================================================================


/*!
\brief A register for ale3 element

\author gee (gee@lnm.mw.tum.de)
*/
class Ale3Register : public DRT::ElementRegister
{
public:

  //! @name Constructors and destructors and related methods

  /*!
  \brief Standard Constructor

  */
  Ale3Register(DRT::Element::ElementType etype);

  /*!
  \brief Copy Constructor

  Makes a deep copy of an Ale3Register

  */
  Ale3Register(const DRT::ELEMENTS::Ale3Register& old);

  /*!
  \brief Deep copy this instance of Ale3Register and return pointer to the copy

  The Clone() method is used from the virtual base class Element in cases
  where the type of the derived class is unknown and a copy-ctor is needed

  */
  DRT::ELEMENTS::Ale3Register* Clone() const;

  /*!
  \brief Return unique ParObject id

  every class imploementing ParObject needs a unique id defined at the
  top of this file.
  */
  virtual int UniqueParObjectId() const { return ParObject_Ale3Register;}

  /*!
  \brief Pack this class so it can be communicated

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Pack(vector<char>& data) const;

  /*!
  \brief Unpack data from a char vector into this class

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Unpack(const vector<char>& data);

  /*!
  \brief Destructor

  */
  virtual ~Ale3Register();

  //@}

  //! @name Acess methods

  /*!
  \brief Print this element
  */
  void Print(ostream& os) const;

  //@}

  //! @name Construction

  /*!
  \brief Call Element init routines

  The method performs all steps needed to init the ale3 elements. it e.g. calculates the
  field of averaged directors at nodes.
  */
  int Initialize(DRT::Discretization& dis);

  //@}

private:


}; // class Ale3Register


//=======================================================================
//=======================================================================
//=======================================================================
//=======================================================================


/*!
\brief An element representing a surface of a ale3 element

\note This is a pure Neumann boundary condition element. It's only
      purpose is to evaluate surface Neumann boundary conditions that might be
      adjacent to a parent ale3 element. It therefore does not implement
      the DRT::Element::Evaluate method and does not have its own ElementRegister class.

\author gee (gee@lnm.mw.tum.de)
*/
class Ale3Surface : public DRT::Element
{
public:

  //! @name Constructors and destructors and related methods

  /*!
  \brief Standard Constructor

  \param id : A unique global id
  \param owner: Processor owning this surface
  \param nnode: Number of nodes attached to this element
  \param nodeids: global ids of nodes attached to this element
  \param nodes: the discretizations map of nodes to build ptrs to nodes from
  \param parent: The parent ale element of this surface
  \param lsurface: the local surface number of this surface w.r.t. the parent element
  */
  Ale3Surface(int id, int owner, int nnode, const int* nodeids,
             DRT::Node** nodes, DRT::ELEMENTS::Ale3* parent, const int lsurface);

  /*!
  \brief Copy Constructor

  Makes a deep copy of a Element

  */
  Ale3Surface(const Ale3Surface& old);

  /*!
  \brief Deep copy this instance of an element and return pointer to the copy

  The Clone() method is used from the virtual base class Element in cases
  where the type of the derived class is unknown and a copy-ctor is needed

  */
  DRT::Element* Clone() const;

  /*!
  \brief Get shape type of element
  */
  virtual DiscretizationType Shape() const;

  /*!
  \brief Return unique ParObject id

  every class implementing ParObject needs a unique id defined at the
  top of the drt_parobject.H file.
  */
  virtual int UniqueParObjectId() const { return ParObject_Ale3Surface;}

  /*!
  \brief Pack this class so it can be communicated

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Pack(vector<char>& data) const;

  /*!
  \brief Unpack data from a char vector into this class

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Unpack(const vector<char>& data);

  /*!
  \brief Destructor

  */
  virtual ~Ale3Surface();

  //@}

  //! @name Acess methods


  /*!
  \brief Get number of degrees of freedom of a certain node
         (implements pure virtual DRT::Element)

  The element decides how many degrees of freedom its nodes must have.
  As this may vary along a simulation, the element can redecide the
  number of degrees of freedom per node along the way for each of it's nodes
  separately.
  */
  virtual int NumDofPerNode(const DRT::Node& node) const { return 3; }

  /*!
  \brief Get number of degrees of freedom per element
         (implements pure virtual DRT::Element)

  The element decides how many element degrees of freedom it has.
  It can redecide along the way of a simulation.

  \note Element degrees of freedom mentioned here are dofs that are visible
        at the level of the total system of equations. Purely internal
        element dofs that are condensed internally should NOT be considered.
  */
  virtual int NumDofPerElement() const { return 0; }

  /*!
  \brief Print this element
  */
  void Print(ostream& os) const;

  /*!
  \brief Allocate and return a ElementRegister class

  Every implementation of DRT::Element must also implement
  an DRT::ElementRegister. This method allocates and returns
  an instance of a matching DRT::ElementRegister.
  */
  virtual RefCountPtr<DRT::ElementRegister> ElementRegister() const { return null; }

  //@}

  //! @name Evaluate methods

  /*!
  \brief Evaluate a Neumann boundary condition

  this method evaluates a surface Neumann condition on the ale3 element

  \param params (in/out)    : ParameterList for communication between control routine
                              and elements
  \param discretization (in): A reference to the underlying discretization
  \param condition (in)     : The condition to be evaluated
  \param lm (in)            : location vector of this element
  \param elevec1 (out)      : vector to be filled by element. If NULL on input,

  \return 0 if successful, negative otherwise
  */
  virtual int EvaluateNeumann(ParameterList& params,
                              DRT::Discretization&      discretization,
                              DRT::Condition&           condition,
                              vector<int>&              lm,
                              Epetra_SerialDenseVector& elevec1);

  //@}

private:

  // don't want = operator
  Ale3Surface& operator = (const Ale3Surface& old);

  //! The parent element of this surface
  DRT::ELEMENTS::Ale3* parent_;
  //! The local surface number of this surface w.r.t to the parent_ element
  int                    lsurface_;

  //  compute kovariant metric tensor G for ale surface element
  //                                                  gammi 04/07
  void  f3_metric_tensor_for_surface(
    const Epetra_SerialDenseMatrix  xyze,
    const Epetra_SerialDenseMatrix  deriv,
    Epetra_SerialDenseMatrix&       metrictensor,
    double                         *drs);

}; // class Ale3Surface




} // namespace ELEMENTS
} // namespace DRT



#endif
#endif
#endif
