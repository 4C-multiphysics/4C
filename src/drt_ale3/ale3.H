//-----------------------------------------------------------------------
/*!
\file ale3.H

<pre>

</pre>
*/
//-----------------------------------------------------------------------
#ifdef D_ALE


#ifndef ALE3_H
#define ALE3_H

#include <Teuchos_RefCountPtr.hpp>
#include <Epetra_Vector.h>

using namespace std;
using namespace Teuchos;

#include "../drt_lib/drt_element.H"
#include "../drt_lib/drt_elementtype.H"
#include "../drt_lib/drt_parobjectfactory.H"
#include "../drt_lib/drt_node.H"
#include "../drt_fem_general/drt_utils_integration.H"
#include "../drt_fem_general/drt_utils_local_connectivity_matrices.H"

namespace DRT
{

class Discretization;

namespace ELEMENTS
{

  // where should that be put?
  template <DRT::Element::DiscretizationType dtype>
  struct DisTypeToNumCornerNodes {};
  template<> struct DisTypeToNumCornerNodes<DRT::Element::tet4>     {static const int numCornerNodes = 4;};
  template<> struct DisTypeToNumCornerNodes<DRT::Element::tet10>    {static const int numCornerNodes = 4;};
  template<> struct DisTypeToNumCornerNodes<DRT::Element::hex8>     {static const int numCornerNodes = 8;};
  template<> struct DisTypeToNumCornerNodes<DRT::Element::hex20>    {static const int numCornerNodes = 8;};
  template<> struct DisTypeToNumCornerNodes<DRT::Element::hex27>    {static const int numCornerNodes = 8;};
  template<> struct DisTypeToNumCornerNodes<DRT::Element::pyramid5> {static const int numCornerNodes = 5;};
  template<> struct DisTypeToNumCornerNodes<DRT::Element::wedge6>   {static const int numCornerNodes = 6;};
  template<> struct DisTypeToNumCornerNodes<DRT::Element::wedge15>  {static const int numCornerNodes = 6;};
  template<> struct DisTypeToNumCornerNodes<DRT::Element::nurbs8>   {static const int numCornerNodes = 8;};
  template<> struct DisTypeToNumCornerNodes<DRT::Element::nurbs27>  {static const int numCornerNodes = 8;};



class Ale3Surface;
class Ale3_Impl_Interface;
template <DRT::Element::DiscretizationType distype> class Ale3_Impl;


class Ale3Type : public DRT::ElementType
{
public:

  std::string Name() const { return "Ale3Type"; }

  static Ale3Type & Instance() { return instance_; };

  virtual DRT::ParObject* Create( const vector<char> & data );

  virtual Teuchos::RCP<DRT::Element> Create( const string eletype,
                                             const string eledistype,
                                             const int id,
                                             const int owner );

  virtual Teuchos::RCP<DRT::Element> Create( const int id, const int owner );

  virtual void NodalBlockInformation( DRT::Element * dwele, int & numdf, int & dimns, int & nv, int & np );

  virtual void ComputeNullSpace( DRT::Discretization & dis, std::vector<double> & ns, const double * x0, int numdf, int dimns );

  virtual void SetupElementDefinition( std::map<std::string,std::map<std::string,DRT::INPUT::LineDefinition> > & definitions );

private:

  static Ale3Type instance_;
};



/*!
\brief A C++ wrapper for the ale3 element
*/
class Ale3 : public DRT::Element
{
public:

  //! @name Friends
  friend class Ale3Surface;
  //friend class Ale3_Impl_Interface;
  //friend class Ale3_Impl<

  //@}
  //! @name Constructors and destructors and related methods

  /*!
  \brief Standard Constructor

  \param id : A unique global id
  */
  Ale3(int id, int owner);

  /*!
  \brief Copy Constructor

  Makes a deep copy of a Element

  */
  Ale3(const Ale3& old);

  /*!
  \brief Deep copy this instance of Ale3 and return pointer to the copy

  The Clone() method is used from the virtual base class Element in cases
  where the type of the derived class is unknown and a copy-ctor is needed

  */
  DRT::Element* Clone() const;

  /*!
  \brief Get shape type of element
  */
  virtual DiscretizationType Shape() const;

  /*!
  \brief Return number of lines of this element
  */
  virtual int NumLine() const {return 0;}

  /*!
  \brief Return number of surfaces of this element
  */
  virtual int NumSurface() const
    {
      switch (NumNode()) {
      case 8:
      case 20:
      case 27:
        return 6; // hex
      case 4:
      case 10:
        return 4; // tet
      case 6:
      case 15:
      case 5:
        return 5; // wedge or pyramid
      default:
        dserror("Could not determine number of surfaces");
   	return -1;
      }
  }

  /*!
  \brief Return number of volumes of this element (always 1)
  */
  virtual inline int NumVolume() const {return 1;}

  /*!
  \brief Get vector of RefCountPtrs to the surfaces of this element

  */
  virtual vector<RCP<DRT::Element> > Surfaces();

  /*!
  \brief Get vector of RefCountPtrs to the volume of this element

  */
  virtual vector<RCP<DRT::Element> > Volumes();

  /*!
  \brief Return unique ParObject id

  every class implementing ParObject needs a unique id defined at the
  top of this file.
  */
  virtual int UniqueParObjectId() const { return Ale3Type::Instance().UniqueParObjectId(); }

  /*!
  \brief Pack this class so it can be communicated

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Pack(DRT::PackBuffer& data) const;

  /*!
  \brief Unpack data from a char vector into this class

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Unpack(const vector<char>& data);

  /*!
  \brief Destructor

  */
  virtual ~Ale3();

  //@}

  //! @name Acess methods


  /*!
  \brief Get number of degrees of freedom of a certain node
         (implements pure virtual DRT::Element)

  The element decides how many degrees of freedom its nodes must have.
  As this may vary along a simulation, the element can redecide the
  number of degrees of freedom per node along the way for each of it's nodes
  separately.
  */
  virtual int NumDofPerNode(const DRT::Node& node) const {return 3;}

  /*!
  \brief Get number of degrees of freedom per element
         (implements pure virtual DRT::Element)

  The element decides how many element degrees of freedom it has.
  It can redecide along the way of a simulation.

  \note Element degrees of freedom mentioned here are dofs that are visible
        at the level of the total system of equations. Purely internal
        element dofs that are condensed internally should NOT be considered.
  */
  virtual int NumDofPerElement() const { return 0; }

  /*!
  \brief Print this element
  */
  void Print(ostream& os) const;

  virtual DRT::ElementType & ElementType() const
  { return Ale3Type::Instance(); }

  //@}

  //! @name Input and Creation

  /*!
  \brief Read input for this element
  */
  bool ReadElement(const std::string& eletype,
                   const std::string& distype,
                   DRT::INPUT::LineDefinition* linedef);

  //@}

  //! @name Evaluation

  /*!
  \brief Evaluate an element

  Evaluate ale3 element stiffness, mass, internal forces etc

  \param params (in/out): ParameterList for communication between control routine
                          and elements
  \param elemat1 (out)  : matrix to be filled by element. If NULL on input,
                          the controling method does not epxect the element to fill
                          this matrix.
  \param elemat2 (out)  : matrix to be filled by element. If NULL on input,
                          the controling method does not epxect the element to fill
                          this matrix.
  \param elevec1 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \param elevec2 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \param elevec3 (out)  : vector to be filled by element. If NULL on input,
                          the controlling method does not epxect the element
                          to fill this vector
  \return 0 if successful, negative otherwise
  */
  int Evaluate(ParameterList& params,
               DRT::Discretization&      discretization,
               vector<int>&              lm,
               Epetra_SerialDenseMatrix& elemat1,
               Epetra_SerialDenseMatrix& elemat2,
               Epetra_SerialDenseVector& elevec1,
               Epetra_SerialDenseVector& elevec2,
               Epetra_SerialDenseVector& elevec3);


  /*!
  \brief Evaluate a Neumann boundary condition

  this method evaluates a surfaces Neumann condition on the shell element

  \param params (in/out)    : ParameterList for communication between control routine
                              and elements
  \param discretization (in): A reference to the underlying discretization
  \param condition (in)     : The condition to be evaluated
  \param lm (in)            : location vector of this element
  \param elevec1 (out)      : vector to be filled by element. If NULL on input,

  \return 0 if successful, negative otherwise
  */
  virtual int EvaluateNeumann(ParameterList& params,
                              DRT::Discretization&      discretization,
                              DRT::Condition&           condition,
                              vector<int>&              lm,
                              Epetra_SerialDenseVector& elevec1,
                              Epetra_SerialDenseMatrix* elemat1 = NULL);


  //@}

  //! @name Other

  //@}


private:

  //! action parameters recognized by ale3
  enum ActionType
  {
    none,
    calc_ale_laplace,
    calc_ale_lin_stiff,
    calc_ale_spring,           ///< compute stiffness based on springs algorithm on last time step configuration
    calc_ale_spring_fixed_ref,  ///< compute stiffness based on springs algorithm on initial configuration
    calc_ale_node_normal
  };

  //! Gaussrule
  //DRT::UTILS::GaussRule3D                         gaussrule_;

  //! container containing all kind of ale3 thisandthat
  //DRT::Container                                  data_;


  // internal calculation methods

  // don't want = operator
  Ale3& operator = (const Ale3& old);
#if 0
  // get optimal gaussrule for given discretization type
  DRT::UTILS::GaussRule3D getOptimalGaussrule(const DiscretizationType& distype);
#endif
};

//=======================================================================
//=======================================================================
//=======================================================================
//=======================================================================

class Ale3_Impl_Interface : SingletonDestruction
{
public:

  /// Empty constructor
  Ale3_Impl_Interface() {}

  virtual ~Ale3_Impl_Interface() {}

  /// Internal implementation class for fluid element
  static Ale3_Impl_Interface* Impl(DRT::ELEMENTS::Ale3* ele);

  virtual void static_ke_spring(Ale3*                     ele,
                                Epetra_SerialDenseMatrix& sys_mat,
                                const vector<double>&     displacements) = 0;
  virtual void static_ke(Ale3*                      ele,
                         DRT::Discretization&       discretization,
                         vector<int>&               lm,
                         Epetra_SerialDenseMatrix&  sys_mat,
                         Epetra_SerialDenseVector&  residual,
                         bool                       incremental,
                         std::vector<double>&       my_dispnp,
                         RefCountPtr<MAT::Material> material,
                         ParameterList& 	    params) = 0;
  virtual void static_ke_laplace(
  Ale3*                      ele,
  DRT::Discretization&       dis,
  Epetra_SerialDenseMatrix&  sys_mat,
  Epetra_SerialDenseVector&  residual,
  bool                       incremental,
  std::vector<double>&       my_dispnp,
  RefCountPtr<MAT::Material> material,
  ParameterList&             params) = 0;

    virtual void ElementNodeNormal(Ale3*                      ele,
                                   Epetra_SerialDenseVector&  elevec1,
                                   std::vector<double>&       my_dispnp
      ) = 0;

};

template <DRT::Element::DiscretizationType distype>
class Ale3_Impl: public Ale3_Impl_Interface
{

  Ale3_Impl() {}
public:


  ~Ale3_Impl() {}

  /// Singleton access method
  static Ale3_Impl<distype> * Instance( bool create=true );

  /// called upon destruction
  virtual void Done();

  void static_ke_laplace(
    Ale3*                      ele,
    DRT::Discretization&       dis,
    Epetra_SerialDenseMatrix&  sys_mat,
    Epetra_SerialDenseVector&  residual,
    bool                       incremental,
    std::vector<double>&       my_dispnp,
    RefCountPtr<MAT::Material> material,
    ParameterList&             params);

  void static_ke_spring(Ale3*                     ele,
                        Epetra_SerialDenseMatrix& sys_mat,
                        const vector<double>&     displacements);
  void static_ke(Ale3*                      ele,
		 DRT::Discretization&       discretization,
                 vector<int>&               lm,
                 Epetra_SerialDenseMatrix&  sys_mat,
                 Epetra_SerialDenseVector&  residual,
                 bool                       incremental,
                 std::vector<double>&       my_dispnp,
                 RefCountPtr<MAT::Material> material,
                 ParameterList& 	    params);
  void ElementNodeNormal(Ale3*                      ele,
                              Epetra_SerialDenseVector&  elevec1,
                              std::vector<double>&       my_dispnp
    );
private:
  static const int iel = DRT::UTILS::DisTypeToNumNodePerEle<distype>::numNodePerElement;
  static const int numcnd = DisTypeToNumCornerNodes<distype>::numCornerNodes;

  inline void ale3_edge_geometry(int i, int j, const LINALG::Matrix<3, iel>& xyze,
                                 double& length,
                                 double& dx,
                                 double& dy,
                                 double& dz);

  /*!
  \brief Prevents node s from penetrating face pqr.

  The calculated dynamic triangle sjq is perpendicular to edge pr and face
  pqr. According to Farhat et al.

  The interface of this function is rather wierd, I changed it to reduce
  re-calculation of vectors that are used multiple times.

  \param node_i (in)    : Determine position of triangle sjq in
  tetrahedra.
  \param sq             : edge vector
  \param len_sq         : length
  \param rp             : edge vector
  \param len_rp         : length
  \param qp             : edge vector
  \param local_x        : vector needed in calculation
  \param sysmat (in/out): The element's sys_mat
  */
  void ale3_add_tria_stiffness(
      int node_p, int node_q, int node_r, int node_s,
      const LINALG::Matrix<3, 1>& sq,
      const double len_sq,
      const LINALG::Matrix<3, 1>& rp,
      const double len_rp,
      const LINALG::Matrix<3, 1>& qp,
      const LINALG::Matrix<3, 1>& local_x,
      LINALG::Matrix<3*iel,3*iel>& sys_mat);

  /*!
  \brief Prevents node-face-penetration for given nodes.

  Twelve-triangle configuration. According to Farhat et al.

  \param tet_i (in)    : Nodes. Arbitrary succession.
  \param sysmat (in/out): The element's sys_mat
  \param xyze (in)     : The actual element coordinates
  */
  void ale3_add_tetra_stiffness(int tet_0, int tet_1, int tet_2, int tet_3,
                                LINALG::Matrix<3*iel,3*iel>& sys_mat,
                                const LINALG::Matrix<3,iel>& xyze);
  inline void ale3_tors_spring_tet4(LINALG::Matrix<3*iel,3*iel>& sys_mat,
                                    const LINALG::Matrix<3,iel>& xyze);
  inline void ale3_tors_spring_pyramid5(LINALG::Matrix<3*iel,3*iel>& sys_mat,
                                        const LINALG::Matrix<3,iel>& xyze);
  inline void ale3_tors_spring_wedge6(LINALG::Matrix<3*iel,3*iel>& sys_mat,
                                      const LINALG::Matrix<3,iel>& xyze);
  inline void ale3_tors_spring_hex8(LINALG::Matrix<3*iel,3*iel>& sys_mat,
                                    const LINALG::Matrix<3,iel>& xyze);
  inline void ale3_tors_spring_nurbs27(LINALG::Matrix<3*iel,3*iel>& sys_mat,
				       const LINALG::Matrix<3,iel>& xyze);


  inline DRT::UTILS::GaussRule3D getOptimalGaussrule();

  Ale3_Impl<distype> operator=(const Ale3_Impl<distype> other);
};


//=======================================================================
//=======================================================================
//=======================================================================
//=======================================================================


class Ale3SurfaceType : public DRT::ElementType
{
public:

  std::string Name() const { return "Ale3SurfaceType"; }

  static Ale3SurfaceType & Instance() { return instance_; };

  virtual Teuchos::RCP<DRT::Element> Create( const int id, const int owner );

  virtual void NodalBlockInformation( DRT::Element * dwele, int & numdf, int & dimns, int & nv, int & np ) {}

  virtual void ComputeNullSpace( DRT::Discretization & dis, std::vector<double> & ns, const double * x0, int numdf, int dimns ) {}

private:

  static Ale3SurfaceType instance_;
};


/*!
\brief An element representing a surface of a ale3 element

\note This is a pure Neumann boundary condition element. It's only
      purpose is to evaluate surface Neumann boundary conditions that might be
      adjacent to a parent ale3 element. It therefore does not implement
      the DRT::Element::Evaluate method and does not have its own ElementRegister class.

\author gee (gee@lnm.mw.tum.de)
*/
class Ale3Surface : public DRT::Element
{
public:

  //! @name Constructors and destructors and related methods

  /*!
  \brief Standard Constructor

  \param id : A unique global id
  \param owner: Processor owning this surface
  \param nnode: Number of nodes attached to this element
  \param nodeids: global ids of nodes attached to this element
  \param nodes: the discretizations map of nodes to build ptrs to nodes from
  \param parent: The parent ale element of this surface
  \param lsurface: the local surface number of this surface w.r.t. the parent element
  */
  Ale3Surface(int id, int owner, int nnode, const int* nodeids,
             DRT::Node** nodes, DRT::ELEMENTS::Ale3* parent, const int lsurface);

  /*!
  \brief Copy Constructor

  Makes a deep copy of a Element

  */
  Ale3Surface(const Ale3Surface& old);

  /*!
  \brief Deep copy this instance of an element and return pointer to the copy

  The Clone() method is used from the virtual base class Element in cases
  where the type of the derived class is unknown and a copy-ctor is needed

  */
  DRT::Element* Clone() const;

  /*!
  \brief Get shape type of element
  */
  virtual DiscretizationType Shape() const;

  /*!
  \brief Return unique ParObject id

  every class implementing ParObject needs a unique id defined at the
  top of the drt_parobject.H file.
  */
  virtual int UniqueParObjectId() const { return Ale3SurfaceType::Instance().UniqueParObjectId(); }

  /*!
  \brief Pack this class so it can be communicated

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Pack(DRT::PackBuffer& data) const;

  /*!
  \brief Unpack data from a char vector into this class

  \ref Pack and \ref Unpack are used to communicate this element

  */
  virtual void Unpack(const vector<char>& data);

  /*!
  \brief Destructor

  */
  virtual ~Ale3Surface();

  //@}

  //! @name Acess methods


  /*!
  \brief Get number of degrees of freedom of a certain node
         (implements pure virtual DRT::Element)

  The element decides how many degrees of freedom its nodes must have.
  As this may vary along a simulation, the element can redecide the
  number of degrees of freedom per node along the way for each of it's nodes
  separately.
  */
  virtual int NumDofPerNode(const DRT::Node& node) const { return 3; }

  /*!
  \brief Get number of degrees of freedom per element
         (implements pure virtual DRT::Element)

  The element decides how many element degrees of freedom it has.
  It can redecide along the way of a simulation.

  \note Element degrees of freedom mentioned here are dofs that are visible
        at the level of the total system of equations. Purely internal
        element dofs that are condensed internally should NOT be considered.
  */
  virtual int NumDofPerElement() const { return 0; }

  /*!
  \brief Print this element
  */
  void Print(ostream& os) const;

  virtual DRT::ElementType & ElementType() const
  { return Ale3SurfaceType::Instance(); }

  //@}

  //! @name Evaluate methods

  /*!
  \brief Evaluate a Neumann boundary condition

  this method evaluates a surface Neumann condition on the ale3 element

  \param params (in/out)    : ParameterList for communication between control routine
                              and elements
  \param discretization (in): A reference to the underlying discretization
  \param condition (in)     : The condition to be evaluated
  \param lm (in)            : location vector of this element
  \param elevec1 (out)      : vector to be filled by element. If NULL on input,

  \return 0 if successful, negative otherwise
  */
  virtual int EvaluateNeumann(ParameterList& params,
                              DRT::Discretization&      discretization,
                              DRT::Condition&           condition,
                              vector<int>&              lm,
                              Epetra_SerialDenseVector& elevec1,
                              Epetra_SerialDenseMatrix* elemat1 = NULL);

  //@}

private:

  // don't want = operator
  Ale3Surface& operator = (const Ale3Surface& old);

  //! The parent element of this surface
  DRT::ELEMENTS::Ale3* parent_;
  //! The local surface number of this surface w.r.t to the parent_ element
  int                    lsurface_;

  //  compute kovariant metric tensor G for ale surface element
  //                                                  gammi 04/07
  void  f3_metric_tensor_for_surface(
    const Epetra_SerialDenseMatrix  xyze,
    const Epetra_SerialDenseMatrix  deriv,
    Epetra_SerialDenseMatrix&       metrictensor,
    double                         *drs);

}; // class Ale3Surface




} // namespace ELEMENTS
} // namespace DRT



#endif
#endif
