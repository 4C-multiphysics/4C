#include "../headers/standardtypes.h"

/*----------------------------------------------------------------------*
 | define array                                           m.gee 8/00    |
 *----------------------------------------------------------------------*/
void amdef(char namstr[],ARRAY *a,int fdim, int sdim, char typstr[])
{
register int i=0;

#ifdef DEBUG 
mg_dstrc_enter("amdef");
#endif

strncpy(a->name,namstr,9);
a->fdim = fdim;
a->sdim = sdim;
if (strncmp("DA",typstr,2)==0) { a->Typ=DA; goto next;}
if (strncmp("IA",typstr,2)==0) { a->Typ=IA; goto next;}
if (strncmp("DV",typstr,2)==0) { a->Typ=DV; goto next;}
if (strncmp("IV",typstr,2)==0) { a->Typ=IV; goto next;}
next:
switch (a->Typ)
{
case DA: /* -------------------------------------------double array */
a->hook.dhook = (double*)calloc(fdim*sdim+2,sizeof(double));
if (a->hook.dhook == NULL) dserror("Allocation of memory failed");
for (i=0; i<(fdim*sdim); a->hook.dhook[i++]=0.0); 
a->hook.dhook[0]         = -9999.9999;
a->hook.dhook[fdim*sdim+1] = -9999.9999;
a->a.da       = (double**)calloc(fdim,sizeof(double*));
if (a->a.da == NULL) dserror("Allocation of memory failed"); 
for (i=0; i<fdim; i++) a->a.da[i] = &(a->hook.dhook[1+i*sdim]);
break;


case IA: /* ------------------------------------------integer array */
a->hook.ihook = (int*)calloc(fdim*sdim+2,sizeof(int));
if (a->hook.ihook == NULL) dserror("Allocation of memory failed");
for (i=0; i<(fdim*sdim); a->hook.ihook[i++]=0); 
a->hook.ihook[0]         = -9999;
a->hook.ihook[fdim*sdim+1] = -9999;
a->a.ia       = (int**)calloc(fdim,sizeof(int*));
if (a->a.ia == NULL) dserror("Allocation of memory failed");
for (i=0; i<fdim; i++) a->a.ia[i] = &(a->hook.ihook[1+i*sdim]);
break;

case DV: /* ------------------------------------------double vector */
a->hook.dhook = (double*)calloc(fdim*sdim+2,sizeof(double));
if (a->hook.dhook == NULL) dserror("Allocation of memory failed");
for (i=0; i<(fdim*sdim); a->hook.dhook[i++]=0.0); 
a->hook.dhook[0]         = -9999.9999;
a->hook.dhook[fdim*sdim+1] = -9999.9999;
a->a.dv = &(a->hook.dhook[1]);
break;

case IV: /* -----------------------------------------integer vector */
a->hook.ihook = (int*)calloc(fdim*sdim+2,sizeof(int));
if (a->hook.ihook == NULL) dserror("Allocation of memory failed");
for (i=0; i<(fdim*sdim+2); a->hook.ihook[i++]=0); 
a->hook.ihook[0]         = -9999;
a->hook.ihook[fdim*sdim+1] = -9999;
a->a.iv = &(a->hook.ihook[1]);
break;

default:
dserror("Unknown type of array given");
}
/*--------------- make report about new array to bugtraceing system */
#ifdef DEBUG 
if (trace.trace_on==1)
{
mg_dstracereport(a);
}
mg_dstrc_exit();
#endif

return;
} /* end of amdef */



/*----------------------------------------------------------------------*
 | redefine array                                         m.gee 8/00    |
 *----------------------------------------------------------------------*/
void amredef(ARRAY *a,int newfdim, int newsdim, char newtypstr[])
{
register int i=0, j=0;
enum {amredefvoid, newIV, newIA, newDV, newDA} newtyp = amredefvoid;
int size1,size2;
ARRAY copyarray;                    

#ifdef DEBUG 
mg_dstrc_enter("amredef");
#endif

/*--------------------------------------- find out the new typ of array */
if (strncmp("IV",newtypstr,2)==0) newtyp =  newIV;
if (strncmp("IA",newtypstr,2)==0) newtyp =  newIA;
if (strncmp("DV",newtypstr,2)==0) newtyp =  newDV;
if (strncmp("DA",newtypstr,2)==0) newtyp =  newDA;

switch(newtyp) /*------------- what is the new array typ supposed to be */
{
case newIV:/*---------------------------------------------new typ is IV */ 
   switch(a->Typ) /*------------------------- what is the old array typ */
   {
   case IV: /*------------------------------------- conversion IV to IV */
      amdef(a->name,&copyarray,a->fdim,a->sdim,"IV");
      for (i=0; i<a->fdim*a->sdim; i++) copyarray.a.iv[i] = a->a.iv[i];
      
      amdel(a);
      amdef(copyarray.name,a,newfdim,newsdim,"IV");

      size1 = MIN(newfdim*newsdim,copyarray.fdim*copyarray.sdim);
      for (i=0; i<size1; i++) a->a.iv[i] = copyarray.a.iv[i];
      
      amdel(&copyarray);
   break;
   
   case IA: /*------------------------------------- conversion IA to IV */
      amdef(a->name,&copyarray,a->fdim,a->sdim,"IA");
      for (i=0; i<a->fdim; i++)
      {
         for (j=0; j<a->sdim; j++)
         {
            copyarray.a.ia[i][j] = a->a.ia[i][j];
         }
      }
      
      amdel(a);
      amdef(copyarray.name,a,newfdim,newsdim,"IV");

      if (newfdim==1)
      {
          size1 = MIN(newsdim,copyarray.sdim);
          for (i=0; i<size1; i++) a->a.iv[i] = copyarray.a.ia[0][i];  
      }
      else
      {
          size1 = MIN(newfdim,copyarray.fdim); 
          for (i=0; i<size1; i++) a->a.iv[i] = copyarray.a.ia[i][0];  
      }
      
      amdel(&copyarray);
   break;

   default:
      dserror("conversion from integer to double or vice versa not allowed");
   break;
   }
break; 

case newIA:/*---------------------------------------------new typ is IA */ 
   switch(a->Typ) /*------------------------- what is the old array typ */
   {
   case IV: /*------------------------------------- conversion IV to IA */
      amdef(a->name,&copyarray,a->fdim,a->sdim,"IV");
      for (i=0; i<a->fdim*a->sdim; i++) copyarray.a.iv[i] = a->a.iv[i];

      amdel(a);
      amdef(copyarray.name,a,newfdim,newsdim,"IA");
      
      if (copyarray.fdim==1)
      {
         size1 = MIN(newsdim,copyarray.sdim);
         for (i=0; i<size1; i++) a->a.ia[0][i] = copyarray.a.iv[i];  
      }
      else
      {
         size1 = MIN(newfdim,copyarray.fdim);
         for (i=0; i<size1; i++) a->a.ia[i][0] = copyarray.a.iv[i];  
      }
      
      amdel(&copyarray);   
   break;

   case IA: /*--------------------------------------conversion IA to IA */
      amdef(a->name,&copyarray,a->fdim,a->sdim,"IA");
      for (i=0; i<a->fdim; i++)
      {
         for (j=0; j<a->sdim; j++)
         {
            copyarray.a.ia[i][j] = a->a.ia[i][j];
         }
      }
      
      amdel(a);
      amdef(copyarray.name,a,newfdim,newsdim,"IA");
      
      size1 = MIN(newfdim,copyarray.fdim);
      size2 = MIN(newsdim,copyarray.sdim);
      
      for (i=0; i<a->fdim; i++)
      {
         for (j=0; j<a->sdim; j++)
         {
            a->a.ia[i][j] = copyarray.a.ia[i][j];
         }
      }
      
      amdel(&copyarray);   
   break;
   default:
      dserror("conversion from integer to double or vice versa not allowed");
   break;
   }
break;
case newDV:/*---------------------------------------------new typ is DV */ 
   switch(a->Typ) /*------------------------- what is the old array typ */
   {
   case DV:/*---------------------------------------conversion DV to DV */
      amdef(a->name,&copyarray,a->fdim,a->sdim,"DV");
      for (i=0; i<a->fdim*a->sdim; i++) copyarray.a.iv[i] = a->a.iv[i];
      
      amdel(a);
      amdef(copyarray.name,a,newfdim,newsdim,"DV");

      size1 = MIN(newfdim*newsdim,copyarray.fdim*copyarray.sdim);
      for (i=0; i<size1; i++) a->a.iv[i] = copyarray.a.iv[i];
      
      amdel(&copyarray);
   break;

   case DA:/*---------------------------------------conversion DA to DV */
      amdef(a->name,&copyarray,a->fdim,a->sdim,"DA");
      for (i=0; i<a->fdim; i++)
      {
         for (j=0; j<a->sdim; j++)
         {
            copyarray.a.ia[i][j] = a->a.ia[i][j];
         }
      }
      
      amdel(a);
      amdef(copyarray.name,a,newfdim,newsdim,"DV");

      if (newfdim==1)
      {
          size1 = MIN(newsdim,copyarray.sdim);
          for (i=0; i<size1; i++) a->a.iv[i] = copyarray.a.ia[0][i];  
      }
      else
      {
          size1 = MIN(newfdim,copyarray.fdim); 
          for (i=0; i<size1; i++) a->a.iv[i] = copyarray.a.ia[i][0];  
      }
      
      amdel(&copyarray);
   break;
   default:
      dserror("conversion from integer to double or vice versa not allowed");
   break;
   }
break;
case newDA:/*---------------------------------------------new typ is DA */ 
   switch(a->Typ) /*------------------------- what is the old array typ */
   {
   case DV:/*---------------------------------------conversion DV to DA */
      amdef(a->name,&copyarray,a->fdim,a->sdim,"DV");
      for (i=0; i<a->fdim*a->sdim; i++) copyarray.a.iv[i] = a->a.iv[i];

      amdel(a);
      amdef(copyarray.name,a,newfdim,newsdim,"DA");
      
      if (copyarray.fdim==1)
      {
         size1 = MIN(newsdim,copyarray.sdim);
         for (i=0; i<size1; i++) a->a.ia[0][i] = copyarray.a.iv[i];  
      }
      else
      {
         size1 = MIN(newfdim,copyarray.fdim);
         for (i=0; i<size1; i++) a->a.ia[i][0] = copyarray.a.iv[i];  
      }
      
      amdel(&copyarray);   
   break;

   case DA:/*---------------------------------------conversion DA to DA */
      amdef(a->name,&copyarray,a->fdim,a->sdim,"DA");
      for (i=0; i<a->fdim; i++)
      {
         for (j=0; j<a->sdim; j++)
         {
            copyarray.a.ia[i][j] = a->a.ia[i][j];
         }
      }
      
      amdel(a);
      amdef(copyarray.name,a,newfdim,newsdim,"DA");
      
      size1 = MIN(newfdim,copyarray.fdim);
      size2 = MIN(newsdim,copyarray.sdim);
      
      for (i=0; i<size1; i++)
      {
         for (j=0; j<size2; j++)
         {
            a->a.ia[i][j] = copyarray.a.ia[i][j];
         }
      }
      
      amdel(&copyarray);   
   break;
   default:
      dserror("conversion from integer to double or vice versa not allowed");
   break;
   }
break;
default:
   dserror("the new array typ is unknown");
break;
}

#ifdef DEBUG 
mg_dstrc_exit();
#endif

return;
} /* end of amredef */





/*----------------------------------------------------------------------*
 | get an array                                           m.gee 8/00    |
 *----------------------------------------------------------------------*/
void amloc(ARRAY *a,void ***v, int *fdim, int *sdim)
{

#ifdef DEBUG 
mg_dstrc_enter("amloc");
#endif

switch (a->Typ)
{
case DA: /* double array */
*v = (void*)(a->a.da);
*fdim=a->fdim;
*sdim=a->sdim;
break;

case IA: /* integer array */
*v = (void*)(a->a.ia);
*fdim=a->fdim;
*sdim=a->sdim;
break;

case DV: /* double vector */
*v = (void*)(a->a.dv);
*fdim=a->fdim;
*sdim=a->sdim;
break;

case IV: /* integer vector */
*v = (void*)(a->a.iv);
*fdim=a->fdim;
*sdim=a->sdim;
break;

default:
dserror("Unknown type of array given");
}

#ifdef DEBUG 
mg_dstrc_exit();
#endif

return;
}/* end of amloc */


/*----------------------------------------------------------------------*
 | delete         array                                   m.gee 8/00    |
 *----------------------------------------------------------------------*/
void amdel(ARRAY *array)
{
int i=0;

#ifdef DEBUG 
mg_dstrc_enter("amdel");
#endif

/*-------------------------------------------------delete name of array */
strncpy(array->name,"DELETED",9);
/*---------------------------------------------------deletes dimensions */
array->fdim=0;
array->sdim=0;
/*-------------------------------------------------------free the space */
switch(array->Typ)
{
case DA:
   free(array->hook.dhook);
   free(array->a.da);
   array->hook.dhook=NULL;
   array->a.da=NULL;
   break;
case IA:
   free(array->hook.ihook);
   free(array->a.ia);
   array->hook.ihook=NULL;
   array->a.ia=NULL;
   break;
case DV:
   free(array->hook.dhook);
   array->hook.dhook=NULL;
   array->a.dv=NULL;
   break;
case IV:
   free(array->hook.ihook);
   array->hook.ihook=NULL;
   array->a.iv=NULL;
   break;
default:
dserror("Unknown type of array given");
}
/*----------------------------------------------------- delete the type */
array->Typ = XX;
/*------------------------- delete the array from the bugtracing system */
#ifdef DEBUG 
if (trace.trace_on==1)
{
    trace.arrays[array->place_in_trace]=NULL;
    trace.num_arrays--;
    array->place_in_trace=0;
}                     
mg_dstrc_exit();
#endif

return;
} /* end of amdel */


/*----------------------------------------------------------------------*
 | initialize an array by zero                            m.gee 8/00    |
 *----------------------------------------------------------------------*/
void amzero(ARRAY *array)
{
int i=0;
int dim;

#ifdef DEBUG 
mg_dstrc_enter("amzero");
#endif

dim = (array->fdim) * (array->sdim);
switch (array->Typ)
{
case DA:
   for (i=0; i<dim; i++) array->hook.dhook[i+1]=0.0;
   break; 
case DV:
   for (i=0; i<dim; i++) array->hook.dhook[i+1]=0.0;
   break;
case IA:
   for (i=0; i<dim; i++) array->hook.ihook[i+1]=0;
   break; 
case IV:
   for (i=0; i<dim; i++) array->hook.ihook[i+1]=0;
   break; 
default:
dserror("Unknown type of array given");
}  

#ifdef DEBUG 
mg_dstrc_exit();
#endif

return;
} /* end of amzero */



/*----------------------------------------------------------------------*
 | allocate and make a copy of ARRAY                      m.gee 8/00    |
 *----------------------------------------------------------------------*/
void am_alloc_copy(ARRAY *array_from, ARRAY *array_to)
{
int i=0;
int dim;

#ifdef DEBUG 
mg_dstrc_enter("am_alloc_copy");
#endif

switch (array_from->Typ)
{
case DA:
   amdef(array_from->name,array_to,array_from->fdim,array_from->sdim,"DA");
   for (i=0; i<array_from->fdim*array_from->sdim; i++)
   {
      array_to->hook.dhook[i+1] = array_from->hook.dhook[i+1];
   }
   break; 
case DV:
   amdef(array_from->name,array_to,array_from->fdim,array_from->sdim,"DV");
   for (i=0; i<array_from->fdim*array_from->sdim; i++)
   {
      array_to->hook.dhook[i+1] = array_from->hook.dhook[i+1];
   }
   break;
case IA:
   amdef(array_from->name,array_to,array_from->fdim,array_from->sdim,"IA");
   for (i=0; i<array_from->fdim*array_from->sdim; i++)
   {
      array_to->hook.ihook[i+1] = array_from->hook.ihook[i+1];
   }
   break; 
case IV:
   amdef(array_from->name,array_to,array_from->fdim,array_from->sdim,"IV");
   for (i=0; i<array_from->fdim*array_from->sdim; i++)
   {
      array_to->hook.ihook[i+1] = array_from->hook.ihook[i+1];
   }
   break; 
default:
dserror("Unknown type of array given");
}  

#ifdef DEBUG 
mg_dstrc_exit();
#endif

return;
} /* end of am_alloc_copy */
