/*----------------------------------------------------------------------*/
/*!
\file ad_str_wrapper.H

\brief Wrapper for the structural time integration

<pre>
Maintainer: Georg Hammerl
            hammerl@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15237
</pre>
*/
/*----------------------------------------------------------------------*/

#ifndef ADAPTER_STRUCTURE_WRAPPER_H
#define ADAPTER_STRUCTURE_WRAPPER_H

#include "ad_str_structure.H"

namespace ADAPTER
{

  /// Just wrap, do nothing new, meant to be derived from
  class StructureWrapper : public Structure
  {
  public:

    /// constructor
    explicit StructureWrapper(Teuchos::RCP<Structure> structure) : structure_(structure) {}


    //! @name Vector access
    //@{

    /// initial guess of Newton's method
    virtual Teuchos::RCP<const Epetra_Vector> InitialGuess()
    { return structure_->InitialGuess(); }

    /// right-hand-side of Newton's method
    virtual Teuchos::RCP<const Epetra_Vector> RHS()
    { return structure_->RHS(); }

    /// unknown displacements at \f$t_{n+1}\f$
    virtual Teuchos::RCP<const Epetra_Vector> Dispnp() const
    { return structure_->Dispnp(); }

    /// known displacements at \f$t_{n}\f$
    virtual Teuchos::RCP<const Epetra_Vector> Dispn() const
    { return structure_->Dispn(); }

    /// unknown velocity at \f$t_{n+1}\f$
    virtual Teuchos::RCP<const Epetra_Vector> Velnp() const
    { return structure_->Velnp(); }

    /// known velocity at \f$t_{n}\f$
    virtual Teuchos::RCP<const Epetra_Vector> Veln() const
    { return structure_->Veln(); }

    /// known velocity at \f$t_{n-1}\f$
    virtual Teuchos::RCP<const Epetra_Vector> Velnm() const
    { return structure_->Velnm(); }

    /// unknown acceleration at \f$t_{n+1}\f$
    virtual Teuchos::RCP<const Epetra_Vector> Accnp() const
    { return structure_->Accnp(); }

    /// known acceleration at \f$t_{n}\f$
    virtual Teuchos::RCP<const Epetra_Vector> Accn() const
    { return structure_->Accn(); }

    /// return displacements at all the time steps
    virtual Teuchos::RCP<DRT::UTILS::TimIntMStep<Epetra_Vector> > DispMStep()
    { return structure_->DispMStep(); }

    /// return times at all the time steps
    virtual Teuchos::RCP<DRT::UTILS::TimIntMStep<double> > TimeMStep()
    { return structure_->TimeMStep(); }

    //@}

    /// known FSI force for immersed FSI
    virtual Teuchos::RCP<Epetra_Vector> ExtractInternalForceVector(double time, double dt, Teuchos::RCP<const Epetra_Vector> dis,Teuchos::RCP<Epetra_Vector> fint)
    { return structure_->ExtractInternalForceVector(time,dt,dis,fint); }

    //! @name Misc
    //@{

    /// dof map of vector of unknowns
    virtual Teuchos::RCP<const Epetra_Map> DofRowMap()
    { return structure_->DofRowMap(); }

    /// dof map of vector of unknowns for multiple dof sets
    virtual Teuchos::RCP<const Epetra_Map> DofRowMap(unsigned nds)
    { return structure_->DofRowMap(nds); }

    /// view of dof map of vector of vector of unknowns
    virtual const Epetra_Map* DofRowMapView()
    { return structure_->DofRowMapView(); }

    /// domain map of system matrix
    virtual const Epetra_Map& DomainMap() const
    { return structure_->DomainMap(); }

    /// direct access to system matrix
    virtual Teuchos::RCP<LINALG::SparseMatrix> SystemMatrix()
    { return structure_->SystemMatrix(); }

    /// direct access to system matrix
    virtual Teuchos::RCP<LINALG::BlockSparseMatrixBase> BlockSystemMatrix()
    { return structure_->BlockSystemMatrix(); }

    /// switch structure field to block matrix
    virtual void UseBlockMatrix(Teuchos::RCP<const LINALG::MultiMapExtractor> domainmaps, Teuchos::RCP<const LINALG::MultiMapExtractor> rangemaps)
    { return structure_->UseBlockMatrix(domainmaps, rangemaps); }

    // access to contact/meshtying bridge
    virtual Teuchos::RCP<CONTACT::MeshtyingContactBridge> MeshtyingContactBridge()
    { return structure_->MeshtyingContactBridge(); }

    // access to locsys manager
    virtual Teuchos::RCP<DRT::UTILS::LocsysManager> LocsysManager()
    { return structure_->LocsysManager(); }

    /// direct access to discretization
    virtual Teuchos::RCP<DRT::Discretization> Discretization()
    { return structure_->Discretization(); }

    /// are there any algebraic constraints?
    virtual bool HaveConstraint()
    { return structure_->HaveConstraint(); }

    /// are there any Windkessel bcs?
    virtual bool HaveWindkessel()
    { return structure_->HaveWindkessel(); }

    /// do we have semi-smooth Newton type plasticity algorithm
    virtual bool HaveSemiSmoothPlasticity()
    { return structure_->HaveSemiSmoothPlasticity(); }

    /// get constraint manager defined in the structure
    virtual const Teuchos::RCP< UTILS::ConstrManager> GetConstraintManager()
    { return structure_->GetConstraintManager(); }

    /// get Windkessel manager defined in the structure
    virtual const Teuchos::RCP< UTILS::WindkesselManager> GetWindkesselManager()
    { return structure_->GetWindkesselManager(); }

    /// get plasticity manager defined in the structure
    virtual const Teuchos::RCP<DRT::UTILS::PlastSsnManager> GetPlasticityManager()
    { return structure_->GetPlasticityManager(); }

    /// get type of thickness scaling for thin shell structures
    virtual INPAR::STR::STC_Scale GetSTCAlgo()
    { return structure_->GetSTCAlgo(); }

    /// access to scaling matrix for STC
    virtual Teuchos::RCP<LINALG::SparseMatrix> GetSTCMat()
    { return structure_->GetSTCMat(); }

    /// Return MapExtractor for Dirichlet boundary conditions
    virtual const Teuchos::RCP<const LINALG::MapExtractor> GetDBCMapExtractor()
    { return structure_->GetDBCMapExtractor(); }

    /// reset step and state vectors
    virtual void Reset()
    { structure_->Reset(); }

    /// reset last time step, needed for time step size adaptivity in TimIntAda and FSI
    virtual void ResetStep()
    { structure_->ResetStep(); }

    //@}


    /// @name Time step helpers
    //@{

    /// return time integration factor
    virtual const double TimIntParam() const
    { return structure_->TimIntParam(); }

    //! Sets the current time \f$t_{n}\f$
    virtual void SetTime(const double time)
    { return structure_->SetTime(time); }

    //! Sets the target time \f$t_{n+1}\f$ of this time step
    virtual void SetTimen(const double time)
    { structure_->SetTimen(time); }

    //! Return current time \f$t_{n}\f$
    virtual double TimeOld() const
    { return structure_->TimeOld(); }

    //! Return target time \f$t_{n+1}\f$
    virtual double Time() const
    { return structure_->Time(); }

    /// get upper limit of time range of interest
    virtual double GetTimeEnd() const
    { return structure_->GetTimeEnd(); }

    //! Set upper limit of time range of interest //HACK for parameter continuation
    virtual void SetTimeEnd(double timemax)
    { structure_->SetTimeEnd(timemax); }

    /// get time step size \f$\Delta t_n\f$
    virtual double Dt() const
    { return structure_->Dt(); }

    /// Return current step number $n$
    virtual int StepOld() const
    { return structure_->StepOld(); }

    /// Return current step number $n+1$
    virtual int Step() const
    { return structure_->Step(); }

    /// get number of time steps
    virtual int NumStep() const
    { return structure_->NumStep(); }

    /// integrate from t1 to t2
    virtual int Integrate() { return structure_->Integrate(); }

    /// tests if there are more time steps to do
    virtual bool NotFinished() const
    { return structure_->NotFinished(); }

    /// set time step size
    virtual void SetDt(const double dtnew)
    { return structure_->SetDt(dtnew); }

    /// start new time step
    virtual void PrepareTimeStep()
    { structure_->PrepareTimeStep(); }

    /// update displacement and evaluate elements
    virtual void Evaluate(Teuchos::RCP<const Epetra_Vector> disiterinc)
    { structure_->Evaluate(disiterinc); }

    /// update at time step end
    virtual void Update()
    { structure_->Update(); }

    /// update at time step end
    virtual void Update(const double endtime)
    { structure_->Update(endtime); }

    /// resize MStep objects for AB2
    virtual void ResizeMStepTimAda()
    { structure_->ResizeMStepTimAda(); }

    /// update iteration; add residual increment to Lagrange multipliers stored in Constraint manager
    virtual void UpdateIterIncrConstr(Teuchos::RCP<Epetra_Vector> lagrincr)
    { structure_->UpdateIterIncrConstr(lagrincr); }

    /// update iteration; add residual increment to pressures stored in Windkessel manager
    virtual void UpdateIterIncrWindkessel(Teuchos::RCP<Epetra_Vector> presincr)
    { structure_->UpdateIterIncrWindkessel(presincr); }

    /// access to output object
    virtual Teuchos::RCP<IO::DiscretizationWriter> DiscWriter()
    { return structure_->DiscWriter();}

    /// prepare output (i.e. calculate stresses, strains, energies)
    virtual void PrepareOutput()
    { return structure_->PrepareOutput(); }

    // Get restart data
    virtual void GetRestartData
    (
      Teuchos::RCP<int> step,
      Teuchos::RCP<double> time,
      Teuchos::RCP<Epetra_Vector> disn,
      Teuchos::RCP<Epetra_Vector> veln,
      Teuchos::RCP<Epetra_Vector> accn,
      Teuchos::RCP<std::vector<char> > elementdata,
      Teuchos::RCP<std::vector<char> > nodedata
    )
    {return structure_->GetRestartData(step,time, disn,veln,accn,elementdata,nodedata );}

    /// output results
    virtual void Output(bool forced_writerestart = false)
    { return structure_->Output(forced_writerestart); }

    /// output results to screen
    virtual void PrintStep()
    { return structure_->PrintStep(); }

    /// read restart information for given time step
    virtual void ReadRestart(const int step)
    { return structure_->ReadRestart(step); }

     /// set restart information for parameter continuation
    virtual void SetRestart
    (
      int step,
      double time,
      Teuchos::RCP<Epetra_Vector> disn,
      Teuchos::RCP<Epetra_Vector> veln,
      Teuchos::RCP<Epetra_Vector> accn,
      Teuchos::RCP<std::vector<char> > elementdata,
      Teuchos::RCP<std::vector<char> > nodedata
    )
    {return structure_->SetRestart(step,time,disn,veln,accn,elementdata,nodedata);}

    /// evaluate reference state (for frictional contact)
    virtual void EvaluateReferenceState()
    { structure_->EvaluateReferenceState(); }

    //@}


    //! @name Solver calls
    //@{

    /// nonlinear solve
    virtual int Solve()
    { return structure_->Solve(); }

    //! linear structure solve with just an interface load
    virtual Teuchos::RCP<Epetra_Vector> SolveRelaxationLinear()
    { return structure_->SolveRelaxationLinear(); }

    /// get the linear solver object used for this field
    virtual Teuchos::RCP<LINALG::Solver> LinearSolver()
    { return structure_->LinearSolver(); }

    //@}


    //! @name volume coupled specific methods
    //@{

    /// set forces due to interface with fluid, the force is expected external-force-like
    virtual void SetForceInterface(Teuchos::RCP<Epetra_MultiVector> iforce)
    { structure_->SetForceInterface(iforce); }

    //! specific method for iterative staggered partitioned TSI
    virtual void PreparePartitionStep()
    { structure_->PreparePartitionStep(); }

    //@}


    //! @name Write access to field solution variables at \f$t^{n+1}\f$
    //@{

    /// write access to extract displacements at \f$t^{n+1}\f$
    virtual Teuchos::RCP<Epetra_Vector> WriteAccessDispnp()
    { return structure_->WriteAccessDispnp(); }

    /// write access to extract velocities at \f$t^{n+1}\f$
    virtual Teuchos::RCP<Epetra_Vector> WriteAccessVelnp()
    { return structure_->WriteAccessVelnp(); }

    //@}

    /// extract rhs (used to calculate reaction force for post-processing)
    virtual Teuchos::RCP<Epetra_Vector> Freact()
    { return structure_->Freact(); }

    //! @name Structure with ale specific methods
    //@{

    /// material displacements (structure with ale)
    virtual Teuchos::RCP<Epetra_Vector> DispMat()
    { return structure_->DispMat(); }

    /// apply material displacements to structure field (structure with ale)
    virtual void ApplyDisMat(Teuchos::RCP<Epetra_Vector> dismat, bool iterated=false)
    { structure_->ApplyDisMat(dismat, iterated); }

    //@}


    /// create result test for encapsulated structure algorithm
    virtual Teuchos::RCP<DRT::ResultTest> CreateFieldTest()
    { return structure_->CreateFieldTest(); }

    //! @name Biofilm specific methods
    //@{

    virtual void SetStrGrDisp(Teuchos::RCP<Epetra_Vector> struct_growth_disp)
    { return structure_->SetStrGrDisp(struct_growth_disp); }

    //@}

    //! @name Crack specific methods
    //@{

    /// Propagate crack within the structure and accordingly modify the discretization
    virtual bool UpdateCrackInformation(Teuchos::RCP<const Epetra_Vector> displace){ return structure_->UpdateCrackInformation( displace ); }

    /// Write Gmsh output for structural field
    virtual void writeGmshStrucOutputStep() { return structure_->writeGmshStrucOutputStep(); }

    /// Get map of newly introduced node ids with their corresponding old node ids
    virtual std::map<int,int> getOldNewCrackNodes(){ return structure_->getOldNewCrackNodes(); }

    /// Get current crack tip nodes
    virtual std::vector<int> GetCrackTipNodes(){ return structure_->GetCrackTipNodes(); }

    //@}


  protected:

    Teuchos::RCP<Structure> structure_;   ///< underlying structural time integration
  };


  /// Calculate increments from absolute values
  class StructureNOXCorrectionWrapper : public StructureWrapper
  {
  public:

    explicit StructureNOXCorrectionWrapper(Teuchos::RCP<Structure> structure)
      : StructureWrapper(structure) {}

    virtual void PrepareTimeStep();

    //! Evaluate() routine that can handle NOX step increments by computing the
    //! last iteration increment needed for structural Evaluate() call
    virtual void Evaluate(Teuchos::RCP<const Epetra_Vector> disstepinc);

  private:

    /// sum of displacement increments already applied,
    ///
    /// there are two increments around
    ///
    /// x^n+1_i+1 = x^n+1_i + disiterinc  (also referred to as residual increment)
    ///
    /// x^n+1_i+1 = x^n     + disstepinc
    Teuchos::RCP<Epetra_Vector> disstepinc_;
  };
}

#endif
