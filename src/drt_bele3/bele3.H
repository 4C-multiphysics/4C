/*!
 * \file bele3.H
 *
 * <pre>
 * Maintainer: Axel Gerstenberger
 *             gerstenberger@lnm.mw.tum.de
 *             http://www.lnm.mw.tum.de
 *             089 - 289-15236
 * </pre>
 */

#ifndef BELE3_H
#define BELE3_H


#include "Teuchos_RefCountPtr.hpp"
#include "Epetra_Vector.h"

#include "../drt_lib/drt_element.H"
#include "../drt_lib/drt_elementtype.H"
#include "../drt_lib/drt_elementtype.H"
#include "../drt_lib/drt_parobjectfactory.H"
#include "../drt_lib/drt_node.H"
#include "../drt_fem_general/drt_utils_integration.H"


namespace DRT
{
// forward declarations
class Discretization;


namespace ELEMENTS
{

class Bele3Type : public DRT::ElementType
{
public:

  std::string Name() const { return "Bele3Type"; }

  static Bele3Type & Instance() { return instance_; };

  virtual DRT::ParObject* Create( const std::vector<char> & data );

  virtual Teuchos::RCP<DRT::Element> Create( const string eletype,
                                             const string eledistype,
                                             const int id,
                                             const int owner );

  virtual Teuchos::RCP<DRT::Element> Create( const int id, const int owner );

  virtual void NodalBlockInformation( DRT::Element * dwele, int & numdf, int & dimns, int & nv, int & np );

  virtual void ComputeNullSpace( DRT::Discretization & dis, std::vector<double> & ns, const double * x0, int numdf, int dimns );

private:

  static Bele3Type instance_;
};

/*!
 * A 3D boundary element with no physics attached
 *
 * This element is meant to have no physics. It can be used to have a boundary discretization
 * of surface/boundary elements. They can be of any 2d shape (quad4,quad9,tri3,...)
 *
 * The number of dof per node is set to 3, so we can define displacement vectors by
 * using FillComplete on the boundary discretization.
 *
 * \author axelchen (gerstenberger@lnm.mw.tum.de)
 */
class Bele3 : public DRT::Element
{
public:

  //@}
  //! @name Constructors and destructors and related methods

  /*!
  \brief Standard Constructor
  */
  explicit Bele3(
      int id,     ///< A unique global id
      int owner   ///< proc num that owns this element
      );

  /*!
  \brief Copy Constructor

  Makes a deep copy of a Element

  */
  explicit Bele3(const Bele3& old);

  DRT::Element* Clone() const;
  virtual DiscretizationType Shape() const;
  virtual int NumLine() const
  {
    if (NumNode()==9 || NumNode()==8 || NumNode()==4) return 4;
    else if (NumNode()==3 || NumNode()==6) return 3;
    else
    {
      dserror("Could not determine number of lines");
      return -1;
    }
  }
  virtual int NumSurface() const {return 1;}
  virtual int NumVolume() const {return -1;}
  virtual vector<RCP<DRT::Element> > Lines();
  virtual vector<RCP<DRT::Element> > Surfaces();
  virtual int UniqueParObjectId() const { return Bele3Type::Instance().UniqueParObjectId(); }
  virtual void Pack(DRT::PackBuffer& data) const;
  virtual void Unpack(const std::vector<char>& data);

  /*!
  \brief Destructor

  */
  virtual ~Bele3();

  //@}

  //! @name Access methods

  virtual int NumDofPerNode(const DRT::Node&) const {return 3;}
  virtual int NumDofPerElement() const { return 0; }
  void Print(ostream& os) const;
  virtual DRT::ElementType & ElementType() const { return Bele3Type::Instance(); }

  //@}

  //! @name Evaluation

  int Evaluate(ParameterList& params,
               DRT::Discretization&      discretization,
               vector<int>&              lm,
               Epetra_SerialDenseMatrix& elemat1,
               Epetra_SerialDenseMatrix& elemat2,
               Epetra_SerialDenseVector& elevec1,
               Epetra_SerialDenseVector& elevec2,
               Epetra_SerialDenseVector& elevec3);

  virtual int EvaluateNeumann(ParameterList& params,
                              DRT::Discretization&      discretization,
                              DRT::Condition&           condition,
                              vector<int>&              lm,
                              Epetra_SerialDenseVector& elevec1,
                              Epetra_SerialDenseMatrix* elemat1 = NULL);


  //@}

  //! @name Other
  //! does this element have non-zero displacements or not
//  bool IsMoving() const { return is_moving_; }

  //@}


private:

  //! action parameters recognized by bele3
  enum ActionType
  {
    none
  };

  /*!
   * \brief check, whether higher order derivatives for shape functions (dxdx, dxdy, ...) are necessary
   * \return boolean indicating higher order status
   */
  bool isHigherOrderElement(
    const DRT::Element::DiscretizationType  distype
    ) const
    {
      bool hoel = true;
      switch (distype)
      {
          case quad4: case quad8: case quad9: case tri6:
            hoel = true;
            break;
          case tri3:
            hoel = false;
            break;
          default:
            dserror("distype unknown!");
      }
      return hoel;
    };

  //! vector with line elements
//  vector<RCP<DRT::Element> >                      lines_;

  //! flag for fixed or moving boundary
//  const bool                                      is_moving_;

  //! don't want = operator
  Bele3& operator = (const Bele3& old);

  //! set number of gauss points to element shape default
  DRT::UTILS::GaussRule2D getOptimalGaussrule(const DiscretizationType& distype) const;

}; // class Bele3



//=======================================================================
//=======================================================================
//=======================================================================
//=======================================================================

class Bele3LineType : public DRT::ElementType
{
public:

  std::string Name() const { return "Bele3LineType"; }

  static Bele3LineType & Instance() { return instance_; };

  virtual Teuchos::RCP<DRT::Element> Create( const int id, const int owner );

  virtual void NodalBlockInformation( DRT::Element * dwele, int & numdf, int & dimns, int & nv, int & np ) {}

  virtual void ComputeNullSpace( DRT::Discretization & dis, std::vector<double> & ns, const double * x0, int numdf, int dimns ) {}

private:

  static Bele3LineType instance_;
};


/*!
\brief An element representing a line of a bele3 element

\author gerstenberger (gerstenberger@lnm.mw.tum.de)
*/
class Bele3Line : public DRT::Element
{
public:

  //! @name Constructors and destructors and related methods

  /*!
  \brief Standard Constructor

  \param id : A unique global id
  \param owner: Processor owning this line
  \param nnode: Number of nodes attached to this element
  \param nodeids: global ids of nodes attached to this element
  \param nodes: the discretizations map of nodes to build ptrs to nodes from
  \param parent: The parent fluid element of this line
  \param lline: the local line number of this line w.r.t. the parent element
  */
  Bele3Line(int id, int owner, int nnode, const int* nodeids,
             DRT::Node** nodes, DRT::ELEMENTS::Bele3* parent, const int lline);

  /*!
  \brief Copy Constructor

  Makes a deep copy of a Element

  */
  Bele3Line(const Bele3Line& old);

  DRT::Element* Clone() const;
  virtual DiscretizationType Shape() const;
  virtual int UniqueParObjectId() const { return Bele3LineType::Instance().UniqueParObjectId(); }
  virtual void Pack(DRT::PackBuffer& data) const;
  virtual void Unpack(const std::vector<char>& data);

  /*!
  \brief Destructor

  */
  virtual ~Bele3Line();

  //@}

  //! @name Access methods


  /*!
  \brief Get number of degrees of freedom of a certain node
         (implements pure virtual DRT::Element)

  For this 3D boundary element, we have 3 displacements, if needed
  */
  virtual int NumDofPerNode(const DRT::Node&) const { return 3; }

  virtual int NumDofPerElement() const { return 0; }

  void Print(ostream& os) const;

  virtual DRT::ElementType & ElementType() const
  { return Bele3LineType::Instance(); }

  //@}

    //! @name Evaluation

  virtual int Evaluate(ParameterList& params,
               DRT::Discretization&      discretization,
               vector<int>&              lm,
               Epetra_SerialDenseMatrix& elemat1,
               Epetra_SerialDenseMatrix& elemat2,
               Epetra_SerialDenseVector& elevec1,
               Epetra_SerialDenseVector& elevec2,
               Epetra_SerialDenseVector& elevec3);

  //! @name Evaluate methods

  virtual int EvaluateNeumann(ParameterList& params,
                              DRT::Discretization&      discretization,
                              DRT::Condition&           condition,
                              vector<int>&              lm,
                              Epetra_SerialDenseVector& elevec1,
                              Epetra_SerialDenseMatrix* elemat1 = NULL);

  //@}

private:

  //! action parameters recognized by Bele3Line
  enum ActionType
  {
     none,
     integrate_Shapefunction
  };

  //! don't want = operator
  Bele3Line& operator = (const Bele3Line& old);

  //! The parent element of this line
  DRT::ELEMENTS::Bele3* parent_;
  //! The local line number of this line w.r.t to the parent_ element
  int                    lline_;



  //! compute infintesimal line element dr for integration along the line
  double  f2_substitution(
		      const Epetra_SerialDenseMatrix  xyze,
		      const Epetra_SerialDenseMatrix  deriv,
		      const int iel);

  //! Get Rule for Gaussintegration according to DRT::UTIL
  DRT::UTILS::GaussRule1D getOptimalGaussrule(const DiscretizationType& distype);

  //! integrate shape functions over a line
  void IntegrateShapeFunction(
      ParameterList&             params,
      DRT::Discretization&       discretization,
      const vector<int>&         lm,
      Epetra_SerialDenseVector&  elevec1,
      const std::vector<double>& edispnp
      );


}; // class Bele3Line




} // namespace ELEMENTS
} // namespace DRT


#endif
