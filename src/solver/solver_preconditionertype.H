/*!----------------------------------------------------------------------
\file solver_preconditionertype.H

<pre>
Maintainer: Tobias Wiesner
            wiesner@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15240
Created on: Jul 4, 2011
</pre>
*----------------------------------------------------------------------*/
#ifndef SOLVER_PRECONDITIONERTYPE_H_
#define SOLVER_PRECONDITIONERTYPE_H_

#include "Epetra_Comm.h"
#include "Epetra_Map.h"
#include "Epetra_Operator.h"
#include "Epetra_LinearProblem.h"
#include "Epetra_CrsGraph.h"
#include "Epetra_CrsMatrix.h"
#include "Epetra_Vector.h"

#include "Teuchos_RefCountPtr.hpp"
#include "Teuchos_ParameterList.hpp"

namespace LINALG
{
  namespace SOLVER
  {
    /// preconditioner base class
    /*!

      A KrylovSolver object needs one (or more) preconditioner objects. There
      are many possible preconditioners. A unified framework simplifies the
      solution process.

      \author u.kue
      \date 04/11
     */
    class PreconditionerType
    {
    public:

      /// construction with output on proc 0 (might be NULL)
      /*!
        No setup is done upon construction, only the preconditioner object is
        created.
       */
      explicit PreconditionerType( FILE * outfile );

      /// virtual destruction
      virtual ~PreconditionerType() {}

      /// linear problem created (managed) by this preconditioner
      /*!
        This is how aztec sees the linear problem that needs to be solved.
       */
      virtual Epetra_LinearProblem & LinearProblem() { return lp_; }

      /// support routine for setup
      void SetupLinearProblem( Epetra_Operator * matrix,
                               Epetra_MultiVector * x,
                               Epetra_MultiVector * b );

      /// Setup preconditioner with a given linear system.
      virtual void Setup( bool create,
                          Epetra_Operator * matrix,
                          Epetra_MultiVector * x,
                          Epetra_MultiVector * b ) = 0;

      /// Finish calculation after linear solve.
      /*!
        This is empty in most cases, however some preconditioners might want to
        scale the solution.
       */
      virtual void Finish( Epetra_Operator * matrix,
                           Epetra_MultiVector * x,
                           Epetra_MultiVector * b ) {}

      /// linear operator used for preconditioning
      /*!
        This is how aztec sees the linear operator to be used for preconditioning.
       */
      virtual Epetra_Operator * PrecOperator() const = 0;

      /// Apply inverse of the preconditioner
      int ApplyInverse(const Epetra_MultiVector& X, Epetra_MultiVector& Y) const
      {
        return PrecOperator()->ApplyInverse( X, Y );
      }

      /// debug output
      virtual void Print( std::ostream & stream ) = 0;

    protected:

      //! a linear problem wrapper class used by Trilinos and for scaling of the system
      Epetra_LinearProblem lp_;

      //! file to write output to (proc 0 only, can be NULL on input)
      FILE * outfile_;
    };
  }
}


#endif /* SOLVER_PRECONDITIONERTYPE_H_ */
