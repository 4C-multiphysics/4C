/*----------------------------------------------------------------------*/
/*! \file

\brief Definition of one line of an input file.

\level 0


*/
/*----------------------------------------------------------------------*/

#ifndef LINEDEFINITION_H
#define LINEDEFINITION_H

#include <iostream>
#include <string>
#include <utility>
#include <vector>

#include "inputreader.H"

namespace DRT
{
  namespace INPUT
  {
    class LineDefinition;
    class Lines;

    /// base class of line components
    /*!
      There are internal subclasses to this class that do the actual work.

      \author u.kue
      \date 08/09
     */
    class LineComponent
    {
     public:
      virtual ~LineComponent() = default;

      /// creat an exact copy of this component
      virtual LineComponent* Clone() = 0;

      /// print to a dat file comment
      virtual void Print(std::ostream& stream) = 0;

      /// try to read component from input line
      virtual bool Read(LineDefinition& definition, std::istream& stream) = 0;

      /// try to read component from input line
      virtual bool Read(LineDefinition& definition, std::string& name, std::istream& stream) = 0;

      /// try to read component from input line
      virtual bool Read(std::istream& stream) = 0;

      /// tell if the component has the specified name tag
      virtual bool IsNamed(std::string name) = 0;
    };


    /// definition of one (possible) line in a dat file
    /*!
      LineDefinition defines how one specific line in a dat file looks like. The
      idea is, that each line consists of a list of components.

      Reading a LineDefinition means filling the components with those values
      found at the input line.

      \note This is a low level class. Therefore, we do not use Teuchos::RCP much but
      instead deallocate the internal objects by hand. For this reason there are
      also proper (not exception save) copy operators provided.

      \author u.kue
      \date 08/09
     */
    class LineDefinition
    {
     public:
      LineDefinition();
      ~LineDefinition();

      LineDefinition(const LineDefinition& other);

      LineDefinition& operator=(const LineDefinition& other);

      /// create an exact copy of this LineDefinition
      Teuchos::RCP<DRT::INPUT::LineDefinition> Clone() const;

      /// @name Add new line components

      /// add a single string definition
      LineDefinition& AddTag(std::string name);

      /// add a single string variable
      LineDefinition& AddString(std::string name);

      /// add a single integer variable
      LineDefinition& AddInt(std::string name);

      /// add a vector of integer variables
      LineDefinition& AddIntVector(std::string name, int length);

      /// add a vector of double variables
      LineDefinition& AddDoubleVector(std::string name, int length);

      /// add a name followed by a variable string
      LineDefinition& AddNamedString(std::string name);

      /// add a name followed by an integer variable
      LineDefinition& AddNamedInt(std::string name);

      /// add a name followed by a vector of integer variables
      LineDefinition& AddNamedIntVector(std::string name, int length);

      /// add a name followed by a double variable
      LineDefinition& AddNamedDouble(std::string name);

      /// add a name followed by a vector of double variables
      LineDefinition& AddNamedDoubleVector(std::string name, int length);

      /// add a name followed by a vector of double variables
      /*!
        The parameter \p lengthdef specifies the name of an integer component
        that gives the length of the vector. The integer component has to
        precede the vector definition on the input line.
       */
      LineDefinition& AddNamedDoubleVector(std::string name, std::string lengthdef);

      /// add a single string definition
      LineDefinition& AddOptionalTag(const std::string& name);

      /// add a name followed by a variable string
      LineDefinition& AddOptionalNamedString(const std::string& name);

      /// add a name followed by an integer variable
      LineDefinition& AddOptionalNamedInt(const std::string& name);

      /// add a name followed by a vector of integer variables
      LineDefinition& AddOptionalNamedIntVector(const std::string& name, int length);

      /// add a name followed by a double variable
      LineDefinition& AddOptionalNamedDouble(const std::string& name);

      /// add a name followed by a vector of double variables
      LineDefinition& AddOptionalNamedDoubleVector(const std::string& name, int length);

      /// add a name followed by a vector of double variables
      /*!
            The parameter \p lengthdef specifies the name of an integer component
            that gives the length of the vector. The integer component has to
            precede the vector definition on the input line.
       */
      LineDefinition& AddOptionalNamedDoubleVector(const std::string& name, std::string lengthdef);

      /// add a name followed by a vector of string variables
      LineDefinition& AddOptionalNamedStringVector(const std::string& name, int length);

      /// add a name followed by a vector of string variables
      /*!
            The parameter \p lengthdef specifies the name of an integer component
            that gives the length of the vector. The integer component has to
            precede the vector definition on the input line.
            The space defines the separation between a string and the next one.
       */
      LineDefinition& AddOptionalNamedStringVector(const std::string& name, std::string lengthdef);

      /// add a name followed by a vector of double variables
      /*!
        The parameter \p lengthdef specifies the name of an integer component
        that gives the length of the vector. The integer component has to
        precede the vector definition on the input line.
       */
      LineDefinition& AddOptionalNamedPairOfStringAndDoubleVector(
          const std::string& name, std::string lengthdef);

      //@}

      /// print to dat file comment
      void Print(std::ostream& stream) const;

      /// try to read this line from the stream
      /*!
        If reading succeeds, the LineDefinition contains the values of the
        line. Otherwise, the values are undefined and should not be used.

        @return true on success
       */
      bool Read(std::istream& stream);

      /// try to read this line from the stream, but skip the component named name
      /*!
        If reading succeeds, the LineDefinition contains the values of the
        line. Otherwise, the values are undefined and should not be used.

        @return true on success
       */
      bool Read(std::istream& stream, const std::string* name);

      /// tell if there is a named component with the given name
      bool HaveNamed(std::string name) const;

      /// @name Extract values from read LineDefinition
      /// There has to be a named component of the given type

      void ExtractString(const std::string& name, std::string& value) const;
      bool HasString(const std::string& name) const;
      void ExtractInt(const std::string& name, int& value) const;
      void ExtractIntVector(const std::string& name, std::vector<int>& v) const;
      void ExtractDouble(const std::string& name, double& value) const;
      void ExtractDoubleVector(const std::string& name, std::vector<double>& v) const;
      void ExtractStringVector(const std::string& name, std::vector<std::string>& v) const;
      void ExtractPairOfStringAndDoubleVector(
          const std::string& name, std::vector<std::pair<std::string, double>>& v) const;

      //@}

     private:
      /// find named component with given name
      LineComponent* FindNamed(const std::string& name) const;

      /// remove all components
      void Clear();

      /// list of components
      std::vector<LineComponent*> components_;

      /// optional tail, only named components here
      std::map<std::string, LineComponent*> optionaltail_;

      /// components from tail read in last line
      std::set<std::string> readtailcomponents_;
    };


    /// a collection of LineDefinitions
    /*!
      The Lines class is used to describe and read input lines from the dat
      file. The point is, the description of the line is used for the actual
      reading. This way the description is never out of sync with the reading
      routines. Furthermore, the reading code and the line definition code are
      separated. All the user needs to do is add a new definition.

      Lines describes a dat file section that consists of any number of specific
      lines. At the time being Lines is used for curves and functions
      sections. Here, each line can be of one of a list of given formats.

      Reading means finding the LineDefinition that matches the input line
      exactly and filling its internal values. After reading the user has to
      extract the values from the LineDefinition.

      \author u.kue
      \date 08/09
     */
    class Lines
    {
     public:
      /// construct to read a given section
      explicit Lines(std::string sectionname) : sectionname_(std::move(sectionname)) {}

      /// add a new LineDefinition
      void Add(const LineDefinition& ld) { definitions_.push_back(ld); }

      /// print all LineDefinitions as dat file comment
      void Print(std::ostream& stream);

      /// read section and return one LineDefinition per line read
      std::vector<Teuchos::RCP<DRT::INPUT::LineDefinition>> Read(
          DatFileReader& reader, int suffix = -1);

     private:
      /// read given line and return LineDefinition
      Teuchos::RCP<DRT::INPUT::LineDefinition> Read(const char* line);

      /// name of the section we read
      std::string sectionname_;

      /// all possible LineDefinitions
      std::vector<LineDefinition> definitions_;
    };

  }  // namespace INPUT
}  // namespace DRT

#endif
