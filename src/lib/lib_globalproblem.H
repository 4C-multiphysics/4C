/*----------------------------------------------------------------------*/
/*! \file

\brief internal representation of an input file

\level 1


*/
/*----------------------------------------------------------------------*/


#ifndef GLOBALPROBLEM_H
#define GLOBALPROBLEM_H

#include <memory>
#include <vector>

#include <Epetra_Comm.h>
#include <Teuchos_RCP.hpp>
#include <Teuchos_ParameterListAcceptorDefaultBase.hpp>

#include "lib_globalproblem_enums.H"
#include "lib_function.H"
#include "lib_resulttest.H"
#include "lib_utils.H"

namespace IO
{
  class OutputControl;
  class InputControl;
  class ErrorFileControl;
}  // namespace IO

namespace COMM_UTILS
{
  class Communicators;
}

namespace MAT
{
  namespace PAR
  {
    class Bundle;
  }
}  // namespace MAT

namespace PARTICLEENGINE
{
  class ParticleObject;
}

namespace CONTACT
{
  namespace CONSTITUTIVELAW
  {
    class Bundle;
  }
}  // namespace CONTACT

namespace DRT
{
  class Discretization;

  namespace INPUT
  {
    class DatFileReader;
  }


  /// Global problem instance that keeps the discretizations
  /*!

    The global problem represents the input file passed to baci. This
    class organizes the reading of a dat file (utilizing the
    DatFileReader of course). That is way, in all but the most eccentric
    cases there will be exactly one object of this class during a baci
    run. This object contains all parameters read from the input file as
    well as any material definitions and even all the discretizations.

    <h3>Input parameters</h3>

    All input parameters are known by the global problem object. These
    parameters are guaranteed to be valid (because they passed the
    validation) and are guaranteed to be there (because default values
    have been set for all parameters missing from the input file.) This
    is Teuchos::ParameterList magic, that just requires the list of
    valid parameters in the file validparameters.cpp to be
    complete.

    The algorithms are meant to ask the global problem object for their
    parameters and extract them from the respective parameter list
    directly.

    <h3>Discretizations</h3>

    The global problem object knows the discretizations defined by the
    input file. In order to access a particular discretization you get
    the global problem object and ask.

    <h3>Materials</h3>

    The global problem object knows the material descriptions from the
    input file. These are not to be confused with the material classes
    the elements know and work with. The global problem object does not
    keep track of gauss point material values, all that is known here
    are the definitions from the input file.

    <h3>Purpose</h3>

    baci evolved out of ccarat in a (somewhat) smooth fashion. The old
    ccarat used global C struct variables all over the place. It is
    indeed the aim of the global problem to collect these variables in
    one place and provide a sane interface to the data. The transition
    is already pretty advanced, however there are still many places
    where global variables are used. These places will have to be
    revised some day.

    The global problem class is still evolving.

    \note It is illegal to introduce new global variables in baci. It is
    illegal to use global variables where other means to do the job are
    available. We just did not get around to remove all of them yet.

    <h3>Singleton behavior</h3>

    \warning This is a guru only section!

    The global problem behaves like a singleton, so there is always one
    instance available. But you can have more than one instance of
    Problem. In normal situations this will not be needed. So don't
    bother. Just call the static Instance() function to get the global
    instance and access your discretizations.

    In the special case that you want to read more that one input file,
    however, you will need to handle the fields from each file
    separately. This is something you cannot do with ccarat's field
    variable so in that case you will have to rely on a second Problem
    instance.

    One artefact that comes from using global variables together with
    multiple Problem objects is the notion of activating of problem
    object. This translates to setting the global variable pointers to
    this Problem object's internal variables. Normally, if there is just
    one Problem object, this is done by default. If you need more that
    one, however, you will have to activate the global problems
    yourself.

    \author u.kue
    \date 06/07
   */
  class Problem : public Teuchos::ParameterListAcceptorDefaultBase
  {
   public:
    /// @name Instances

    /// return an instance of this class
    static Problem* Instance(int num = 0);

    /// return number of problem instances
    static unsigned NumInstances() { return instances_.size(); }

    /// calculation done, clean up
    /*!
      There can be a variety of objects to a problem. Some of them might
      require proper cleanup. Make sure we always do it.
     */
    static void Done();

    //@}

    /// @name Input

    /// read global parameters
    void ReadParameter(DRT::INPUT::DatFileReader& reader);

    /// setup the discretizations
    void ReadFields(DRT::INPUT::DatFileReader& reader, const bool readmesh = true);

    /// set up micro-scale discretizations in case of structure multi-scale simulations
    void ReadMicroFields(DRT::INPUT::DatFileReader& reader);

    /// set up supporting processors for micro-scale discretizations
    void ReadMicrofieldsNPsupport();

    /// input of contact constitutive laws
    void ReadContactConstitutiveLaws(DRT::INPUT::DatFileReader& reader);

    /// input of materials
    void ReadMaterials(DRT::INPUT::DatFileReader& reader);

    /// setup map between materials of original and cloned elements
    void ReadCloningMaterialMap(DRT::INPUT::DatFileReader& reader);

    /// input of conditions
    void ReadConditions(DRT::INPUT::DatFileReader& reader);

    /// input of time curves, functions and result tests
    void ReadTimeFunctionResult(DRT::INPUT::DatFileReader& reader);

    /// input of knots for isogeometric analysis
    void ReadKnots(DRT::INPUT::DatFileReader& reader);

    /// input of particles
    void ReadParticles(DRT::INPUT::DatFileReader& reader);

    /// set restart step which was read from the command line
    void SetRestartStep(int r);

    void SetInputControlFile(Teuchos::RCP<IO::InputControl>& input) { inputcontrol_ = input; }

    /// manipulate problem type
    void SetProblemType(ProblemType targettype);

    //@}

    /// @name General query methods
    /// Once and for all definitions

    /// give enum of my problem type
    ProblemType GetProblemType() const;

    /// give string name of my problem type
    std::string ProblemName() const;

    /// return restart step
    int Restart() const;

    /// return restart time
    double RestartTime() const;

    /// number of space dimensions (as specified in the input file)
    int NDim() const;

    /// current wall time in seconds with micro second precision
    static double Walltime();

    //! Return string name of the basis function type (polynomial/nurbs)
    std::string SpatialApproximation() const;

    //! Return type of the basis function encoded as enum
    ShapeFunctionType SpatialApproximationType() const { return shapefuntype_; }

    //! @}

    /// @name Control file

    /*!
    \brief Create control file for output and read restart data if required

    In addition, issue a warning to the screen, if no binary output will be written.

    @param[in] comm Communicator
    @param[in] inputfile File name of input file
    @param[in] prefix
    @param[in] restartkenner
    */
    void OpenControlFile(const Epetra_Comm& comm, const std::string& inputfile, std::string prefix,
        const std::string& restartkenner);

    /// error files
    void OpenErrorFile(
        const Epetra_Comm& comm, std::string prefix, const bool enforceopening = false);

    /// control file for restart read
    Teuchos::RCP<IO::InputControl> InputControlFile() { return inputcontrol_; }

    /// control file for normal output
    Teuchos::RCP<IO::OutputControl> OutputControlFile() { return outputcontrol_; }

    /// control error files
    Teuchos::RCP<IO::ErrorFileControl> ErrorFile() { return errorfilecontrol_; }

    /// write parameters read from input file for documentation
    void WriteInputParameters();

    //@}

    /// @name Parameters read from file

    /// Set parameters from a parameter list and return with default values.
    void setParameterList(Teuchos::RCP<Teuchos::ParameterList> const& paramList) override;

    /// Return a const parameter list of all of the valid parameters that
    /// this->setParameterList(...) will accept.
    Teuchos::RCP<const Teuchos::ParameterList> getValidParameters() const override;

    /// @name Communicators and their parallel groups

    /// set communicators
    void SetCommunicators(Teuchos::RCP<COMM_UTILS::Communicators> communicators);

    /// return communicators
    Teuchos::RCP<COMM_UTILS::Communicators> GetCommunicators() const;

    //@}

    /// @name Input parameter sections
    /// direct access to parameters from input file sections

    const Teuchos::ParameterList& BinningStrategyParams() const
    {
      return getParameterList()->sublist("BINNING STRATEGY");
    }
    const Teuchos::ParameterList& GeometricSearchParams() const
    {
      return getParameterList()->sublist("BOUNDINGVOLUME STRATEGY");
    }
    const Teuchos::ParameterList& IOParams() const { return getParameterList()->sublist("IO"); }
    const Teuchos::ParameterList& DesignDescriptionParams() const
    {
      return getParameterList()->sublist("DESIGN DESCRIPTION");
    }
    const Teuchos::ParameterList& PatSpecParams() const
    {
      return getParameterList()->sublist("PATIENT SPECIFIC");
    }
    const Teuchos::ParameterList& StructuralDynamicParams() const
    {
      return getParameterList()->sublist("STRUCTURAL DYNAMIC");
    }
    const Teuchos::ParameterList& Cardiovascular0DStructuralParams() const
    {
      return getParameterList()->sublist("CARDIOVASCULAR 0D-STRUCTURE COUPLING");
    }
    const Teuchos::ParameterList& StatInverseAnalysisParams() const
    {
      return getParameterList()->sublist("STAT INVERSE ANALYSIS");
    }
    const Teuchos::ParameterList& MortarCouplingParams() const
    {
      return getParameterList()->sublist("MORTAR COUPLING");
    }
    const Teuchos::ParameterList& ContactDynamicParams() const
    {
      return getParameterList()->sublist("CONTACT DYNAMIC");
    }
    const Teuchos::ParameterList& BeamInteractionParams() const
    {
      return getParameterList()->sublist("BEAM INTERACTION");
    }
    const Teuchos::ParameterList& BrownianDynamicsParams() const
    {
      return getParameterList()->sublist("BROWNIAN DYNAMICS");
    }
    const Teuchos::ParameterList& ThermalDynamicParams() const
    {
      return getParameterList()->sublist("THERMAL DYNAMIC");
    }
    const Teuchos::ParameterList& TSIDynamicParams() const
    {
      return getParameterList()->sublist("TSI DYNAMIC");
    }
    const Teuchos::ParameterList& FluidDynamicParams() const
    {
      return getParameterList()->sublist("FLUID DYNAMIC");
    }
    const Teuchos::ParameterList& TwoPhaseFlowParams() const
    {
      return getParameterList()->sublist("TWO PHASE FLOW");
    }
    const Teuchos::ParameterList& LubricationDynamicParams() const
    {
      return getParameterList()->sublist("LUBRICATION DYNAMIC");
    }
    const Teuchos::ParameterList& ScalarTransportDynamicParams() const
    {
      return getParameterList()->sublist("SCALAR TRANSPORT DYNAMIC");
    }
    const Teuchos::ParameterList& STIDynamicParams() const
    {
      return getParameterList()->sublist("STI DYNAMIC");
    }
    const Teuchos::ParameterList& FS3IDynamicParams() const
    {
      return getParameterList()->sublist("FS3I DYNAMIC");
    }
    const Teuchos::ParameterList& AleDynamicParams() const
    {
      return getParameterList()->sublist("ALE DYNAMIC");
    }
    const Teuchos::ParameterList& FSIDynamicParams() const
    {
      return getParameterList()->sublist("FSI DYNAMIC");
    }
    const Teuchos::ParameterList& FPSIDynamicParams() const
    {
      return getParameterList()->sublist("FPSI DYNAMIC");
    }
    const Teuchos::ParameterList& ImmersedMethodParams() const
    {
      return getParameterList()->sublist("IMMERSED METHOD");
    }
    const Teuchos::ParameterList& CutGeneralParams() const
    {
      return getParameterList()->sublist("CUT GENERAL");
    }
    const Teuchos::ParameterList& XFEMGeneralParams() const
    {
      return getParameterList()->sublist("XFEM GENERAL");
    }
    const Teuchos::ParameterList& XFluidDynamicParams() const
    {
      return getParameterList()->sublist("XFLUID DYNAMIC");
    }
    const Teuchos::ParameterList& FBIParams() const
    {
      return getParameterList()->sublist("FLUID BEAM INTERACTION");
    }
    const Teuchos::ParameterList& LOMAControlParams() const
    {
      return getParameterList()->sublist("LOMA CONTROL");
    }
    const Teuchos::ParameterList& BIOFILMControlParams() const
    {
      return getParameterList()->sublist("BIOFILM CONTROL");
    }
    const Teuchos::ParameterList& ELCHControlParams() const
    {
      return getParameterList()->sublist("ELCH CONTROL");
    }
    const Teuchos::ParameterList& EPControlParams() const
    {
      return getParameterList()->sublist("CARDIAC MONODOMAIN CONTROL");
    }
    const Teuchos::ParameterList& ArterialDynamicParams() const
    {
      return getParameterList()->sublist("ARTERIAL DYNAMIC");
    }
    const Teuchos::ParameterList& ReducedDAirwayDynamicParams() const
    {
      return getParameterList()->sublist("REDUCED DIMENSIONAL AIRWAYS DYNAMIC");
    }
    const Teuchos::ParameterList& RedAirwayTissueDynamicParams() const
    {
      return getParameterList()->sublist("COUPLED REDUCED-D AIRWAYS AND TISSUE DYNAMIC");
    }
    const Teuchos::ParameterList& PoroelastDynamicParams() const
    {
      return getParameterList()->sublist("POROELASTICITY DYNAMIC");
    }
    const Teuchos::ParameterList& PoroFluidMultiPhaseDynamicParams() const
    {
      return getParameterList()->sublist("POROFLUIDMULTIPHASE DYNAMIC");
    }
    const Teuchos::ParameterList& PoroMultiPhaseScatraDynamicParams() const
    {
      return getParameterList()->sublist("POROMULTIPHASESCATRA DYNAMIC");
    }
    const Teuchos::ParameterList& PoroMultiPhaseDynamicParams() const
    {
      return getParameterList()->sublist("POROMULTIPHASE DYNAMIC");
    }
    const Teuchos::ParameterList& PoroScatraControlParams() const
    {
      return getParameterList()->sublist("POROSCATRA CONTROL");
    }
    const Teuchos::ParameterList& ElastoHydroDynamicParams() const
    {
      return getParameterList()->sublist("ELASTO HYDRO DYNAMIC");
    }
    const Teuchos::ParameterList& SSIControlParams() const
    {
      return getParameterList()->sublist("SSI CONTROL");
    }
    const Teuchos::ParameterList& SSTIControlParams() const
    {
      return getParameterList()->sublist("SSTI CONTROL");
    }
    const Teuchos::ParameterList& SearchtreeParams() const
    {
      return getParameterList()->sublist("SEARCH TREE");
    }
    const Teuchos::ParameterList& StructuralNoxParams() const
    {
      return getParameterList()->sublist("STRUCT NOX");
    }
    const Teuchos::ParameterList& LocaParams() const { return getParameterList()->sublist("LOCA"); }
    const Teuchos::ParameterList& ParticleParams() const
    {
      return getParameterList()->sublist("PARTICLE DYNAMIC");
    }
    const Teuchos::ParameterList& PASIDynamicParams() const
    {
      return getParameterList()->sublist("PASI DYNAMIC");
    }
    const Teuchos::ParameterList& LevelSetControl() const
    {
      return getParameterList()->sublist("LEVEL-SET CONTROL");
    }
    const Teuchos::ParameterList& WearParams() const { return getParameterList()->sublist("WEAR"); }
    const Teuchos::ParameterList& TSIContactParams() const
    {
      return getParameterList()->sublist("TSI CONTACT");
    }
    const Teuchos::ParameterList& BeamContactParams() const
    {
      return getParameterList()->sublist("BEAM CONTACT");
    }
    const Teuchos::ParameterList& BeamPotentialParams() const
    {
      return getParameterList()->sublist("BEAM POTENTIAL");
    }
    const Teuchos::ParameterList& SemiSmoothPlastParams() const
    {
      return getParameterList()->sublist("SEMI-SMOOTH PLASTICITY");
    }
    const Teuchos::ParameterList& ElectromagneticParams() const
    {
      return getParameterList()->sublist("ELECTROMAGNETIC DYNAMIC");
    }
    const Teuchos::ParameterList& VolmortarParams() const
    {
      return getParameterList()->sublist("VOLMORTAR COUPLING");
    }
    const Teuchos::ParameterList& TutorialParams() const
    {
      return getParameterList()()->sublist("TUTORIAL DYNAMIC");
    };
    const Teuchos::ParameterList& MORParams() const
    {
      return getParameterList()()->sublist("MOR");
    };
    const Teuchos::ParameterList& MeshPartitioningParams() const
    {
      return getParameterList()->sublist("MESH PARTITIONING");
    }

    const Teuchos::ParameterList& SolverParams(int solverNr) const;

    const Teuchos::ParameterList& UMFPACKSolverParams();

    //@}

    /// @name Discretizations

    /// get access to a particular discretization
    Teuchos::RCP<DRT::Discretization> GetDis(const std::string& name) const;

    /// tell number of known fields
    unsigned NumFields() const { return discretizationmap_.size(); }

    /// tell names of known fields
    std::vector<std::string> GetDisNames() const;

    /// check whether a certain discretization exists or not
    bool DoesExistDis(const std::string& name) const;

    /// add a discretization to the global problem
    void AddDis(const std::string& name, Teuchos::RCP<Discretization> dis);


    //@}

    /// @name Materials

    /// return pointer to materials bundled to the problem
    Teuchos::RCP<MAT::PAR::Bundle> Materials() { return materials_; }

    // return pointer to contact constitutive law bundled to the problem
    Teuchos::RCP<CONTACT::CONSTITUTIVELAW::Bundle> ContactConstitutiveLaws()
    {
      return contactconstitutivelaws_;
    }

    //@}

    /// @name Particles

    /// return reference to read in particles
    std::vector<std::shared_ptr<PARTICLEENGINE::ParticleObject>>& Particles() { return particles_; }

    //@}

    std::map<std::pair<std::string, std::string>, std::map<int, int>> CloningMaterialMap()
    {
      return clonefieldmatmap_;
    }

    /// @name Spatial Functions

    /**
     * Get a function read from the input file by its ID @p num.
     *
     * @tparam T The type of function interface.
     */
    template <typename T>
    T& FunctionById(int num)
    {
      return functionmanager_.template FunctionById<T>(num);
    }

    //@}

    /// @name Result Tests

    /// Do the testing
    void TestAll(const Epetra_Comm& comm) { resulttest_.TestAll(comm); }

    /// add field specific result test object
    void AddFieldTest(Teuchos::RCP<ResultTest> test) { resulttest_.AddFieldTest(test); }

    //@}

    /// Return the class that handles random numbers globally
    DRT::UTILS::Random* Random() { return &random_; }

    /// Return the class that handles restart initiating -> to be extended
    DRT::UTILS::RestartManager* RestartManager() { return &restartmanager_; }

   private:
    /// private default constructor to disallow creation of instances
    Problem();

    /// no copying
    Problem(const Problem&);

    /// no copying
    Problem& operator=(const Problem&);

    /// @name Private access to parameters from certain input file sections

    /// for internal use only! Use Restart(), SpatialApproximation() etc. instead !!!
    const Teuchos::ParameterList& ProblemTypeParams() const
    {
      return getParameterList()->sublist("PROBLEM TYP");
    }

    /// for internal use only! Use NDim() to access the number of space dimensions
    const Teuchos::ParameterList& ProblemSizeParams() const
    {
      return getParameterList()->sublist("PROBLEM SIZE");
    }
    //@}

    /// the single instance
    static std::vector<Problem*> instances_;

    /// the problem type
    ProblemType probtype_;

    /// Spatial approximation type
    ShapeFunctionType shapefuntype_;

    /// the restart step (given by command line or input file)
    int restartstep_;

    /// the restart time (given by command line or input file)
    double restarttime_;

    /// discretizations of this problem
    std::map<std::string, Teuchos::RCP<Discretization>> discretizationmap_;

    /// material bundle
    Teuchos::RCP<MAT::PAR::Bundle> materials_;

    /// bundle containing all read-in contact constitutive laws
    Teuchos::RCP<CONTACT::CONSTITUTIVELAW::Bundle> contactconstitutivelaws_;

    /// all particles that are read in
    std::vector<std::shared_ptr<PARTICLEENGINE::ParticleObject>> particles_;

    /// basket of spatial function
    DRT::UTILS::FunctionManager functionmanager_;

    /// all test values we might have
    DRT::ResultTestManager resulttest_;

    /// map of coupled fields and corresponding material IDs (needed for cloning
    /// of discretizations)
    std::map<std::pair<std::string, std::string>, std::map<int, int>> clonefieldmatmap_;

    /// communicators
    Teuchos::RCP<COMM_UTILS::Communicators> communicators_;

    /// @name File IO

    Teuchos::RCP<IO::InputControl> inputcontrol_;
    Teuchos::RCP<IO::OutputControl> outputcontrol_;
    Teuchos::RCP<IO::ErrorFileControl> errorfilecontrol_;  ///< error file handles

    //@}

    /// handles all sorts of random numbers
    DRT::UTILS::Random random_;

    /// handles restart
    DRT::UTILS::RestartManager restartmanager_;
  };

}  // namespace DRT

#endif
