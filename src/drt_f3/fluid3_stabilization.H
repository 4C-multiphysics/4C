/*----------------------------------------------------------------------*/
/*!
 * \file fluid3_stabilization.H
 *
 * \brief stabilization related, templated functions
 *
 * <pre>
 * Maintainer: Axel Gerstenberger
 *             gerstenberger@lnm.mw.tum.de
 *             http://www.lnm.mw.tum.de
 *             089 - 289-15236
 * </pre>
 */
/*----------------------------------------------------------------------*/

#ifdef D_FLUID3
#ifdef CCADISCRET

#ifndef FLUID3_STABILIZATION_H
#define FLUID3_STABILIZATION_H

#include "../drt_fem_general/drt_utils_fem_shapefunctions.H"
#include "../drt_fem_general/drt_utils_local_connectivity_matrices.H"
#include "../drt_fem_general/drt_utils_integration.H"
#include "../drt_lib/drt_element.H"
#include "../linalg/linalg_serialdensevector.H"
#include "../drt_lib/standardtypes_cpp.H"
#include "../drt_inpar/inpar_fluid.H"
#include "../drt_xfem/interfacexfsi.H"
#include "../drt_xfem/enrichment_utils.H"


namespace FLD
{
namespace UTILS
{
  //! for each distype there should be an m_k needed for stabilization computation
  template<DRT::Element::DiscretizationType DISTYPE>
  double MK()
  {
    switch (DISTYPE)
    {
      case DRT::Element::tet4:
      case DRT::Element::pyramid5:
      case DRT::Element::hex8:
      case DRT::Element::wedge6:
        return 0.333333333333333333333; // 1/3
        break;
      case DRT::Element::hex20:
      case DRT::Element::hex27:
      case DRT::Element::tet10:
      case DRT::Element::wedge15:
        return 0.083333333333333333333; // 1/12
        break;
      default:
        dserror("type unknown!\n");
    }
    return -1.0;
  }


  //! get one point gauss rule to calculate tau at element center
  template<DRT::Element::DiscretizationType DISTYPE>
  DRT::UTILS::GaussRule3D getIntegrationRuleForStabilization()
  {
    switch (DISTYPE)
    {
      case DRT::Element::hex8:
      case DRT::Element::hex20:
      case DRT::Element::hex27:
        return DRT::UTILS::intrule_hex_1point;
        break;
      case DRT::Element::tet4:
      case DRT::Element::tet10:
        return DRT::UTILS::intrule_tet_1point;
        break;
      case DRT::Element::wedge6:
      case DRT::Element::wedge15:
        return DRT::UTILS::intrule_wedge_1point;
        break;
      case DRT::Element::pyramid5:
        return DRT::UTILS::intrule_pyramid_1point;
        break;
      default:
        dserror("invalid discretization type for fluid3");
        return DRT::UTILS::intrule3D_undefined;
    }
  }


  //! calculate characteristic element size for stabilization
  template <class V>
  double Streamlength(
      const V&     shp_dx,
      const V&     shp_dy,
      const V&     shp_dz,
      const LINALG::Matrix<3,1>& gpvelnp,  /// velocity at Gaussian point
      const double               vel_norm, /// velocity norm
      const int                  numparamvelx
  )
  {
    // normed velocity at Gauss point
    LINALG::Matrix<3,1> velino;
    if (vel_norm >= 1e-6)
    {
      velino.Update(1.0/vel_norm,gpvelnp);
    }
    else
    {
      velino.Clear();
      velino(0) = 1.0;
    }

    // get streamlength
    //const double val = sum(abs(velino(j)*derxy(j,i)));
    LINALG::SerialDenseVector velinoder(numparamvelx,true);
    for (int iparam = 0; iparam < numparamvelx; ++iparam)
    {
      velinoder(iparam) += velino(0)*shp_dx(iparam);
      velinoder(iparam) += velino(1)*shp_dy(iparam);
      velinoder(iparam) += velino(2)*shp_dz(iparam);
    }
    // remark: "const double val = velinoder.Norm1();" ;
    double val = 0.0;
    for (int iparam = 0; iparam < numparamvelx; ++iparam)
      val += fabs(velinoder(iparam));

    if (val == 0.0) dserror("infinite stream length detected!");
    const double strle = 2.0/val;

    return strle;
  }


  //! calculate volume based on numerical integration
  template<DRT::Element::DiscretizationType DISTYPE, class M2>
  double VolumeViaNumIntegration(
      const M2&  xyze     ///< element nodal position array
  )
  {
    const int numnode = DRT::UTILS::DisTypeToNumNodePerEle<DISTYPE>::numNodePerElement;

    // use one point integration rule to calculate hk at element center
    const DRT::UTILS::GaussRule3D integrationrule_stabili = getIntegrationRuleForStabilization<DISTYPE>();

    // integration points
    const DRT::UTILS::IntegrationPoints3D intpoints(integrationrule_stabili);

    // shape functions and derivs at element center
    LINALG::Matrix<3,1> e;
    e(0) = intpoints.qxg[0][0];
    e(1) = intpoints.qxg[0][1];
    e(2) = intpoints.qxg[0][2];
    const double wquad = intpoints.qwgt[0];

    LINALG::Matrix<3,numnode> deriv;
    DRT::UTILS::shape_function_3D_deriv1(deriv, e(0), e(1), e(2), DISTYPE);

    // get Jacobian matrix and determinant
    // xjm_ = deriv_(i,k)*xyze(j,k);
    LINALG::Matrix<3,3> xjm;
    xjm.MultiplyNT(deriv,xyze);

    const double vol = wquad * xjm.Determinant();

    return vol;
  }

  //! calculate characteristic element size for stabilization
  template<DRT::Element::DiscretizationType DISTYPE, class M1, class M2>
  double HK(
      const M1&  evelnp,  ///< nodal velocity array
      const M2&  xyze     ///< element nodal position array
  )
  {
    const double vol = VolumeViaNumIntegration<DISTYPE>(xyze);

    // get element length for tau_Mp/tau_C: volume-equival. diameter/sqrt(3)
    const double hk = pow((6.*vol/M_PI),(1.0/3.0))/sqrt(3.0);

    return hk;
  }

  //! calculate characteristic element size for stabilization
  //!
  //! note: this works only for one-sided problems - two-sided problems
  //! like two-phase flow probably require 2 h_k as they represent 2 fluids
  template<DRT::Element::DiscretizationType DISTYPE, class M1, class M2>
  double HK_XFEM(
      const XFEM::InterfaceHandle&  ih,
      const DRT::Element*           xfemele,
      const M1&                     evelnp,  ///< nodal velocity array
      const M2&                     xyze     ///< element nodal position array
  )
  {
    const double vol = VolumeViaNumIntegration<DISTYPE>(xyze);

    const double phys_volumeratio = (1.0 - XFEM::DomainCoverageRatio(*xfemele,ih));

    const double reduced_vol = vol * phys_volumeratio;

    // get element length for tau_Mp/tau_C: volume-equival. diameter/sqrt(3)
    const double hk = pow((6.*reduced_vol/M_PI),(1.0/3.0))/sqrt(3.0);

    return hk;
  }


  void computeStabilizationParams(
      const LINALG::Matrix<3,1>& gpvelnp,  /// velocity at Gaussian point
      const LINALG::Matrix<3,3>& xji,      /// inverse of transposed Jacobian matrix
      const bool   instationary,
      const double dynvisc,                /// dyamic viscosity
      const double dens,                   /// density
      const double vel_norm,
      const double strle,
      const double hk,
      const double mk,
      const double timefac,
      const double dt,
      const enum INPAR::FLUID::TauType tautype,
      double& tau_stab_Mu,
      double& tau_stab_Mp,
      double& tau_stab_C
      );

  //! compute largest element diameter for Nitsche stabilization parameter
  template<DRT::Element::DiscretizationType DISTYPE, class M1>
  double getEleDiameter(const M1& xyze)
  {
    double elediam = 0.0;

    // number of nodes of this element
    const size_t numnode = DRT::UTILS::DisTypeToNumNodePerEle<DISTYPE>::numNodePerElement;

    // check all possible connections between nodes of an element
    // node 1 to 2
    //    :
    // node 1 to 8 = numnode
    // node 2 to 3
    //    :
    // node 2 to 8
    //    :
    //    :
    //    :
    // node 7 to 8
    for(size_t i_start=0; i_start< numnode-2; ++i_start)
    {
      for(size_t i_end= i_start+1; i_end < numnode-1; ++i_end)
      {
        LINALG::Matrix<3,1> direction;
        direction.Clear();
        direction(0) = xyze(0, i_start) - xyze(0, i_end);
        direction(1) = xyze(1, i_start) - xyze(1, i_end);
        direction(2) = xyze(2, i_start) - xyze(2, i_end);

        // update elediam
        if (direction.Norm2() > elediam) elediam=direction.Norm2();
      }
    }

    return elediam;
  }

} // namespace UTILS
} // namespace FLD

#endif

#endif
#endif
