#ifndef CUT_BOUNDARYCELL_H
#define CUT_BOUNDARYCELL_H

#include "cut_cycle.H"
#include "cut_element.H"

#include "../drt_fem_general/drt_utils_gausspoints.H"
#include "../drt_fem_general/drt_utils_integration.H"
#include "../drt_fem_general/drt_utils_boundary_integration.H"

#include <Teuchos_TimeMonitor.hpp>


namespace GEO
{
namespace CUT
{
  class Facet;
  class Element;
  class VolumeCell;
  class Mesh;
  class Point;

  /*!
  \brief Base class for boundary cells. Boundary cells are used to represent the cut surface. Each volume cell has its own boundary cells
   at any cut surface with outward normals.
 */
class BoundaryCell
{
public:

  BoundaryCell( const Epetra_SerialDenseMatrix & xyz, Facet * facet, const std::vector<Point*> & points )
    : xyz_( xyz ),
      facet_( facet ),
      points_( points )
  {
  }

  virtual ~BoundaryCell() {}

  /*!
  \brief Returns the shape of the boundarycell
   */

  virtual DRT::Element::DiscretizationType Shape() const = 0;

  /*!
  \brief Returns the cubature degree to generate quadrature rule for the cell
   */
  virtual int CubatureDegree( DRT::Element::DiscretizationType elementshape ) const = 0;

  /*!
  \brief Writes the geometry of boundarycell, and the constant scalar "value" in GMSH format
   */
  virtual void DumpGmsh( std::ofstream & file, int * value=NULL ) = 0;

  /*!
  \brief Returns the area of tri3 and quad4 boundarycell
   */
  virtual double Area() = 0;

  /*!
  \brief Returns the center of tri3 and quad4 boundarycell
   */
  virtual void ElementCenter(LINALG::Matrix<3,1> & midpoint) = 0;

  /*!
  \brief Get the outward normal vector for the tri3 and quad4 boundarycell
   */
  virtual void Normal( const LINALG::Matrix<2,1> & xsi, LINALG::Matrix<3,1> & normal ) const = 0;

  /*!
  \brief Get the corner points of the boundarycell in Cylce for geometrical operations
   */
  const Cycle & PointCycle() const { return points_; }

  /*!
  \brief Get the corner points of the boundarycell as vector of Points
   */
  const std::vector<Point*> & Points() const { return points_(); }

  /*!
  \brief Get the coodinates of the corner points of boundarycell
   */
  const Epetra_SerialDenseMatrix & Coordinates() const { return xyz_; }

  /*!
  \brief Get the Facet which represent the boundarycell
   */
  Facet * GetFacet() { return facet_; }

  /*!
  \brief Delete all the points of this boundarycell
   */
  void Clear() { points_.clear(); }

  bool IsValid() const { return points_.size() > 0; }

  /*!
  \brief Get the Gaussian integration rule for the boundarycell
   */
  virtual DRT::UTILS::GaussIntegration gaussRule()=0;

  /*!
  \brief Get the normal vector for the arbitrary boundarycell alone
   */
  virtual LINALG::Matrix<3,1> GetNormalVector()=0;

  /*!
  \brief Print the corner points on screen
   */
  void Print();

  /*!
  \brief Computes the location of Gauss points on the boundarycell (x_gp_lin) from the standard Gauss point location (eta)
  corresponding to the shape of the boundarycell. Also computes the factor to be multiplied with integration weight
  and normal vector of the boundarycell
   */
  template <DRT::Element::DiscretizationType celldistype>
  void Transform( const LINALG::Matrix<2,1> & eta,
                  LINALG::Matrix<3,1>       & x_gp_lin,
                  LINALG::Matrix<3,1>       & normal,
                  double                    & drs)
  {
      const int numnodes = DRT::UTILS::DisTypeToNumNodePerEle<celldistype>::numNodePerElement;
      LINALG::Matrix<3,numnodes> xyze( this->xyz_, true );

      LINALG::Matrix<numnodes,1> funct(false);
      LINALG::Matrix<2,numnodes> deriv(false);
      LINALG::Matrix<2,2> metrictensor(false);

      DRT::UTILS::shape_function_2D( funct, eta(0), eta(1), celldistype );
      DRT::UTILS::shape_function_2D_deriv1( deriv, eta(0), eta(1), celldistype );
      DRT::UTILS::ComputeMetricTensorForBoundaryEle<celldistype>( xyze, deriv, metrictensor, drs, &normal );

      x_gp_lin.Multiply(xyze, funct);

      return;
  }

  /*!
  \brief Compute the location of Gauss points on the background element's local coordinate system
  setting shadow = true means the mapping is done w.r. to the parent quad element from which elem1 is derived
   */
  template <DRT::Element::DiscretizationType celldistype>
  void TransformLocalCoords( Element * elem1,
                             const LINALG::Matrix<2,1> & eta,
                             LINALG::Matrix<3,1>       & x_gp_lin,
                             LINALG::Matrix<3,1>       & normal,
                             double                    & drs,
                             bool                      shadow = false )
  {
    //TEUCHOS_FUNC_TIME_MONITOR( "GEO::CUT::BoundaryCell::TransformLocalCoords" );


    const int numnodes = DRT::UTILS::DisTypeToNumNodePerEle<celldistype>::numNodePerElement;
    LINALG::Matrix<3,numnodes> xyzeGlo( this->xyz_, true ), xyze;

    for(int i=0;i<numnodes;i++)
    {
      LINALG::Matrix<3,1> glo (&xyzeGlo(0,i)),loc;

      // map w.r to linear shadow element
      if( not shadow )
      {
        elem1->LocalCoordinates(glo,loc);
      }
      // map w.r to parent quad element
      else
      {
        if( not elem1->isShadow() )
          elem1->LocalCoordinates(glo,loc);
        else
          elem1->LocalCoordinatesQuad( glo, loc );
      }
      xyze(0,i)=loc(0);xyze(1,i)=loc(1);xyze(2,i)=loc(2);
    }
    LINALG::Matrix<numnodes,1> funct;
    LINALG::Matrix<2,numnodes> deriv;
    LINALG::Matrix<2,2> metrictensor;

    DRT::UTILS::shape_function_2D( funct, eta(0), eta(1), celldistype );
    DRT::UTILS::shape_function_2D_deriv1( deriv, eta(0), eta(1), celldistype );
    DRT::UTILS::ComputeMetricTensorForBoundaryEle<celldistype>( xyze, deriv, metrictensor, drs, &normal );

    x_gp_lin.Multiply(xyze, funct);

    return;
  }

protected:

  virtual DRT::UTILS::GaussRule2D MySimpleGaussRule() = 0;

  template <DRT::Element::DiscretizationType distype>
  double MyArea()
  {
    const int numnodes = DRT::UTILS::DisTypeToNumNodePerEle<distype>::numNodePerElement;
    LINALG::Matrix<3,numnodes> xyze( this->xyz_, true );
    LINALG::Matrix<numnodes,1> funct;
    LINALG::Matrix<2,numnodes> deriv;
    LINALG::Matrix<2,2> metrictensor;

    DRT::UTILS::GaussRule2D gaussrule = this->MySimpleGaussRule();
    DRT::UTILS::IntegrationPoints2D intpoints( gaussrule );

    double area = 0;
    double drs;
    for ( int i=0; i<intpoints.nquad; ++i )
    {
      double * eta = intpoints.qxg[i];
      DRT::UTILS::shape_function_2D( funct, eta[0], eta[1], distype );
      DRT::UTILS::shape_function_2D_deriv1( deriv, eta[0], eta[1], distype );
      DRT::UTILS::ComputeMetricTensorForBoundaryEle<distype>( xyze, deriv, metrictensor, drs, NULL );
      if ( not std::isnan( drs ) )
        area += intpoints.qwgt[i] * drs;
    }
    return area;
  }

  /*-------------------------------------------------------------------------------------*
  | To calculate the element center of a boundary cell                   shahmiri 07/12
  *--------------------------------------------------------------------------------------*/
  template <DRT::Element::DiscretizationType distype>
  void MyElementCenter(LINALG::Matrix<3,1> & center, LINALG::Matrix<3,1> & midpoint)
  {
    const int numnodes = DRT::UTILS::DisTypeToNumNodePerEle<distype>::numNodePerElement;
    LINALG::Matrix<3,numnodes> xyze( this->xyz_, true );
    LINALG::Matrix<numnodes,1> funct;
    DRT::UTILS::shape_function_2D( funct, center(0,0), center(1,0), distype );
    midpoint.Multiply(xyze,funct);
  }

  Epetra_SerialDenseMatrix xyz_;
  Facet * facet_;
  Cycle points_;
};

/// tri3 boundary cell
class Tri3BoundaryCell : public BoundaryCell
{
public:

  Tri3BoundaryCell( const Epetra_SerialDenseMatrix & xyz, Facet * facet, const std::vector<Point*> & points )
    : BoundaryCell( xyz, facet, points )
  {
  }

  virtual DRT::Element::DiscretizationType Shape() const { return DRT::Element::tri3; }

  virtual int CubatureDegree( DRT::Element::DiscretizationType elementshape ) const { return 20; }

  virtual void DumpGmsh( std::ofstream & file, int * value=NULL );

  virtual double Area() { return MyArea<DRT::Element::tri3>(); }

  virtual void ElementCenter(LINALG::Matrix<3,1> & midpoint);

  virtual void Normal( const LINALG::Matrix<2,1> & pos, LINALG::Matrix<3,1> & normal ) const;

  virtual DRT::UTILS::GaussIntegration gaussRule();

  virtual LINALG::Matrix<3,1> GetNormalVector();

protected:

  virtual DRT::UTILS::GaussRule2D MySimpleGaussRule() { return DRT::UTILS::intrule_tri_3point; }
};

/// quad4 boundary cell
class Quad4BoundaryCell : public BoundaryCell
{
public:

  Quad4BoundaryCell( const Epetra_SerialDenseMatrix & xyz, Facet * facet, const std::vector<Point*> & points )
    : BoundaryCell( xyz, facet, points )
  {
  }

  virtual DRT::Element::DiscretizationType Shape() const { return DRT::Element::quad4; }

  virtual int CubatureDegree( DRT::Element::DiscretizationType elementshape ) const { return 20; }

  virtual void DumpGmsh( std::ofstream & file, int * value=NULL );

  virtual double Area() { return MyArea<DRT::Element::quad4>(); }

  virtual void ElementCenter(LINALG::Matrix<3,1> & midpoint);

  virtual void Normal( const LINALG::Matrix<2,1> & pos, LINALG::Matrix<3,1> & normal ) const;

  virtual DRT::UTILS::GaussIntegration gaussRule();

  virtual LINALG::Matrix<3,1> GetNormalVector();

protected:

  virtual DRT::UTILS::GaussRule2D MySimpleGaussRule() { return DRT::UTILS::intrule_quad_4point; }
};

/// Irregular boundary cell generated during the cut
class ArbitraryBoundaryCell : public BoundaryCell
{
public:

  ArbitraryBoundaryCell( const Epetra_SerialDenseMatrix & xyz, Facet * facet, const std::vector<Point*> & points,
      const DRT::UTILS::GaussIntegration& gaussRule, const LINALG::Matrix<3,1>& normal )
    : BoundaryCell( xyz, facet, points ),
      gaussRule_(gaussRule),
      normal_(normal)
  {
  }

  virtual DRT::Element::DiscretizationType Shape() const { return DRT::Element::dis_none; }

  virtual int CubatureDegree( DRT::Element::DiscretizationType elementshape ) const {  return 0; }

  virtual void DumpGmsh( std::ofstream & file, int * value=NULL );

  virtual double Area() { return 0.0;}

  virtual void ElementCenter(LINALG::Matrix<3,1> & midpoint);

  virtual void Normal( const LINALG::Matrix<2,1> & pos, LINALG::Matrix<3,1> & normal ) const;

  virtual DRT::UTILS::GaussIntegration gaussRule();

  virtual LINALG::Matrix<3,1> GetNormalVector();

protected:

  virtual DRT::UTILS::GaussRule2D MySimpleGaussRule() { return DRT::UTILS::intrule_quad_4point; }
private:
  DRT::UTILS::GaussIntegration gaussRule_;
  LINALG::Matrix<3,1> normal_;

};

}
}

#endif
