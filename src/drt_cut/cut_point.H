#ifndef CUT_POINT_H
#define CUT_POINT_H

#include <fstream>

#include <map>

#include <Teuchos_RCP.hpp>

#include "../linalg/linalg_fixedsizematrix.H"

#include "cut_utils.H"

namespace GEO
{
namespace CUT
{

namespace IMPL
{

class PointLineFilter
{
public:

  virtual ~PointLineFilter() {}

  virtual bool operator()( Line * line ) const = 0;
};

}

/// Points in a mesh. Both nodal points and cut points.
/*!
 * A point knows its position with respect to the cut interface.
 */
class Point
{
public:

  enum PointPosition
  {
    undecided,
    oncutsurface = -1,
    inside = -2,
    outside = -3
  };

  static Point * NewPoint( Mesh & mesh, const double * x, double t, Edge * cut_edge, Side * cut_side );

  static Point * InsertCut( Edge * cut_edge, Side * cut_side, Node * n );

  Point( unsigned pid, const double * x, Edge * cut_edge, Side * cut_side );

  int Id() const { return pid_; }

  const double * X() const { return x_; }

  PointPosition Position() const { return position_; }

  void Position( PointPosition p );

  /*!
  \brief Add this edge to the list of edges that are cut by this point
   */
  void AddEdge( Edge* e );

  /*!
  \brief Add this side to the list of sides that are cut by this point
   */
  void AddSide( Side* s );

  /*!
  \brief Add this element to the list of elements that are cut by this point
   */
  void AddElement( Element* e ) { if ( e!=NULL ) { cut_elements_.insert( e ); } }

  /*!
  \brief Returns true if the edge is cut by this point
   */
  bool IsCut( Edge* e )
  {
    return cut_edges_.count( e )>0;
  }

  /*!
   \brief Returns true if the facet is cut by this point
    */
  bool IsCut( Facet* f )
  {
    return facets_.count( f )>0;
  }

  /*!
  \brief Returns true if the side is cut by this point
   */
  bool IsCut( Side* s )
  {
    return cut_sides_.count( s )>0;
  }

  /*!
  \brief Returns true if this point cuts the element
  */
  bool IsCut( Element* s )
  {
    return cut_elements_.count( s )>0;
  }

  /*!
  \brief Get the coordinates of this point
   */
  void Coordinates( double * x )
  {
    std::copy( x_, x_+3, x );
  }

  void Register( Line * line )
  {
    lines_.insert( line );
  }

  void Register( Facet * facet )
  {
    facets_.insert( facet );
  }

  void CommonEdge( Point * other, plain_edge_set & edges );

  void CommonSide( Point * other, plain_side_set & sides );

  Line * CommonLine( Point * other );

  Line * CutLine( Side * side, bool unique=true );

  Line * CutLine( Line * line, Side * side, Element * element );

  Line * CutLine( const IMPL::PointLineFilter & filter, bool unique=true );

  Line * CutLine( Line * line, const IMPL::PointLineFilter & filter, bool unique=true );

  void CutLines( const IMPL::PointLineFilter & filter, plain_line_set & cut_lines );

  void CutLines( Side * side, plain_line_set & cut_lines );

  //std::vector<Edge*> CutEdges( Point * other );

  const plain_edge_set & CutEdges() { return cut_edges_; }

  const plain_side_set & CutSides() { return cut_sides_; }

  Side * CutSide( Side * side, Point * other );

  void CutEdge( Side * side, Line * other_line, std::vector<Edge*> & matches );

  void Print( std::ostream & stream=std::cout )
  {
    stream << "("
           << pid_ << "; "
           << std::setprecision( 16 ) << x_[0] << ","
           << std::setprecision( 16 ) << x_[1] << ","
           << std::setprecision( 16 ) << x_[2] << ")";
  }

  void Plot( std::ostream & f )
  {
    f << std::setprecision( 10 ) << x_[0] << " "
      << std::setprecision( 10 ) << x_[1] << " "
      << std::setprecision( 10 ) << x_[2] << " # "
      << pid_;
    DumpDoubles( f, X(), 3 );
    f << "\n";
  }

  double t( Edge* edge );

  //void t( Edge* edge, double pos ) { t_[edge] = pos; }

  unsigned Pid() const { return pid_; }

  bool NodalPoint( const std::vector<Node*> & nodes ) const;

  Node * CutNode();

  void Intersection( plain_edge_set & edges );

  void Intersection( plain_side_set & sides );

  void Intersection( plain_facet_set & facets );

  const plain_element_set & Elements() const { return cut_elements_; }

  const plain_facet_set & Facets() const { return facets_; }

  Edge * CommonCutEdge( Side * side );

private:

  // find the unique line that matches the filter criteria
  template <class Filter>
  Line * Find( Filter & filter, bool unique=true );

  template <class Filter>
  void Find( Filter & filter, plain_line_set & cut_lines );

  unsigned pid_;
  PointPosition position_;

  double x_[3];
  std::map<Edge*, double> t_;

  plain_edge_set cut_edges_;
  plain_side_set cut_sides_;
  plain_element_set cut_elements_;

  plain_line_set lines_;
  plain_facet_set facets_;
};

inline std::ostream & operator<<( std::ostream & stream, Point & point )
{
  point.Print( stream );
  return stream;
}

inline std::ostream & operator<<( std::ostream & stream, Point * point )
{
  point->Print( stream );
  return stream;
}

inline int EntityId( const Point & p ) { return p.Pid(); }

/// id based comparison for sorting and searching
template <class T>
class EntityIdLess
{
public:

  bool operator()( const T& p1, const T& p2 ) const
  {
    return EntityId( p1 ) < EntityId( p2 );
  }

  bool operator()( const T* p1, const T* p2 ) const
  {
    return EntityId( *p1 ) < EntityId( *p2 );
  }

  bool operator()( const Teuchos::RCP<T> p1, const Teuchos::RCP<T> p2 ) const
  {
    return EntityId( *p1 ) < EntityId( *p2 );
  }

};

typedef EntityIdLess<Point> PointPidLess;

/// position on edge based comparison for sorting and searching
class PointPositionLess
{
public:

  explicit PointPositionLess( Edge* edge ) : edge_( edge ) {}

  bool operator()( Point& p1, Point& p2 ) const
  {
    if ( not p1.IsCut( edge_ ) or not p2.IsCut( edge_ ) )
      throw std::runtime_error( "point position compare only on cut edges" );
    return p1.t( edge_ ) < p2.t( edge_ );
  }

  bool operator()( Point* p1, Point* p2 ) const
  {
    if ( not p1->IsCut( edge_ ) or not p2->IsCut( edge_ ) )
      throw std::runtime_error( "point position compare only on cut edges" );
    return p1->t( edge_ ) < p2->t( edge_ );
  }

private:
  Edge* edge_;
};

#ifdef CUT_USE_SORTED_VECTOR
typedef sorted_vector<Point*, true, PointPidLess> PointSet;
typedef sorted_vector<Point*, true, PointPositionLess> PointPositionSet;

typedef sorted_vector<Teuchos::RCP<Point>, true, PointPidLess> RCPPointSet;

#else
typedef std::set<Point*, PointPidLess> PointSet;
typedef std::set<Point*, PointPositionLess> PointPositionSet;

typedef std::set<Teuchos::RCP<Point>, PointPidLess> RCPPointSet;

#endif

namespace IMPL
{

class ExcludeLineFilter : public PointLineFilter
{
public:

  ExcludeLineFilter( Line * line, const PointLineFilter & filter )
    : line_( line ),
      filter_( filter )
  {
  }

  virtual bool operator()( Line * line ) const
  {
    return line!=line_ and filter_( line );
  }

private:
  Line * line_;
  const PointLineFilter & filter_;
};

class SideCutFilter : public PointLineFilter
{
public:

  SideCutFilter( Side * side )
    : side_( side )
  {
  }

  virtual bool operator()( Line * line ) const;

private:
  Side * side_;
};

class SideElementCutFilter : public PointLineFilter
{
public:

  SideElementCutFilter( Side * side, Element * element )
    : side_( side ),
      element_( element )
  {
  }

  virtual bool operator()( Line * line ) const;

private:
  Side * side_;
  Element * element_;
};

class SideSideCutFilter : public PointLineFilter
{
public:

  SideSideCutFilter( Side * side1, Side * side2 )
    : side1_( side1 ),
      side2_( side2 )
  {
  }

  virtual bool operator()( Line * line ) const;

private:
  Side * side1_;
  Side * side2_;
};

}

inline void FindCommonSides( const std::vector<Point*> & side, plain_side_set & sides )
{
  std::vector<Point*>::const_iterator is = side.begin();
  sides = ( *is )->CutSides();
  for ( ++is; is!=side.end(); ++is )
  {
    Point * p = *is;
    p->Intersection( sides );
    if ( sides.size()==0 )
    {
      break;
    }
  }
}

inline void FindCommonSides( Point * p1, Point * p2, Point * p3, plain_side_set & sides )
{
  sides = p1->CutSides();
  p2->Intersection( sides );
  p3->Intersection( sides );
}

inline void FindCommonSides( Point * p1, Point * p2, Point * p3, Point * p4, plain_side_set & sides )
{
  sides = p1->CutSides();
  p2->Intersection( sides );
  p3->Intersection( sides );
  p4->Intersection( sides );
}

}
}

#endif
