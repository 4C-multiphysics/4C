/*----------------------------------------------------------------------*/
/*!
\file fsi_algorithm.H

\brief Basis of all FSI algorithms

<pre>
Maintainer: Ulrich Kuettler
            kuettler@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15238
</pre>
*/
/*----------------------------------------------------------------------*/

#ifdef CCADISCRET

#ifndef FSI_ALGORITHM_H
#define FSI_ALGORITHM_H

#include <Epetra_Comm.h>

#include <Teuchos_RCP.hpp>
#include <Teuchos_ParameterList.hpp>

#include "../drt_adapter/FSIStructureWrapper.H"
#include "../drt_adapter/adapter_fluid_ale.H"
#include "../drt_adapter/adapter_algorithmbase.H"


namespace FSI
{

  /// FSI algorithm base
  /*!

    Base class of FSI algorithms with generalized fluid field. There can (and
    will) be different subclasses that implement different coupling schemes.

    \note The generalized fluid field hides any ale or xfem handling of the
    variable fluid domain. This is the appropriate base class if direct access
    to ale or xfem is not required. If a coupling algorithm needs an ale
    field, MonolithicBase is the better choice for a base class.

    \warning The order of calling the three BaseAlgorithm-constructors (that
    is the order in which we list the base classes) is important here! In the
    constructors control file entries are written. And these entries define
    the order in which the filters handle the Discretizations, which in turn
    defines the dof number ordering of the Discretizations... Don't get
    confused. Just always list structure, fluid, ale. In that order.

    \author u.kue
    \date 02/08
   */
  class Algorithm : public ADAPTER::AlgorithmBase
  {
  public:

    /// create using a Epetra_Comm
    explicit Algorithm(const Epetra_Comm& comm);

    /// virtual destructor to support polymorph destruction
    virtual ~Algorithm();

    /// access to structure field
    ADAPTER::FSIStructureWrapper& StructureField(){return *structure_;}

    /// access to fluid field
    ADAPTER::FluidMovingBoundary& MBFluidField(){return *fluid_;}

    /// read restart data
    virtual void ReadRestart(int step);

  protected:

    //! @name Time loop building blocks

    /// start a new time step
    virtual void PrepareTimeStep();

    /// take current results for converged and save for next time step
    virtual void Update();

    /// calculate stresses, strains, energies
    virtual void PrepareOutput()
    {
      StructureField().PrepareOutput();
    }

    /// write output
    virtual void Output();

    //@}

    //! @name Transfer helpers

    //virtual Teuchos::RCP<Epetra_Vector> StructToAle(Teuchos::RCP<Epetra_Vector> iv) const;
    //virtual Teuchos::RCP<Epetra_Vector> AleToStruct(Teuchos::RCP<Epetra_Vector> iv) const;
    virtual Teuchos::RCP<Epetra_Vector> StructToFluid(Teuchos::RCP<Epetra_Vector> iv) const;
    virtual Teuchos::RCP<Epetra_Vector> FluidToStruct(Teuchos::RCP<Epetra_Vector> iv) const;

    //virtual Teuchos::RCP<Epetra_Vector> StructToAle(Teuchos::RCP<const Epetra_Vector> iv) const;
    //virtual Teuchos::RCP<Epetra_Vector> AleToStruct(Teuchos::RCP<const Epetra_Vector> iv) const;
    virtual Teuchos::RCP<Epetra_Vector> StructToFluid(Teuchos::RCP<const Epetra_Vector> iv) const;
    virtual Teuchos::RCP<Epetra_Vector> FluidToStruct(Teuchos::RCP<const Epetra_Vector> iv) const;

    //@}

    ADAPTER::Coupling& StructureFluidCoupling();
    const ADAPTER::Coupling& StructureFluidCoupling() const;

    /// underlying structure of the FSI problem
    Teuchos::RCP< ::ADAPTER::FSIStructureWrapper>    structure_;

    /// underlying fluid of the FSI problem
    Teuchos::RCP< ::ADAPTER::FluidMovingBoundary>    fluid_;

  private:

    /// coupling of structure and fluid at the interface
    Teuchos::RCP<ADAPTER::Coupling>               coupsf_;
  };
}

#endif
#endif
