/*----------------------------------------------------------------------*/
/*!
\file strtimint.H
\brief Time integration for structural dynamics

<pre>
Maintainer: Thomas Kl√∂ppel
            kloeppel@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15257
</pre>
*/

/*----------------------------------------------------------------------*/
/* definitions */
#ifndef STRTIMINT_H
#define STRTIMINT_H

/*----------------------------------------------------------------------*/
/* headers */
#include <string>
#include <iostream>
#include <fstream>

#include <Teuchos_RefCountPtr.hpp>
#include <Teuchos_ParameterList.hpp>
#include <Teuchos_StandardParameterEntryValidators.hpp>
#include <Epetra_Vector.h>
#include <Epetra_Operator.h>
#include <Epetra_RowMatrix.h>
#include <Epetra_Time.h>
#include <NOX.H>
#include <NOX_Epetra.H>
#include <ml_common.h>
#include <ml_include.h>
#include <nlnml_preconditioner.H>
#include <nlnml_linearsystem.H>
#include <nlnml_finelevelnoxinterface.H>

#include "../drt_adapter/adapter_structure.H"
#include "strtimint_mstep.H"
#include "../drt_inpar/inpar_structure.H"
#include "../drt_structure/stru_aux.H"


// forward declarations
namespace DRT
{
  class Discretization;

  namespace UTILS
  {
    class LocsysManager;
  }
}

namespace UTILS
{
  class ConstrManager;
  class ConstraintSolver;
  class SurfStressManager;
}

namespace MORTAR
{
  class ManagerBase;
}

namespace CONTACT
{
  class Beam3cmanager;
}

namespace POTENTIAL
{
  class PotentialManager;
}

namespace LINALG
{
  class Solver;
  class MapExtractor;
  class SparseMatrix;
  class SparseOperator;
  class BlockSparseMatrixBase;
}

namespace IO
{
  class DiscretizationWriter;
}


/*----------------------------------------------------------------------*/
//! Structural Dynamics
namespace STR
{

  /*====================================================================*/
  /*!
   * \brief Front-end for structural dynamics by integrating in time.
   *
   * <h3> Intention </h3>
   * This front-end for structural dynamics defines an interface to call
   * several derived time integrators. Thus it describes a plethora of pure
   * virtual methods which have to be implemented at the derived integrators.
   * However, it also offers a few non-empty methods and stores associated
   * data. The most important method of this base time integrator object
   * is #Integrate().
   *
   * #Integrate() performs a time integration (time loop) with constant
   * time steps and other parameters as set by the user.
   *
   * Although #Integrate is the main interface, this base time integrator
   * allows the public to access a few of its datum objects, for instance
   * the tangent system matrix #stiff_ by #SystemMatrix(). This selective access
   * is needed in environments in which a independent time loop is provided.
   * This happens e.g. in fluid-structure-interaction.
   *
   * <h3> Responsibilties </h3>
   * Most importantly the base integrator manages the system state vectors and
   * matrices. It also deals with the output to files and offers method to
   * determine forces and stiffnesses (tangents).
   *
   * \author bborn
   * \date 06/08
   */
  class TimInt : public ::ADAPTER::Structure
  {

    //! Structural time adaptivity is friend
    friend class TimAda;

    //! Joint auxiliar schemes are friends
    template <typename T> friend class TimAdaJoint;

  public:

    //! @name Life
    //@{

    //! Print tea time logo
    void Logo();

    //! Constructor
    TimInt
    (
      const Teuchos::ParameterList& ioparams,  //!< ioflags
      const Teuchos::ParameterList& sdynparams,  //!< input parameters
      const Teuchos::ParameterList& xparams,  //!< extra flags
      Teuchos::RCP<DRT::Discretization> actdis,  //!< current discretisation
      Teuchos::RCP<LINALG::Solver> solver,  //!< the solver
      Teuchos::RCP<LINALG::Solver> contactsolver,  //!< the solver for contact/meshtying
      Teuchos::RCP<IO::DiscretizationWriter> output  //!< the output
    );

    //! Destructor
    virtual ~TimInt()
    {
      DetachEnergyFile();
    }

    //! Empty constructor
    TimInt() { ; }

    //! Copy constructor
    TimInt(const TimInt& old) { ; }

    //! Resize #TimIntMStep<T> multi-step quantities
    virtual void ResizeMStep() = 0;

    //! Merge
    //!
    //! Merge basically duplicates the base object content of time
    //! integrator #tis onto the time integrator #this. This is like
    //! a copy, but a copy constructor is not permitted, because
    //! #TimInt is pure virtual.
    //! Usually this is not wanted when copying, but here it is
    //! highly appreciated. #TimInt contains only pointers (of the
    //! RefCount type) and can thus link -- or merge -- the data
    //! of #tis with #this. Practically, this turns up with time
    //! adaptivity in which #tis is the marching integrator
    //! and #this is the auxiliar method, which shares the marching data.
    void Merge
    (
      TimInt& tis  //!< existing integrator to merge against
    )
    {
      // copy it
      *this = tis;
      // A slice of lemon?
      return;
    }

    //@}

    //! @name Actions
    //@{

    //! Equilibrate the initial state by identifying the consistent
    //! initial accelerations and (if applicable) internal variables
    //! Make damping and mass matrix
    void DetermineMassDampConsistAccel();

    //! Apply Dirichlet boundary conditions on provided state vectors
    void ApplyDirichletBC
    (
      const double time,  //!< at time
      Teuchos::RCP<Epetra_Vector> dis,  //!< displacements
                                        //!< (may be Teuchos::null)
      Teuchos::RCP<Epetra_Vector> vel,  //!< velocities
                                        //!< (may be Teuchos::null)
      Teuchos::RCP<Epetra_Vector> acc,  //!< accelerations
                                       //!< (may be Teuchos::null)
      bool recreatemap  //!< recreate mapextractor/toggle-vector
                        //!< which stores the DOF IDs subjected
                        //!< to Dirichlet BCs
                        //!< This needs to be true if the bounded DOFs
                        //!< have been changed.
    );

    //! Do time integration of multiple steps
    void Integrate();

    //! Do time integration of single step
    virtual void IntegrateStep() = 0;

    //! Update configuration after time step
    //!
    //! Thus the 'last' converged is lost and a reset of the time step
    //! becomes impossible. We are ready and keen awating the next
    //! time step.
    virtual void UpdateStepState() = 0;

    //! Update everything on element level after time step and after output
    //!
    //! Thus the 'last' converged is lost and a reset of the time step
    //! becomes impossible. We are ready and keen awating the next
    //! time step.
    virtual void UpdateStepElement() = 0;

    //! Update time and step counter
    void UpdateStepTime();

    //! Update step for contact / meshtying
    void UpdateStepContactMeshtying();

    //! Update step for beam contact
    void UpdateStepBeamContact();

    //! Reset configuration after time step
    //!
    //! Thus the last converged state is copied back on the predictor
    //! for current time step. This applies only to elemet-wise
    //! quantities
    void ResetStep();

    //! Set initial fields in structure (e.g. initial velocities)
    void SetInitialFields();

    //@}

    //! @name Determination of output quantities that depend on
    // the constitutive model
    //@{
    //! Calculate all output quantities depending on the constitutive model
    //  (and, hence, on a potential material history)
    void PrepareOutput();

    //! Calculate stresses, strains on micro-scale
    void PrepareOutputMicro();

    //! Calculate stresses and strains
    void DetermineStressStrain();

    //! Calculate kinetic, internal and external energy
    void DetermineEnergy();

    //@}


    //! @name Output
    //@{

    //! print summary after step
    virtual void PrintStep() = 0;

    //! Output to file
    //! This routine always prints the last converged state, i.e.
    //! \f$D_{n}, V_{n}, A_{n}\f$. So, #UpdateIncrement should be called
    //! upon object prior to writing stuff here.
    //! \author mwgee (originally) \date 03/07
    void OutputStep();

    //! Write restart
    //! \author mwgee (originally) \date 03/07
    void OutputRestart
    (
      bool& datawritten  //!< (in/out) read and append if
                         //!< it was written at this time step
    );

    //! Output displacements, velocities and accelerations
    //! and more system vectors
    //! \author mwgee (originally) \date 03/07
    void OutputState
    (
      bool& datawritten  //!< (in/out) read and append if
                         //!< it was written at this time step
    );

    //! Stress & strain output
    //! \author lw (originally)
    void OutputStressStrain
    (
      bool& datawritten  //!< (in/out) read and append if
                         //!< it was written at this time step
    );

    //! Energy output
    void OutputEnergy();

    //! Active set, energy and momentum output for contact
    void OutputContact();

    //! Error norm output
    void OutputErrorNorms();

    //! Nodal positions output
    void OutputNodalPositions();

    //! Output on the micro-scale (multi-scale analysis)
    void OutputMicro();

    //! Patient Specific Output
    void OutputPatspec();

    //! Check wether energy output file is attached
    bool AttachedEnergyFile()
    {
      if (energyfile_) return true;
      else return false;
    }

    //! Attach file handle for energy file #energyfile_
    void AttachEnergyFile();

    //! Detach file handle for energy file #energyfile_
    void DetachEnergyFile()
    {
      if (energyfile_) delete energyfile_;
    }

    //@}

    //! @name Forces and Stiffnesses
    //@{

    //! Apply external force
    void ApplyForceExternal
    (
      const double time,  //!< evaluation time
      const Teuchos::RCP<Epetra_Vector> dis,  //!< displacement state
      const Teuchos::RCP<Epetra_Vector> vel,  // velocity state
      Teuchos::RCP<Epetra_Vector>& fext  //!< external force
    );

    //! Evaluate ordinary internal force, its stiffness at state
    void ApplyForceStiffInternal
    (
      const double time,  //!< evaluation time
      const double dt,  //!< step size
      const Teuchos::RCP<Epetra_Vector> dis,  //!< displacement state
      const Teuchos::RCP<Epetra_Vector> disi,  //!< residual displacements
      const Teuchos::RCP<Epetra_Vector> vel,  // velocity state
      Teuchos::RCP<Epetra_Vector> fint,  //!< internal force
      Teuchos::RCP<LINALG::SparseOperator> stiff  //!< stiffness matrix
    );

    //! Evaluate ordinary internal force, its stiffness at state
    void PoroApplyForceStiffInternal
    (
      const double time,  //!< evaluation time
      const double dt,  //!< step size
      const Teuchos::RCP<Epetra_Vector> dis,  //!< displacement state
      const Teuchos::RCP<Epetra_Vector> disi,  //!< residual displacements
      const Teuchos::RCP<Epetra_Vector> vel,  // velocity state
      Teuchos::RCP<Epetra_Vector> fint,  //!< internal force
      Teuchos::RCP<LINALG::SparseOperator> stiff,  //!< stiffness matrix
      Teuchos::RCP<LINALG::SparseOperator> stiff_rea // reacitve part of stiffness matrix
    );

    //! Evaluate ordinary internal force
    //!
    //! We need incremental displacements, because the internal variables,
    //! chiefly EAS parameters with an algebraic constraint, are treated
    //! as well. They are not treated perfectly, ie they are not iteratively
    //! equilibriated according to their (non-linear) constraint and
    //! the pre-determined displacements -- we talk explicit time integration
    //! here, but they are applied in linearised manner. The linearised
    //! manner means the static condensation is applied once with
    //! residual displacements replaced by the full-step displacement
    //! increment \f$D_{n+1}-D_{n}\f$.
    void ApplyForceInternal
    (
      const double time,  //!< evaluation time
      const double dt,  //!< step size
      const Teuchos::RCP<Epetra_Vector> dis,  //!< displacement state
      const Teuchos::RCP<Epetra_Vector> disi,  //!< incremental displacements
      const Teuchos::RCP<Epetra_Vector> vel,  // velocity state
      Teuchos::RCP<Epetra_Vector> fint  //!< internal force
    );

    //@}

    //! @name Thermo-structure-interaction specific methods
    //@{
    //! Apply the current temperatures to the structure problem
    void ApplyTemperatures
    (
      Teuchos::RCP<const Epetra_Vector> temp  //!< current temperatures
    );
    //@}

    void ApplyVelAndPress
    (
      Teuchos::RCP<const Epetra_Vector> veln  //!< current velocities and pressures
    );

    //! Set forces due to interface with fluid, the force is expected external-force-like
    virtual void SetForceInterface
    (
      Teuchos::RCP<Epetra_Vector> iforce  ///< the force on interface
    );

    //! @name Attributes
    //@{

    //! Provide Name
    virtual enum INPAR::STR::DynamicType MethodName() const = 0;

    //! Provide title
    std::string MethodTitle() const
    {
      return INPAR::STR::DynamicTypeString(MethodName());
    }

    //! Return true, if time integrator is implicit
    virtual bool MethodImplicit() = 0;

    //! Return true, if time integrator is explicit
    bool MethodExplicit() { return (not MethodImplicit()); }

    //! Provide number of steps, e.g. a single-step method returns 1,
    //! a \f$m\f$-multistep method returns \f$m\f$
    virtual int MethodSteps() = 0;

    //! return time integration factor
    virtual double TimIntParam() = 0;

    //! Give order of accuracy
    int MethodOrderOfAccuracy()
    {
      return min(MethodOrderOfAccuracyDis(), MethodOrderOfAccuracyVel());
    }

    //! Give local order of accuracy of displacement part
    virtual int MethodOrderOfAccuracyDis() = 0;

    //! Give local order of accuracy of velocity part
    virtual int MethodOrderOfAccuracyVel() = 0;

    //! Return linear error coefficient of displacements
    virtual double MethodLinErrCoeffDis() = 0;

    //! Return linear error coefficient of velocities
    virtual double MethodLinErrCoeffVel() = 0;

    //@}

    //! @name Access methods
    //@{

    //! Access dicretisation
    Teuchos::RCP<DRT::Discretization> Discretization()
    {
      // Here a 'false' must be used. This is due to
      // the fact that TimInt possesses a references
      // on the discretisation #discret_ and not
      // a Teuchos::RefCountPointer. Eventually, TimInt
      // will be destroyed and it will immediately destroy
      // its #discret_ member. However, #discret_ is handed down
      // to the ConstrManager and kept there as a RefCountPointer.
      // The object #discret_ is gone, when ConstrManager tries
      // to kill it. We achieve a nice segmentation fault.
      // The 'false' prevents ConstrManager of trying to kill it.
      //return Teuchos::rcp(&discret_, false);

      // Now, the discretisation is stored as Teuchos::RefCountPointer,
      // thus
      return discret_;
    }

    //! Access solver, one of these have to be removed (see below)
    Teuchos::RCP<LINALG::Solver> Solver()
    {
      return solver_;
    }

    //! Access solver, one of these have to be removed (see above)
    Teuchos::RCP<LINALG::Solver> LinearSolver()
    {
      return solver_;
    }

    //! Access output object
    Teuchos::RCP<IO::DiscretizationWriter> DiscWriter()
    {
      return output_;
    }

    //! Read restart values
    void ReadRestart
    (
      const int step //!< restart step
    );

    //! Read and set restart state
    void ReadRestartState();

    //! Read and set restart forces
    virtual void ReadRestartForce() = 0;

    //! Read and set restart values for constraints
    void ReadRestartConstraint();

    //! Read and set restart values for contact / meshtying
    void ReadRestartContactMeshtying();

    //! Read and set restart values for surface stresses
    void ReadRestartSurfstress();

    //! Read and set restart values for multi scale materials
    void ReadRestartMultiScale();

    //! Return displacements \f$D_{n}\f$
    Teuchos::RCP<Epetra_Vector> Dis() { return (*dis_)(0); }

    //! Return displacements \f$D_{n+1}\f$
    Teuchos::RCP<Epetra_Vector> DisNew() { return disn_; }

    //! Return velocities \f$V_{n}\f$
    Teuchos::RCP<Epetra_Vector> Vel() { return (*vel_)(0); }

    //! Return velocities \f$V_{n+1}\f$
    Teuchos::RCP<Epetra_Vector> VelNew() { return veln_; }

    //! Return velocities \f$V_{n+1-a_f}\f$
    virtual Teuchos::RCP<Epetra_Vector> Velaf() = 0;

    //! Return accelerations \f$A_{n}\f$
    Teuchos::RCP<Epetra_Vector> Acc() { return (*acc_)(0); }

    //! Return accelerations \f$A_{n+1}\f$
    Teuchos::RCP<Epetra_Vector> AccNew() { return accn_; }

    //! Return external force \f$F_{ext,n}\f$
    virtual Teuchos::RCP<Epetra_Vector> Fext() = 0;

    //! Return external force \f$F_{ext,n+1}\f$
    virtual Teuchos::RCP<Epetra_Vector> FextNew() = 0;

    //! Return reaction forces
    virtual Teuchos::RCP<Epetra_Vector> Freact() = 0;

    //! Return stiffness,
    //! i.e. force residual differentiated by displacements
    Teuchos::RCP<LINALG::SparseMatrix> SystemMatrix();

    //! Return stiffness,
    //! i.e. force residual differentiated by displacements
    Teuchos::RCP<LINALG::BlockSparseMatrixBase> BlockSystemMatrix();

    //! switch structure field to block matrix in fsi simulations
    virtual void UseBlockMatrix(const LINALG::MultiMapExtractor& domainmaps,
        const LINALG::MultiMapExtractor& rangemaps) = 0;

    //! Return sparse mass matrix
    Teuchos::RCP<LINALG::SparseMatrix> MassMatrix();

    //! Return domain map of mass matrix
    const Epetra_Map& GetDomainMap();

    //! Return current step number map
    double GetTime() const { return (*time_)[0]; }

    //! Sets the current time needed for the inverse analysis
    void SetTime(double time) const { (*time_)[0]=time; }

    //! Get upper limit of time range of interest
    double GetTimeEnd() const { return timemax_; }

    //! Get time step size \f$\Delta t_n\f$
    double GetTimeStepSize() const { return (*dt_)[0]; }

    //! Set time step size \f$\Delta t_n\f$
    void SetTimeStepSize(double timestepsize) { (*dt_)[0] = timestepsize; }

    //! Set time step size and time in the first step \f$\Delta t_n\f$
    void SetInitialTimeStepAndTime(double timestepsize) { (*dt_)[0] = timestepsize; timen_ = (*time_)[0] + (*dt_)[0]; }

    //! Return current step number map
    int GetStep() const { return step_; }

    //! Get number of time steps
    int GetTimeNumStep() const { return stepmax_; }


    //! Return MapExtractor for Dirichlet boundary conditions
    const Teuchos::RCP<const LINALG::MapExtractor> GetDBCMapExtractor()
    {
      return dbcmaps_;
    }

    //! Return (rotatory) transformation matrix of local co-ordinate systems
    Teuchos::RCP<const LINALG::SparseMatrix> GetLocSysTrafo() const;

    //! Return locsys manager
    Teuchos::RCP<DRT::UTILS::LocsysManager> LocsysManager() {return locsysman_;}

    //! Sets the time for the next time step needed for the inverse analysis
    void SetTimen(double time){timen_ = time;};  //!< target time \f$t_{n+1}\f$

    //@}

    //! @name Contact and meshtying specific methods
    //@{

    //! use contact solver or not
    bool UseContactSolver();

    //! return bool indicating if contact or meshtying are defined
    bool HaveContactMeshtying() { return (cmtman_ != Teuchos::null); }

    //! return contact/meshtying manager
    Teuchos::RCP<MORTAR::ManagerBase> ContactManager() {return cmtman_;}

    //! Check if contact / meshtying is chosen in input file and
    //! create manager object + initialize all relevant stuff if so
    void PrepareContactMeshtying(const Teuchos::ParameterList& sdynparams);

    //! Prepare contact at the beginning of each new time step
    //! (call dynamic redistribution of contact interface(s) AND
    //! evaluate reference state for frictional contact at t=0)
    void PrepareStepContact();

    //! Only evaluate reference state for frictional contact at t=0
    void EvaluateReferenceState();

    //@}

    //! @name Beam contact specific methods
    //@{

    //! return bool indicating if beam contact is defined
    bool HaveBeamContact() { return (beamcman_ != Teuchos::null); }

    //! return beam contact manager
    Teuchos::RCP<CONTACT::Beam3cmanager> BeamContactManager() {return beamcman_;}

    //! Check if beam contact is chosen in input file and
    //! create manager object + initialize all relevant stuff if so
    void PrepareBeamContact(const Teuchos::ParameterList& sdynparams);

    //@}

    //! @name Structure with ale specific methods
    //@{

    //! material displacements (structure with ale)
   Teuchos::RCP<Epetra_Vector> DispMat() { return dismatn_; }

    //! apply material displacements to structure field (structure with ale)
    void ApplyDisMat(Teuchos::RCP<Epetra_Vector> dismat);

    //@}

  protected:

    //! @name General purpose algorithm members
    //@{
    Teuchos::RCP<DRT::Discretization> discret_;  //!< attached discretisation
    int myrank_;  //!< ID of actual processor in parallel
    const Epetra_Map* dofrowmap_;  //!< vector layout from the discretization
                                   //!< to construct matching
                                   //!< vectors and matrices
    Teuchos::RCP<LINALG::Solver> solver_;  //!< linear algebraic solver (no contact/meshtying)
    Teuchos::RCP<LINALG::Solver> contactsolver_;  //!< linear algebraic solver (for contact/meshtying)
    bool solveradapttol_;  //!< adapt solver tolerance
    double solveradaptolbetter_;  //!< tolerance to which is adpated ????
    Teuchos::RCP<LINALG::MapExtractor> dbcmaps_;  //!< map extractor object
                                                  //!< containing non-overlapping
                                                  //!< map of global DOFs on Dirichlet
                                                  //!< boundary conditions
    Teuchos::RCP<Epetra_Vector> dirichtoggle_;    //!< old style dirichtoggle vector
                                                  //!< (only used for contact and supposed
                                                  //!< to go away sonner or later)
    //@}

    //! @name Printing and output
    //@{
    Teuchos::RCP<IO::DiscretizationWriter> output_;  //!< binary output
    bool printlogo_;  //!< true: enjoy your cuppa
    int printscreen_;  //!< print infos to standard out every n steps
    FILE* errfile_;  //!< error file handle
    bool printerrfile_;  //!< print infos to error file #errfile_
    bool printiter_;  //!< print intermediate iterations during solution
    int writerestartevery_;  //!< write restart every given step;
                             //!< if 0, restart is not written
    int writereducedrestart_; // Write reduced Restart Data i.e no mesh for mlmc purposes
    bool writestate_;  //!< write state on/off
    int writeresultsevery_;  //!< write state/stress/strain every given step
    INPAR::STR::StressType writestress_;  //!< stress output type
    INPAR::STR::StrainType writestrain_;  //!< strain output type
    INPAR::STR::StrainType writeplstrain_;  //!< plastic strain output type
    int writeenergyevery_;  //!< write system energy every given step
    bool writesurfactant_;  //!< write surfactant output
    std::ofstream* energyfile_;  //!< outputfile for energy

    Teuchos::RCP<std::vector<char> > stressdata_; //!< container for element GP stresses
    Teuchos::RCP<std::vector<char> > straindata_; //!< container for element GP strains
    Teuchos::RCP<std::vector<char> > plstraindata_; //!< container for element GP plastic strains
    double kinergy_; //!< kinetic energy
    double intergy_; //!< internal energy
    double extergy_; //!< external energy
    //@}

    //! @name Damping
    //!
    //! Rayleigh damping means \f${C} = c_\text{K} {K} + c_\text{M} {M}\f$
    //@{
    enum INPAR::STR::DampKind damping_;  //!< damping type
    double dampk_;  //!< damping factor for stiffness \f$c_\text{K}\f$
    double dampm_;  //!< damping factor for mass \f$c_\text{M}\f$
    //@}

    //! @name Managed stuff
    //@{

    //! whatever constraints
    Teuchos::RCP<UTILS::ConstrManager> conman_;  //!< constraint manager
    Teuchos::RCP<UTILS::ConstraintSolver> consolv_;  //!< constraint solver

    //! surface stresses
    Teuchos::RCP<UTILS::SurfStressManager> surfstressman_;

    //! potential conditions
    Teuchos::RCP<POTENTIAL::PotentialManager>   potman_;

    //! contact / meshtying
    Teuchos::RCP<MORTAR::ManagerBase>   cmtman_;

    //! beam contact
    Teuchos::RCP<CONTACT::Beam3cmanager>   beamcman_;

    //! Dirichlet BCs with local co-ordinate system
    Teuchos::RCP<DRT::UTILS::LocsysManager> locsysman_;

    //! Map to differentiate pressure and displacement/velocity DOFs
    Teuchos::RCP<LINALG::MapExtractor> pressure_;

    //@}

    //! @name General control parameters
    //@{
    Teuchos::RCP<TimIntMStep<double> > time_;  //!< time \f$t_{n}\f$ of last converged step
    double timen_;  //!< target time \f$t_{n+1}\f$
    Teuchos::RCP<TimIntMStep<double> > dt_;  //!< time step size \f$\Delta t\f$
    double timemax_;  //!< final time \f$t_\text{fin}\f$
    int stepmax_;  //!< final step \f$N\f$
    int step_;  //!< time step index \f$n\f$
    int stepn_;  //!< time step index \f$n+1\f$
    bool lumpmass_;  //!< flag for lumping the mass matrix, default: false
    //@}

    //! @name Global vectors
    //@{
    Teuchos::RCP<Epetra_Vector> zeros_;  //!< a zero vector of full length
    //@}

    //! @name Global state vectors
    //@{

    //! global displacements \f${D}_{n}, D_{n-1}, ...\f$
    Teuchos::RCP<TimIntMStep<Epetra_Vector> > dis_;
    //! global velocities \f${V}_{n}, V_{n-1}, ...\f$
    Teuchos::RCP<TimIntMStep<Epetra_Vector> > vel_;
    //! global accelerations \f${A}_{n}, A_{n-1}, ...\f$
    Teuchos::RCP<TimIntMStep<Epetra_Vector> > acc_;
    Teuchos::RCP<Epetra_Vector> disn_;  //!< global displacements
                                        //!< \f${D}_{n+1}\f$
                                        //!< at \f$t_{n+1}\f$
    Teuchos::RCP<Epetra_Vector> veln_;  //!< global velocities
                                        //!< \f${V}_{n+1}\f$
                                        //!< at \f$t_{n+1}\f$
    Teuchos::RCP<Epetra_Vector> accn_;  //!< global accelerations
                                        //!< \f${A}_{n+1}\f$
                                        //!< at \f$t_{n+1}\f$
    //! global coupling variables of the thermo field
    Teuchos::RCP<Epetra_Vector> tempn_; //!< global temperatures
                                        //!< \f${T}_{n+1}\f$
                                        //!< at \f$t_{n+1}\f$
    //! additional external forces
    Teuchos::RCP<Epetra_Vector> fifc_;  //!< interface force in e.g. FSI
    //@}

    //! @name Structure with ale specific stuff
    //@{

    Teuchos::RCP<Epetra_Vector> dismatn_; //!< global material displacements
                                          //!< (structure with ale)
    //@}


    //! @name System matrices
    //@{
    //! holds eventually effective stiffness
    Teuchos::RCP<LINALG::SparseOperator> stiff_;
    //! mass matrix (constant)
    Teuchos::RCP<LINALG::SparseOperator> mass_;
    //! Rayleigh damping matrix (constant)
    Teuchos::RCP<LINALG::SparseOperator> damp_;
    //@}

    //! @name Time measurement
    //@{
    RCP<Epetra_Time>  timer_;    //!< timer for solution technique
    double            dtsolve_;  //!< linear solver time
    double            dtele_;    //!< element evaluation time
    double            dtcmt_;    //!< contact / meshtying evaluation time
    //@}

    //! @name Poroelasticity specific stuff
    //@{
    // global coupling variable of the fluid field (for poroelasticity problems only)
    Teuchos::RCP<const Epetra_Vector> fluidveln_; //!< global velocities and pressures at n+1
    double initporosity_;

    //@}

    //! @name Patient specific stuff
    //@{
    Teuchos::RCP<Teuchos::ParameterList> pslist_;
    //@}



    //----------------------------------------------------------------
    // the following methods are imported from the adapter_structure_timint and need a
    // merge with the already existing ones above
    //----------------------------------------------------------------
  public:

    /// initial guess of Newton's method
    virtual Teuchos::RCP<const Epetra_Vector> InitialGuess() = 0;

    /// right-hand-side of Newton's method
    virtual Teuchos::RCP<const Epetra_Vector> RHS() = 0;

    /// unknown displacements at \f$t_{n+1}\f$
    Teuchos::RCP<const Epetra_Vector> Dispnp(){ return DisNew(); }

    /// unknown displacements at \f$t_{n}\f$
    Teuchos::RCP<const Epetra_Vector> Dispn(){ return Dis(); }

    /// dof map of vector of unknowns
    Teuchos::RCP<const Epetra_Map> DofRowMap();

    /// dof map of vector of unknowns
    // new method for multiple dofsets
    Teuchos::RCP<const Epetra_Map> DofRowMap(unsigned nds);

    /// recalculate structural matrices for tsi simulations
    virtual void TSIMatrix() = 0;

    /// Get current time step \f$n\f$ (sometimes called \f$k\f$ [but not in Baci])
    virtual int GetTimeStep() const { return GetStep(); }

    /// start new time step
    virtual void PrepareTimeStep() = 0;

    virtual void Evaluate(Teuchos::RCP<const Epetra_Vector> disiterinc) = 0;

    /// update at time step end
    virtual void Update() = 0;

    /// Update iteration
    /// Add residual increment to Lagrange multipliers stored in Constraint manager
    virtual void UpdateIterIncrConstr
    (
      Teuchos::RCP<Epetra_Vector> lagrincr  ///< Lagrange multiplier increment
    ) = 0;


    /// output results
    virtual void Output() = 0;

    /// domain map of system matrix (do we really need this?)
    virtual const Epetra_Map& DomainMap(){ return GetDomainMap(); }

    /// are there any algebraic constraints?
    virtual bool HaveConstraint() = 0;

    /// get constraint manager defined in the structure
    virtual const RCP<UTILS::ConstrManager> GetConstraintManager() = 0;


    virtual INPAR::STR::STC_Scale GetSTCAlgo() = 0;


    virtual Teuchos::RCP<LINALG::SparseMatrix> GetSTCMat() = 0 ;


    /// @name Solver calls
    //@{

    /// non-linear solve
    ///
    /// Do the nonlinear solve for the time step. All boundary conditions have
    /// been set.
    virtual void Solve() = 0;

    //! Linear structure solve with just an interface load
    virtual Teuchos::RCP<Epetra_Vector> SolveRelaxationLinear() = 0;

    /// linear structure solve with just a interface load
    ///
    /// The very special solve done in steepest descent relaxation
    /// calculation (and matrix free Newton Krylov).
    ///
    /// \note Can only be called after a valid structural solve.
//    virtual Teuchos::RCP<Epetra_Vector> RelaxationSolve(
//      Teuchos::RCP<Epetra_Vector> iforce
//    ) = 0;

    //@}

    //! @name Extract methods
    //@{

    /// extract displacements
    virtual Teuchos::RCP<Epetra_Vector> ExtractDispnp(){ return DisNew(); }

    /// extract displacements
    virtual Teuchos::RCP<Epetra_Vector> ExtractDispn(){ return Dis(); }

    /// extract velocities
    virtual Teuchos::RCP<Epetra_Vector> ExtractVeln(){ return Vel(); }

    /// extract velocities
    virtual Teuchos::RCP<Epetra_Vector> ExtractVelnp(){ return VelNew(); }

    /// extract velocities
    virtual Teuchos::RCP<Epetra_Vector> ExtractVelaf(){ return Velaf(); }

    /// extract velocities
    virtual Teuchos::RCP<Epetra_Vector> ExtractAccn(){ return Acc(); }

    //@}

    //! specific method for iterative staggered partitioned TSI

    /// Identify residual
    /// This method does not predict the target solution but
    /// evaluates the residual and the stiffness matrix.
    /// In partitioned solution schemes, it is better to keep the current
    /// solution instead of evaluating the initial guess (as the predictor)
    /// does.
    virtual void PreparePartitionStep() = 0;

    /// create result test for encapsulated structure algorithm
    virtual Teuchos::RCP<DRT::ResultTest> CreateFieldTest();

    /// poroelasticity specific method
    virtual void PoroInitForceStiffResidual() {dserror("not available for explicit time integrators"); }

    // to be removed by Anh-Tu
    virtual void UpdateIterIncrementally(const Teuchos::RCP<const Epetra_Vector> disi)
    {dserror("not available for explicit time integrators"); }
    virtual void PrepareSystemForNewtonSolve()
    {dserror("not available for explicit time integrators"); }
    virtual void PoroEvaluateForceStiffResidual(bool predict = false)
    {dserror("not available for explicit time integrators"); }
    // to be removed by Anh-Tu ; END

  };

}  // namespace STR

/*----------------------------------------------------------------------*/
#endif  // #ifndef STRTIMINT_H
