/*----------------------------------------------------------------------*/
/*!
\file strtimint_expl.H
\brief Explicit time integration for structural dynamics

<pre>
Maintainer: Alexander Popp
            popp@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15238
</pre>
*/

/*----------------------------------------------------------------------*/
#ifndef STRTIMINT_EXPL_H
#define STRTIMINT_EXPL_H

/*----------------------------------------------------------------------*/
/* headers */
#include "strtimint.H"

/*----------------------------------------------------------------------*/
/* belongs to structural dynamics namespace */
namespace STR
{

  namespace AUX
  {
    class MapExtractor;
  }

  /*====================================================================*/
  /*!
   * \brief Front-end for structural dynamics
   *        with \b explicit time integrators
   *
   * <h3> About </h3>
   * This object bridges the gap between the base time integator STR::TimInt
   * and the specific implementation of explicit time integrators.
   *
   * \author bborn
   * \date 07/08
   */
  class TimIntExpl : public TimInt
  {

  public:

    //! @name Life
    //@{

    //! constructor
    TimIntExpl
    (
      const Teuchos::ParameterList& ioparams,  //!< ioflags
      const Teuchos::ParameterList& sdynparams,  //!< input parameters
      const Teuchos::ParameterList& xparams,  //!< extra flags
      Teuchos::RCP<DRT::Discretization> actdis,  //!< current discretisation
      Teuchos::RCP<LINALG::Solver> solver,  //!< the solver
      Teuchos::RCP<LINALG::Solver> contactsolver,  //!< the solver for contact meshtying
      Teuchos::RCP<IO::DiscretizationWriter> output  //!< the output
    );

    //! Empty constructor
    TimIntExpl() : TimInt() { ; }

    //! Copy constructor
    TimIntExpl(const TimIntExpl& old) : TimInt(old) { ; }

    //! Destructor
    virtual ~TimIntExpl() { ; };

    //@}

    //! @name Actions
    //@{

    //! Resize #TimIntMStep<T> multi-step quantities
    virtual void ResizeMStep() = 0;

    //! Do time integration of single step
    virtual int IntegrateStep() = 0;

    //! Update configuration after time step
    //!
    //! Thus the 'last' converged is lost and a reset of the time step
    //! becomes impossible. We are ready and keen awaiting the next time step.
    virtual void UpdateStepState() = 0;

    //! Update Element
    virtual void UpdateStepElement() = 0;
/*
    //! Update configuration and time after time step
    void UpdateStepAndTime()
    {
      // system state
      UpdateStepState();
      // update time and step
      time_->UpdateSteps(timen_);
      step_ = stepn_;
      //
      timen_ += (*dt_)[0];
      stepn_ += 1;
      // element update
      UpdateStepElement();
    }
*/
    //@}

    //! @name Output
    //@{

    //! print summary after step
    void PrintStep();

    //! The text for summary print, see #PrintStep
    void PrintStepText
    (
      FILE* ofile  //!< output file handle
    );

    //@}

    //! @name Attribute access functions
    //@{

    //! Return time integrator name
    virtual enum INPAR::STR::DynamicType MethodName() const = 0;

    //! These time integrators are all explicit (mark their name)
    bool MethodImplicit() { return false; }

    //! Provide number of steps, e.g. a single-step method returns 1,
    //! a m-multistep method returns m
    virtual int MethodSteps() = 0;

    //! Give local order of accuracy of displacement part
    virtual int MethodOrderOfAccuracyDis() = 0;

    //! Give local order of accuracy of velocity part
    virtual int MethodOrderOfAccuracyVel() = 0;

    //! Return linear error coefficient of displacements
    virtual double MethodLinErrCoeffDis() = 0;

    //! Return linear error coefficient of velocities
    virtual double MethodLinErrCoeffVel() = 0;

    //! return time integration factor
    virtual const double TimIntParam() const { dserror("TimeFac not yet implemented"); return -1.0; }

    //! return Newmark parameter \f$beta\f$
    virtual const double GetNewmarkBeta() const
    { dserror("Cannot return Newmark-beta. This is not a Newmark-type time integrator!"); return -1.0; }

    //@}

    //! @name System vectors
    //@{

    //! Return external force \f$F_{ext,n}\f$
    virtual Teuchos::RCP<Epetra_Vector> Fext() = 0;

    //! Return reaction forces
    Teuchos::RCP<Epetra_Vector> Freact()
    {
      dserror("Not impl.");
      return Teuchos::null;
    };

    //! Read and set external forces from file
    virtual void ReadRestartForce() = 0;

    //! Write internal and external forces for restart
    virtual void WriteRestartForce(Teuchos::RCP<IO::DiscretizationWriter> output) = 0;

    virtual Teuchos::RCP<Epetra_Vector> Velaf()
    {
      dserror("mid velocities not available");
      return Teuchos::null;
    }

    //! InitialGuess is not available for explicit time integrators
    virtual Teuchos::RCP<const Epetra_Vector> InitialGuess()
    {
      dserror("InitialGuess() is not available for explicit time integrators");
      return Teuchos::null;
    }

    //! RHS() is not available for explicit time integrators
    virtual Teuchos::RCP<const Epetra_Vector> RHS()
    {
      dserror("RHS() is not available for explicit time integrators");
      return Teuchos::null;
    }

    //! Prepare time step
    virtual void PrepareTimeStep()
    {
      // update end time \f$t_{n+1}\f$ of this time step to cope with time step size adaptivity
      SetTimen( (*time_)[0]+(*dt_)[0] );

      // prepare contact for new time step
      PrepareStepContact();

      return;
    }

    /// has to be renamed either here or IntegrateStep()
    virtual void Evaluate(
      Teuchos::RCP<const Epetra_Vector> disiterinc
    )
    {
      dserror("just here for overloading reasons, should go as soon as possible");
    }

    //! Apply external force
    void ApplyForceExternal
    (
      const double time,  //!< evaluation time
      const Teuchos::RCP<Epetra_Vector> dis,  //!< displacement state
      const Teuchos::RCP<Epetra_Vector> vel,  // velocity state
      Teuchos::RCP<Epetra_Vector>& fext  //!< external force
    );

    /// has to be renamed either here or PrintStep()
    virtual void Output(bool forced_writerestart)
    {
      OutputStep(forced_writerestart);
      return;
    }

    /// has to be renamed either here or UpdateStepState() /UpdateStepStateElement()
    virtual void Update()
    {
      UpdateStepState();
      UpdateStepTime();
      UpdateStepElement();
      return;
    }

    //! Update routine for coupled problems with monolithic approach with time adaptivity
    virtual void Update(const double endtime)
    {
      dserror("Not implemented. No time adaptivity available for explicit time integration.");
    }


    /* Linear structure solve with just an interface load */
    Teuchos::RCP<Epetra_Vector> SolveRelaxationLinear()
    {
      dserror("SolveRelaxationLinear() not implemented");
      return Teuchos::null;
    }

	  /// update all the field vectors to account for new node introduced by crack
    void updateEpetraVectorsCrack( std::map<int,int>& oldnew ) { dserror( "not implemented yet" ); }

    /// are there any algebraic constraints?
    virtual bool HaveConstraint()
    {
      dserror("HaveConstraint() has not been tested for explicit time integrators");
      return false;
    };

    /// are there any Windkessel bcs?
    virtual bool HaveWindkessel()
    {
      dserror("HaveWindkessel() has not been tested for explicit time integrators");
      return false;
    };

    //! Return Teuchos::rcp to ConstraintManager conman_
    virtual const Teuchos::RCP< ::UTILS::ConstrManager> GetConstraintManager()
    {
      dserror("GetConstraintManager() has not been tested for explicit time integrators");
      return Teuchos::null;
    };

    //! Return Teuchos::rcp to WindkesselManager conman_
    virtual const Teuchos::RCP< ::UTILS::WindkesselManager> GetWindkesselManager()
    {
      dserror("GetWindkesselManager() has not been tested for explicit time integrators");
      return Teuchos::null;
    };

    //! Get type of thickness scaling for thin shell structures
    virtual INPAR::STR::STC_Scale GetSTCAlgo()
    {
      dserror("GetSTCAlgo() has not been tested for explicit time integrators");
      return INPAR::STR::stc_none;
    };

    //! Access to scaling matrix for STC
    virtual Teuchos::RCP<LINALG::SparseMatrix> GetSTCMat()
    {
      dserror("GetSTCMat() has not been tested for explicit time integrators");
      return Teuchos::null;
    };

    virtual void UpdateIterIncrConstr
    (
      Teuchos::RCP<Epetra_Vector> lagrincr ///< Lagrange multiplier increment
    )
    {
      dserror("UpdateIterIncrConstr() has not been tested for explicit time integrators");
      return;
    }

    virtual void UpdateIterIncrWindkessel
    (
      Teuchos::RCP<Epetra_Vector> presincr ///< pressure increment
    )
    {
      dserror("UpdateIterIncrWindkessel() has not been tested for explicit time integrators");
      return;
    }

    /// Do the nonlinear solve, i.e. (multiple) corrector,
    /// for the time step. All boundary conditions have
    /// been set.
    virtual int Solve()
    {
      IntegrateStep();
      return 0;
    }

    //! prepare partiton step
    virtual void PreparePartitionStep()
    {
      // do nothing for explicit time integrators
      return;
    }

    virtual void UseBlockMatrix(Teuchos::RCP<const LINALG::MultiMapExtractor> domainmaps,
                                Teuchos::RCP<const LINALG::MultiMapExtractor> rangemaps)
    {
      dserror("UseBlockMatrix() not implemented");
    }
    //@}

  };

}  // namespace STR

/*----------------------------------------------------------------------*/
#endif  // #ifndef STRTIMINT_EXPL_H
