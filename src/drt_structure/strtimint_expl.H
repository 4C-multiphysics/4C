/*----------------------------------------------------------------------*/
/*!
\file strtimint_expl.H
\brief Explicit time integration for structural dynamics

<pre>
Maintainer: Alexander Popp
            popp@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15238
</pre>
*/

/*----------------------------------------------------------------------*/
#ifdef CCADISCRET
#ifndef STRTIMINT_EXPL_H
#define STRTIMINT_EXPL_H

/*----------------------------------------------------------------------*/
/* headers */
#include "strtimint.H"

/*----------------------------------------------------------------------*/
/* belongs to structural dynamics namespace */
namespace STR
{

  namespace AUX
  {
    class MapExtractor;
  }

  /*====================================================================*/
  /*!
   * \brief Front-end for structural dynamics
   *        with \b explicit time integrators
   *
   * <h3> About </h3>
   * This object bridges the gap between the base time integator STR::TimInt
   * and the specific implementation of explicit time integrators.
   *
   * \author bborn
   * \date 07/08
   */
  class TimIntExpl : public TimInt
  {

  public:

    //! @name Life
    //@{

    //! constructor
    TimIntExpl
    (
      const Teuchos::ParameterList& ioparams,  //!< ioflags
      const Teuchos::ParameterList& sdynparams,  //!< input parameters
      const Teuchos::ParameterList& xparams,  //!< extra flags
      Teuchos::RCP<DRT::Discretization> actdis,  //!< current discretisation
      Teuchos::RCP<LINALG::Solver> solver,  //!< the solver
      Teuchos::RCP<LINALG::Solver> contactsolver,  //!< the solver for contact meshtying
      Teuchos::RCP<IO::DiscretizationWriter> output  //!< the output
    );

    //! Empty constructor
    TimIntExpl() : TimInt() { ; }

    //! Copy constructor
    TimIntExpl(const TimIntExpl& old) : TimInt(old) { ; }

    //! Resize #TimIntMStep<T> multi-step quantities
    virtual void ResizeMStep() = 0;

    //@}

    //! @name Actions
    //@{

    //! Do time integration of single step
    virtual void IntegrateStep() = 0;

    //! Update configuration after time step
    //!
    //! Thus the 'last' converged is lost and a reset of the time step
    //! becomes impossible. We are ready and keen awating the next time step.
    virtual void UpdateStepState() = 0;

    //! Update Element
    virtual void UpdateStepElement() = 0;
/*
    //! Update configuration and time after time step
    void UpdateStepAndTime()
    {
      // system state
      UpdateStepState();
      // update time and step
      time_->UpdateSteps(timen_);
      step_ = stepn_;
      //
      timen_ += (*dt_)[0];
      stepn_ += 1;
      // element update
      UpdateStepElement();
    }
*/
    //@}

    //! @name Output
    //@{

    //! print summary after step
    void PrintStep();

    //! The text for summary print, see #PrintStep
    void PrintStepText
    (
      FILE* ofile  //!< output file handle
    );

    //@}

    //! @name Attribute access functions
    //@{

    //! Return time integrator name
    virtual enum INPAR::STR::DynamicType MethodName() const = 0;

    //! These time integrators are all explicit (mark their name)
    bool MethodImplicit() { return false; }

    //! Provide number of steps, e.g. a single-step method returns 1,
    //! a m-multistep method returns m
    virtual int MethodSteps() = 0;

    //! Give local order of accuracy of displacement part
    virtual int MethodOrderOfAccuracyDis() = 0;

    //! Give local order of accuracy of velocity part
    virtual int MethodOrderOfAccuracyVel() = 0;

    //! Return linear error coefficient of displacements
    virtual double MethodLinErrCoeffDis() = 0;

    //! Return linear error coefficient of velocities
    virtual double MethodLinErrCoeffVel() = 0;

    //! return time integration factor
    virtual double TimIntParam(){ dserror("TimeFac not yet implemented"); return -1.0; }

    //@}

    //! @name Fluid-structure-interaction specific methods
    //@{

    //! Set forces due to interface with fluid
    virtual void SetForceInterface
    (
      const AUX::MapExtractor& extractor,
      Teuchos::RCP<Epetra_Vector> iforce  ///< the force on interface
    );

    //@}

    //! @name System vectors
    //@{

    //! Return external force \f$F_{ext,n}\f$
    virtual Teuchos::RCP<Epetra_Vector> Fext() = 0;

    //! Return reaction forces
    Teuchos::RCP<Epetra_Vector> Freact()
    {
      dserror("Not impl.");
      return Teuchos::null;
    };

    //! Read and set external forces from file
    virtual void ReadRestartForce() = 0;

    virtual Teuchos::RCP<Epetra_Vector> Velaf()
    {
      dserror("mid velocities not available");
      return Teuchos::null;
    }

    //! InitialGuess is not available for explicit time integrators
    virtual Teuchos::RCP<const Epetra_Vector> InitialGuess()
    {
      dserror("InitialGuess() is not available for explicit time integrators");
      return Teuchos::null;
    }

    //! RHS() is not available for explicit time integrators
    virtual Teuchos::RCP<const Epetra_Vector> RHS()
    {
      dserror("RHS() is not available for explicit time integrators");
      return Teuchos::null;
    }

    /// recalculate structural matrices for tsi simulations
    virtual void TSIMatrix()
    {
      dserror("TSIMatrix() is not needed for explicit time integrators");
      return;
    }

    //! FORMERLY: Called from the previous adapters
    /* prepare time step */
    virtual void PrepareTimeStep()
    {
      dserror("PrepareTimeStep() is not needed for explicit time integrators");
    }

    /// has to be renamed either here or IntegrateStep()
    virtual void Evaluate(
      Teuchos::RCP<const Epetra_Vector> disiterinc
    )
    {
      dserror("just here for overloading reasons, should go as soon as possible");
    }

    /// has to be renamed either here or PrintStep()
    virtual void Output()
    {
      dserror("just here for overloading reasons, should go as soon as possible");
    }

    /// has to be renamed either here or UpdateStepState() /UpdateStepStateElement()
    virtual void Update()
    {
      dserror("just here for overloading reasons, should go as soon as possible");
    }

//    virtual Teuchos::RCP<Epetra_Vector> RelaxationSolve(
//      Teuchos::RCP<Epetra_Vector> iforce
//    )
//    {
//      dserror("RelaxationSolve() is not needed for explicit time integrators");
//      return Teuchos::null;
//    }

    /* Linear structure solve with just an interface load */
    Teuchos::RCP<Epetra_Vector> SolveRelaxationLinear()
    {
      dserror("SolveRelaxationLinear() not implemented");
      return Teuchos::null;
    }

    /// are there any algebraic constraints?
    virtual bool HaveConstraint()
    {
      dserror("HaveConstraint() has not been tested for explicit time integrators");
      return false;
    };

    //! Return rcp to ConstraintManager conman_
    virtual const RCP< ::UTILS::ConstrManager> GetConstraintManager()
    {
      dserror("GetConstraintManager() has not been tested for explicit time integrators");
      return Teuchos::null;
    };

    virtual INPAR::STR::STC_Scale GetSTCAlgo()
    {
      dserror("GetSTCAlgo() has not been tested for explicit time integrators");
      return INPAR::STR::stc_none;
    };

    virtual Teuchos::RCP<LINALG::SparseMatrix> GetSTCMat()
    {
      dserror("GetSTCMat() has not been tested for explicit time integrators");
      return Teuchos::null;
    };

    virtual void UpdateIterIncrConstr
    (
      Teuchos::RCP<Epetra_Vector> lagrincr ///< Lagrange multiplier increment
    )
    {
      dserror("UpdateIterIncrConstr() has not been tested for explicit time integrators");
      return;
    }

    ///  Do the nonlinear solve for the time step. All boundary conditions have
    ///  been set.
    /// eventually renamed here or IntegrateStep()
    virtual void Solve()
    {
      dserror("Solve() is not needed for explicit time integrators or rename it correctly");
      return;
    }

    //! prepare partiton step
    virtual void PreparePartitionStep()
    {
      // do nothing for explicit time integrators;
      return;
    }

    virtual void UseBlockMatrix(const LINALG::MultiMapExtractor& domainmaps, const LINALG::MultiMapExtractor& rangemaps)
    {
      dserror("UseBlockMatrix() not implemented");
    }
    //@}

  };

}  // namespace STR

/*----------------------------------------------------------------------*/
#endif  // #ifndef STRTIMINT_EXPL_H
#endif  // #ifdef CCADISCRET
