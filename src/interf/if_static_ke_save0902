/*!-----------------------------------------------------------------------
\file
\brief contains the routine 'if_static_ke' which calculates the usual
stiffness matrix for a interface element

*-----------------------------------------------------------------------*/
#ifdef D_INTERF
#include "../headers/standardtypes.h"
#include "interf.h"
#include "interf_prototypes.h"

/*! 
\addtogroup INTERF
*//*! @{ (documentation module open)*/

/*!----------------------------------------------------------------------
\brief calculates usual stiffness matrix  

<pre>                                                              mn 05/03
This routine calculates usual stiffness matrix for small strains
formulation.

</pre>
\param **s       DOUBLE    (o)  blablabla 
\param   dl      DOUBLE    (i)  blablabal

\warning There is nothing special to this routine
\return void                                               
\sa calling:  ---; 
    caled by: interf();

*----------------------------------------------------------------------*/
extern struct _GENPROB     genprob;
/*---------------------------------------------------------------------*/

void ifstatic_ke(ELEMENT       *ele, 
                 INTERF_DATA   *data, 
                 MATERIAL      *mat,
                 ARRAY         *estif_global,
                 ARRAY         *emass_global,
                 DOUBLE        *force,  /* global int forces (0-initialized in the corrector, not needed for predictor) */
                 INT            init)
{
const DOUBLE    q12 = ONE/TWO;
const DOUBLE    q14 = ONE/FOUR;
INT             ield;         /* numnp to this element     */
INT             iele;         /* numnp for gradient enhancement of wall     */
INT             numdfd;
INT             i,k,lr,ls,a,b;      /* some loopers     */
DOUBLE          detd,dete,detwall;   /* determinants of jacobian matrixes  */
DOUBLE          facd,face,facwall;   /* integration factors  */
DOUBLE          facr,facs;        /* weight at gaussian point                                      */
DOUBLE          e1,e2;          /* xi-coordinate of gaussian point                               */
INT             nir;         /* number of gaussian points                                     */
DOUBLE          Thick;       /* element thickness perpendicular to wall plane                    */
DOUBLE          width;       /* element thickness in wall plane                    */
DOUBLE          deltax,deltay;/* differences between coordinates */
DOUBLE          beta;        /* angle between xi-axis and X-Y system in [0,pi/4] */
DOUBLE          alpha;       /* angle between xi-axis and X-Y system in [0,..2 pi] */
DOUBLE          cod,sid;
DOUBLE          coe,sie;
DOUBLE          c_parabel,b_parabel; /* y = a + b*x + c*x^2  */
DOUBLE          help;        /* Zwischenwert */
DOUBLE          eps_vl;      /* local equivalent strain at gauss point */
DOUBLE          eps_vnl;     /* nonlocal equivalent strain at gauss point */
DOUBLE          nue;     
DOUBLE          k_fac;     
INT             flag=0;      /* flag for distinction between differnet element orientation cases  */
INT             ip;
INT             istore = 0;  /* controls storing of new stresses to wa */
INT             newval = 0;  /* controls evaluation of new stresses    */
INT             imass  = 0;  /* imass=0 -> static, imass=1 -> dynamic    */


static ARRAY    xrefe_a;     /* coordinates of element nodes */     
static DOUBLE **xrefe;         
static ARRAY    D_a;         /* material tensor */     
static DOUBLE **D;         
static ARRAY    F_a;         /* material tensor */     
static DOUBLE  *F;         

static ARRAY    functd_a;     /* shape functions for [u]*/    
static DOUBLE  *functd;     
static ARRAY    bopd_a;       /* lets call it B-operator for nt-direction*/   
static DOUBLE **bopd;     

static ARRAY    functwall_a;  /* shape functions for u */    
static DOUBLE  *functwall;     
static ARRAY    bopwall_a;    /* B-operator for strain */   
static DOUBLE **bopwall; 
static ARRAY    derivwall_a;  /* derivatives of u - Ansaetzen */   
static DOUBLE **derivwall; 
static ARRAY    xjmwall_a;     /* jacobian matrix for displacement */     
static DOUBLE **xjmwall;
    
static ARRAY    NL_a;         /* lets call it B-operator for xy-direction */   
static DOUBLE **NL;
     
static ARRAY    functe_a;     /* shape functions for nonlocal strains */    
static DOUBLE  *functe;     
static ARRAY    derive_a;     /* derivatives of nonl. equiv.strain shape funct*/   
static DOUBLE **derive;     
static ARRAY    bope_a;       /* B-operator for nonlocal strains */   
static DOUBLE **bope; 
static ARRAY    xjme_a;       /* jacobian matrix for nonlocal strains */     
static DOUBLE **xjme;
    
static ARRAY    Kdd_a;       /* element stiffness-Zwischenspeicher */   
static DOUBLE **Kdd;     
static ARRAY    Ked_a;       /* element stiffness-Zwischenspeicher */   
static DOUBLE **Ked;     
static ARRAY    Kee_a;       /* element stiffness-Zwischenspeicher */   
static DOUBLE **Kee;     
       
static DOUBLE **estif;       /* element stiffness matrix ke */

DOUBLE T[2];                 /* stress */
DOUBLE L[4];                 /* distance between corner nodes of the element */
DOUBLE x_mid[3];             /* x-coordinates on xi-axis */
DOUBLE y_mid[3];             /* y-coordinates on xi-axis */
DOUBLE fintd[16];            /* internal force Zwischenspeicher */
DOUBLE finte[4];             /* internal force in gradient enhanced environment */
DOUBLE grad_eps_vnl[2];      /* gradient of nonlocal equivalent strain */
DOUBLE e_vec[2];
DOUBLE fac_vec[2];
DOUBLE strain[4];            /* strain vector for nonlocal strain equation */
DOUBLE epsilon[3][3];        /* strain tensor  for nonlocal strain equation */
DOUBLE delta[3][3];          /* Kroneker delta (unit tensor)            */
DOUBLE F_ten[3][3];          /* Tensor F:=partial eps_v/partial epsilon  */
DOUBLE F_con[4];          /* zwischenstperierung von F  */
/*----------------------------------------------------------------------*/
#ifdef DEBUG 
dstrc_enter("ifstatic_ke");
#endif
/*------------------------------------------------- some working arrays */
if (init==1)
{
xrefe     = amdef("xrefe"  ,&xrefe_a,  2,8, "DA");

functd    = amdef("functd" ,&functd_a ,3,1, "DV");       
bopd      = amdef("bopd"   ,&bopd_a   ,2,16,"DA");           

NL        = amdef("NL"     ,&NL_a     ,2,16,"DA");           

functe    = amdef("functe" ,&functe_a ,4,1, "DV");       
derive    = amdef("derive" ,&derive_a ,2,4 ,"DA");       
bope      = amdef("bope"   ,&bope_a   ,2,4, "DA");           
xjme      = amdef("xjme"   ,&xjme_a   ,2,2 ,"DA");           

functwall = amdef("functwall" ,&functwall_a ,MAXNOD_WALL1,1, "DV");       
bopwall   = amdef("bopwall",&bopwall_a ,3,(2*MAXNOD_WALL1),"DA");           
derivwall = amdef("derivwall",&derivwall_a ,2,(2*MAXNOD_WALL1),"DA");           
xjmwall   = amdef("xjmwall"     ,&xjmwall_a  ,2,2 ,"DA");           

D         = amdef("D"      ,&D_a      ,2,2, "DA");           
F         = amdef("F"      ,&F_a      ,4,1, "DV");           

Kdd       = amdef("Kdd"    ,&Kdd_a    ,(2*MAXNOD_WALL1),(2*MAXNOD_WALL1),"DA");           
Ked       = amdef("Ked"    ,&Ked_a    ,4,(2*MAXNOD_WALL1),"DA");           
Kee       = amdef("Kee"    ,&Kee_a    ,4,4, "DA");           
goto end;
}
/*----------------------------------------------------------------------*/
/* uninit phase        (init=-1)                                        */
/*----------------------------------------------------------------------*/
else if (init==-1)
{
   amdel(&xrefe_a);   
   amdel(&functd_a);
   amdel(&functe_a);
   amdel(&derive_a);
   amdel(&functwall_a);
   amdel(&xjmwall_a);
   amdel(&xjme_a);
   amdel(&D_a);
   amdel(&F_a);
   amdel(&bopd_a);
   amdel(&bopwall_a);
   amdel(&NL_a);
   amdel(&bope_a);
   amdel(&Kdd_a);
   amdel(&Ked_a);
   amdel(&Kee_a);
   goto end;  
}
else if(init==2)
{
  istore = 1;
}
/*----------------------------------------------------------------------*/
/*----------- check orientation of element (which is my xi direction)---*/
ield     = ele->numnp;
numdfd   = 2* ield;
iele     = 4;
for (k=0; k<ield; k++)
{
 xrefe[0][k] = ele->node[k]->x[0];       /* coordinates in x-direction */
 xrefe[1][k] = ele->node[k]->x[1];       /* coordinates in y-direction */              
}
L[0] = sqrt( (xrefe[0][1] - xrefe[0][0]) * (xrefe[0][1] - xrefe[0][0])
     +       (xrefe[1][1] - xrefe[1][0]) * (xrefe[1][1] - xrefe[1][0]));
L[1] = sqrt( (xrefe[0][2] - xrefe[0][1]) * (xrefe[0][2] - xrefe[0][1])
     +       (xrefe[1][2] - xrefe[1][1]) * (xrefe[1][2] - xrefe[1][1]));
/*-------------------------------------------- integration parameters ---*/
ifintg(ele,data);

/*--------------------- coordinates of "nonexisting nodes" on xi-axes ---*/
switch(ele->distyp)
{
case quad4:

     if(L[0]>L[1])
     {
      x_mid[0]   = q12*(xrefe[0][0] + xrefe[0][3]);
      y_mid[0]   = q12*(xrefe[1][0] + xrefe[1][3]);
      x_mid[1]   = q12*(xrefe[0][1] + xrefe[0][2]);
      y_mid[1]   = q12*(xrefe[1][1] + xrefe[1][2]);
      flag = 1;
      width=L[1];
     }
     else if (L[1]>L[0])
     {
      x_mid[0]   = q12*(xrefe[0][0] + xrefe[0][1]);
      y_mid[0]   = q12*(xrefe[1][0] + xrefe[1][1]);
      x_mid[1]   = q12*(xrefe[0][2] + xrefe[0][3]);
      y_mid[1]   = q12*(xrefe[1][2] + xrefe[1][3]);
      flag = 2;
      width=L[0];
     }
     
break;
/*-----------------------------------------------------------------------*/
case quad8:

     if(L[0]>L[1])
     {
      x_mid[0]   = q12*(xrefe[0][0] + xrefe[0][3]);
      y_mid[0]   = q12*(xrefe[1][0] + xrefe[1][3]);
      x_mid[1]   = q12*(xrefe[0][1] + xrefe[0][2]);
      y_mid[1]   = q12*(xrefe[1][1] + xrefe[1][2]);
      x_mid[2]   = q12*(xrefe[0][4] + xrefe[0][6]);
      y_mid[2]   = q12*(xrefe[1][4] + xrefe[1][6]);
      flag = 1;
      width=L[1];
     }
     else if (L[1]>L[0])
     {
      x_mid[0]   = q12*(xrefe[0][0] + xrefe[0][1]);
      y_mid[0]   = q12*(xrefe[1][0] + xrefe[1][1]);
      x_mid[1]   = q12*(xrefe[0][2] + xrefe[0][3]);
      y_mid[1]   = q12*(xrefe[1][2] + xrefe[1][3]);
      x_mid[2]   = q12*(xrefe[0][5] + xrefe[0][7]);
      y_mid[2]   = q12*(xrefe[1][5] + xrefe[1][7]);
      flag = 2;
      width=L[0];
     }
     help      = (x_mid[0]-x_mid[1])/(x_mid[0]-x_mid[2]);
     c_parabel = (y_mid[0]-y_mid[1]-(y_mid[0]-y_mid[2])*help)/
                 (x_mid[0]*x_mid[0]-x_mid[1]*x_mid[1]-
                  (x_mid[0]*x_mid[0]-x_mid[2]*x_mid[2])*help);
     b_parabel = (y_mid[0]-y_mid[1]-c_parabel*(x_mid[0]*x_mid[0]-x_mid[1]*x_mid[1]))/
                 (x_mid[0]-x_mid[1]);
     
break;
}
Thick = ele->e.interf->thick;
nir   = ele->e.interf->nGP;

/*-------------------------------------------- reinitalization to zero---*/
amzero(estif_global);
estif     = estif_global->a.da;
/*------------------------------------------------ If Dynamic, Mass=0 ---*/
if (emass_global) 
{
   imass = 1;
   amzero(emass_global);
} 
/*=======================================================================*/
if(genprob.graderw<=0)
{
 ip = -1;
/*================================================= integration loop ===*/
 for (lr=0; lr<nir; lr++)
 {   
   ip++;
   /*================================ gaussian point and weight at it ===*/
   e1   = data->xgr[lr];
   facr = data->wgtr[lr];
   /*----------------------------------------------- ansatzfunctions ---*/
   if_funcderiv(e1,ele->distyp,x_mid,y_mid,b_parabel,c_parabel,functd,&cod,&sid,&detd);
   /*-------------------------------------------- integration factor ---*/
   facd  = facr * detd * Thick; 
    /*------------------------------------------ calculate operator B ---*/
   amzero(&bopd_a);
   amzero(&NL_a);
   if_bop(ele->distyp,bopd,functd,cod,sid,flag,NL);
   /*--------------------------------------------- call material law ---*/
   if (imass == 1) 
   { 
     if_mat_dyn(ele,mat,bopd,D,T,ip,istore,newval);
   } 
   else 
   {
     if_mat(ele,mat,bopd,D,T,ip,istore,newval);
   }
   /*-------------------------------------------------------------------*/
   /*-------------------------------------------------------------------*/
   if(istore==0)
   {
     /*--------------------------------- element stiffness matrix ke ---*/
      if_ke(ield,flag,estif,bopd,D,facd);
     /*--------------------------------------- internal nodal forces ---*/        
      if (force)
      { 
        if_fint(ield,T,facd,bopd,force);
      }                    
    } 
 }/*================================================ end of loop over lr */
}
/*=======================================================================*/
if(genprob.graderw>0)
{
 amzero(&Kdd_a);
 amzero(&Ked_a);
 amzero(&Kee_a);
 for (a=0; a<16; a++)  fintd[a] = 0.0;
 for (a=0; a<4; a++)   finte[a] = 0.0;
 ip = -1;
/*============================ integration loop for balance equation ===*/
 for (lr=0; lr<nir; lr++)
 {   
   ip++;
   /*=============================== gaussian point and weight at it ===*/
   e1   = data->xgr[lr];
   facr = data->wgtr[lr];
   /*----------------------------------------------- ansatzfunctions ---*/
   if_funcderiv(e1,ele->distyp,x_mid,y_mid,b_parabel,c_parabel,functd,&cod,&sid,&detd);
   /*------------------------------- B-operator for nonlocal strains ---*/
   /*
   amzero(&bope_a);
   if_func_bope(e1,x_mid,y_mid,functe,&coe,&sie,&dete,flag,bope);
   */
   /*-------------------------------------------- integration factor ---*/
   facd  = facr * detd * Thick; 
   /*
   face  = facr * dete * Thick * width; 
   */
    /*----------------------------------------- calculate operator B ---*/
   amzero(&bopd_a);
   amzero(&NL_a);
   if_bop(ele->distyp,bopd,functd,cod,sid,flag,NL);
    /*------------------------- calculate equivalent strain measures ---*/
    /*
   if_nonlocal(ele,mat,functe,bope,bopd,grad_eps_vnl,&eps_vnl,&eps_vl,F,coe,sie,width);
   */
   /*--------------------------------------------- call material law ---*/
   if (imass == 1) 
   { 
     if_mat_dyn(ele,mat,bopd,D,T,ip,istore,newval);
   } 
   else 
   {
     if_mat(ele,mat,bopd,D,T,ip,istore,newval);
   }
   /*-------------------------------------------------------------------*/
   /*-------------------------------------------------------------------*/
   if(istore==0)
   {
     /*--------------------------------- element stiffness matrix ke ---*/
      if_ke(ield,flag,Kdd,bopd,D,facd);
      /*
      if_stiff_ed(Ked,functe,F,bopd,facd,width,numdfd);
      if_stiff_ee(Kee,functe,bope,mat->m.ifmat->c_rad,face);
      */
     /*--------------------------------------- internal nodal forces ---*/        
      if (force)
      { 
        if_fint(ield,T,facd,bopd,fintd);
        /*
        if_fint_e(finte,functe,bope,grad_eps_vnl,eps_vnl,eps_vl,mat->m.ifmat->c_rad,face);
        */
      }                    
    } 
 }/*================================================ end of loop over lr */
 e_vec[0]  = -0.5773502691896;
 e_vec[1]  = 0.5773502691896;
 fac_vec[0]= 1.0;
 fac_vec[1]= 1.0;
 /*===================== integration loop for nonlocal strain equation ===*/
 for (lr=0; lr<2; lr++)
 {
   e1   = e_vec[lr];
   facr = fac_vec[lr];
   for (ls=0; ls<2; ls++)
   {
     e2   = e_vec[ls];
     facs = fac_vec[ls];
     /*---------------------- shape functions and their derivatives ---*/
     w1_funct_deriv(functwall,derivwall,e1,e2,quad4,1);
     w1_funct_deriv(functe,derive,e1,e2,quad4,1);
     /*------------------------------------ compute jacobian matrix ---*/       
     w1_jaco(NULL,derivwall,xjmwall,&detwall,ele,4);                         
     w1_jaco(NULL,derive,xjme,&dete,ele,4);                         
     /*----------------------------------------- integration factor ---*/ 
     facwall = facr * facs * detwall * Thick;
     face    = facr * facs * dete * Thick;
     /*--------------------------------------- calculate operator B ---*/
     amzero(&bopwall_a);
     w1_bop(bopwall,derivwall,xjmwall,detwall,4);
     amzero(&bope_a);
     wge_bope(bope,derive,xjme,dete);
     /*--- compute strain nonl.equiv.strain, grad nonl.equiv.strain ---*/        
     wge_strain(ele,bopwall,functe,bope,strain,&eps_vnl,grad_eps_vnl);
     nue = mat->m.ifmat->nue;
     /*--------------------------------- plane stress zum probieren ---*/        
     strain[3]=-(nue*(strain[0]+strain[1]))/(1.0-nue);
     /*------------------------ from strain-vector to strain-tensor ---*/        
     w1_4to9(strain,epsilon);
     /*------------------------------------- produce Kroneker Delta ---*/
     w1_kroneker(delta);
     /*------------- compute local equivalent strain and derivative ---*/
     k_fac = mat->m.ifmat->k_fac;
     wge_epsequiv(4,epsilon,delta,k_fac,nue,&eps_vl,F_ten);
     /*-------- from tangenttensor to vector F (just anoth arangem.)---*/
     w1_9to4(F_ten,F); 
     /*--------------------------------- plane stress zum probieren ---*/        
     F_con[0] = F[0] - (nue/(1.0 - nue)) * F[3];
     F_con[1] = F[1] - (nue/(1.0 - nue)) * F[3];
     F_con[2] = F[2];
     for(i=0; i<3; i++)
     {
       F[i] = F_con[i];
     }
     F[3] = 0.0;
     /*---------------- element matrices for nonlocal equation kele ---*/
     wge_stiff_ed(Ked,bopwall,F,functe,facwall,8,4,3);
     wge_stiff_ee(Kee,bope,mat->m.damage_ge->crad,functe,face,4);
     /*-------------------------------------------- internal forces ---*/        
     if (force)
     {
      wge_finte(eps_vl,eps_vnl,grad_eps_vnl,mat->m.damage_ge->crad,face,bope,functe,4,finte);
     }
     
  }/*============================================= end of loop over ls */
 }/*============================================== end of loop over lr */

 amzero(&Ked_a);
 amzero(&Kee_a);
 for (a=0; a<4; a++)   finte[a] = 0.0;

 
 if(istore==0)
 {
   if_permstiff(estif,Kdd,Ked,Kee,iele,ield);
   if(force)
   {
     if_permforce(force,finte,fintd,iele,ield);
   }
 }
}
/*=======================================================================*/


/*----------------------------------------------------------------------*/
end:
/*----------------------------------------------------------------------*/
#ifdef DEBUG 
dstrc_exit();
#endif
return; 
} /* end of ifstatic_ke */


/*----------------------------------------------------------------------*/
#endif /*D_INTERF*/
/*! @} (documentation module close)*/
