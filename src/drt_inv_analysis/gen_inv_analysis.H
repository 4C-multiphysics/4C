/*----------------------------------------------------------------------*/
/*!
 * \file gen_inv_analysis.H

<pre>
Maintainer: Michael Gee
            gee@lnm.mw.tum.de
            http://www.lnm.mw.tum.de/Members/gee
            089 - 289-15239
</pre>
*/
/*----------------------------------------------------------------------*/
#ifndef GEN_INV_ANALYSIS_H
#define GEN_INV_ANALYSIS_H

#include "Teuchos_RCP.hpp"
#include "Epetra_SerialDenseMatrix.h"
#include "Epetra_SerialDenseVector.h"
#include "Epetra_Vector.h"

// forward declarations

namespace COMM_UTILS
{
  class NestedParGroup;
}

namespace STR
{
  class TimInt;
}

namespace IO
{
  class DiscretizationWriter;
}

namespace LINALG
{
  class Solver;
}

namespace DRT
{
  class Condition;
  class Discretization;
}

namespace STR
{

/*====================================================================*/
/*!
* Inverse Analysis of Structures
*
* To optimize the material parameters \f$ \mathbf p\f$ , given by
*
* \f[ \mathbf{p} = [p_1, ..., p_k]^T \f]
*
* of each constitutive model, an inverse analysis was performed.
*
*
*
* Beginning with an initial guess of the material parameters, displacements
* were calculated and compared to those obtained from the experiment.
* For the comparison, selected dofs of selected nodes, at every
* time step of the simulation were measured.
*
* As long as the difference between calculated and measured dofs
* was higher than a tolerance, a new set of parameters was calculated by
* utilizing the Levenberg- Marquardt Algorithm, developed by
* [Levenberg1944] and [Marquardt1963]. This algorithm is based
* on a least square fit, and has already shown good results for soft
* biological tissue [Kauer2002, Mahnken1996, Moulton1995, Seshaiyer2003].
*
* In this approach the material parameters were updated according to
* \f[
*       \Delta \mathbf{p} = [\mathbf{J}^T(\mathbf {p})\mathbf{J}(\mathbf {p}) +
*       \mu ~ diag(\mathbf{J}^T(\mathbf {p})\mathbf{J}(\mathbf {p}))]^{-1} \mathbf{J}^T(\mathbf {p}) \mathbf {R}
* \f]
*
* with \f$\mu\f$ being a dimensionless training parameter and \f$\mathbf{J}\f$ being the rectangular
* Jacobian-Matrix of the dofs change with respect to the parameter change, i. e.
*
* \f[
*     \begin{array}{c}
*     \ \mathbf J= \left( \begin{array}{ccc}
*     \frac {\partial \mathbf{u}_1} {\partial p_1} & ... & \frac {\partial \mathbf{u}_1}{\partial p_k} \\
*     \vdots	 &   & \vdots \\
*     \frac {\partial \mathbf{u}_{n}} {\partial p_1}	&  ... & \frac {\partial \mathbf{u}_{n}}{\partial p_k}
*     \end{array} \right).
*     \end{array}
* \f]
*
* At each of the \f$ n\f$ time steps the dofs \f$\mathbf{u}\f$ were measured.
* \f$\mathbf{R}\f$ is the residual vector given by the difference between
* calculated and experimentally determined displacements
*\f[
*        \begin{array}{c}
*        \mathbf R =  \left( \begin{array}{c}
*        \mathbf {r}_{1}\\
*        \vdots \\
*        \mathbf {r}_{n}
*        \end{array} \right)
*         =  \left( \begin{array}{c}
*        \mathbf{u}_{1, cal} - \mathbf{u}_{1, exp}\\
*        \vdots \\
*        \mathbf{u}_{n,cal} - \mathbf{u}_{n, exp}
*        \end{array} \right).
*        \end{array}
*\f]
*
* The standardized error \f$ err\f$ used is the root mean square of
* \f$\mathbf R \f$
*\f[
*     err =  \sqrt {\frac { \sum _{i=1}^{n} (\mathbf{r}_i\cdotp\mathbf{r}_i)} {n}}
*\f]
*
*
* \author rausch
*/

class GenInvAnalysis {

private:

  /// my structure discretisation to work at
  Teuchos::RCP<DRT::Discretization> discret_;

  /// linear algebraic solver
  Teuchos::RCP<LINALG::Solver> solver_;

  /// context for output and restart
  Teuchos::RCP<IO::DiscretizationWriter> output_;

  ///  time integrator for structural dynamics
  Teuchos::RCP<STR::TimInt> sti_;

  ///  number of measurment points the
  double tstep_;                    // timestep

  int problem_type_;		            // Neumann or Dirichlet Problem
  int np_;                          // number of fitted parameters (default 3, 4 with kappa)
  int nmp_;                         // total number of measured dofs

  Epetra_SerialDenseVector mcurve_; // measured displacement of the experiments (target value)
  std::vector<double> timesteps_;   // time values where displacements are measured

  double mu_;
  double mu_o_;

  double error_;
  double error_o_;
  // Gradient based error measure
  double error_grad_;
  double error_grad_o_;

  double error_i_; //keeps the current error for the tolerance check depending on the update strategy
  double tol_;

  // Update Stratgy for mu
  enum INV_REG_UPDATE_STRATEGY
    {
      grad_based,
      res_based
    };
  INV_REG_UPDATE_STRATEGY reg_update_;

  // don't accept optimization step for negative material parameters
  int check_neg_params_;


  string filename_;

  double kappa_multi_;

  int numb_run_;

  Epetra_SerialDenseVector p_;	           // parameter vector
  Epetra_SerialDenseVector p_o_;           // parameters of the last step

  /// @name Storage
  //@{
  Epetra_SerialDenseMatrix p_s_;
  Epetra_SerialDenseMatrix delta_p_s_;
  Epetra_SerialDenseMatrix par_s_;
  Epetra_SerialDenseVector mu_s_;
  Epetra_SerialDenseVector error_s_;
  Epetra_SerialDenseVector error_grad_s_;
  //Epetra_SerialDenseMatrix ccurve_s_;
  //@}

  int reset_out_count_;

  std::set<int> matset_;
  std::vector<std::set<int> > eh_matset_;

  // observed nodes, dofs, timesteps
  int                  nnodes_;        // number of nodes observed
  int                  ndofs_;         // total number of dofs monitored
  int                  nsteps_;        // number of time steps observed
  std::vector<int>          nodes_;         // list of node gids observed
  std::vector<std::vector<int> > dofs_;          // list of dofs on each node that are monitored

public:

  /// standard constructor
  GenInvAnalysis(
    Teuchos::RCP<DRT::Discretization> dis,  ///< the discretisation
    Teuchos::RCP<LINALG::Solver> solver,  ///< algebraic solver
    Teuchos::RCP<IO::DiscretizationWriter> output  ///< outputer
    );

  /// Read in routine for the material parameters
  void ReadInParameters();

  /// Set material parameters
  void SetParameters(Epetra_SerialDenseVector p_cur);

  /// get current state of calculated curve
  Epetra_SerialDenseVector GetCalculatedCurve(Epetra_Vector& disp);

  /// coarse fitting of parameters
  void PrecondParameters();

  /// fitting the material parameters using the Levenberg-Marquart algorithm
  void CalcNewParameters(Epetra_SerialDenseMatrix& cmatrix, std::vector<double>& perturb);


  /// Calculate the new dof vector for comparison with the experimental data
  Epetra_SerialDenseVector CalcCvector(bool outputtofile);

  /// NP Calculate the new dof vector for comparison with the experimental data
  Epetra_SerialDenseVector CalcCvector(bool outputtofile,Teuchos::RCP<COMM_UTILS::NestedParGroup> group);

  /// acual inverse analysis loop
  void Integrate();

  /// acual inverse analysis loop (nested parallel version)
  void NPIntegrate();

  /// Output of Inverse Analysis
  void PrintStorage(Epetra_SerialDenseMatrix cmatrix, Epetra_SerialDenseVector delta_p);
  void PrintFile();

  // Check if mat params are out of bounds
  void CheckOptStep();

  /// Re-initialized micro-scale
  void MultiInvAnaInit();


};  // class GenInvAnalysis

}  // namespace STR

#endif /*INV_ANALYSIS_H_*/
