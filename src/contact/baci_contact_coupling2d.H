/*---------------------------------------------------------------------*/
/*! \file
\brief Classes for mortar contact coupling in 2D.

\level 2


*/
/*---------------------------------------------------------------------*/
#ifndef BACI_CONTACT_COUPLING2D_H
#define BACI_CONTACT_COUPLING2D_H

#include "baci_config.H"

#include "baci_inpar_contact.H"
#include "baci_inpar_wear.H"
#include "baci_mortar_coupling2d.H"

BACI_NAMESPACE_OPEN

namespace CONTACT
{
  /*!
  \brief A class representing the framework for mortar coupling of ONE
         slave element and ONE master element of a contact interface in
         2D. This is a derived class from MORTAR::Coupling2d which does
         the contact-specific stuff for 2d mortar coupling.

  */

  class CoCoupling2d : public MORTAR::Coupling2d
  {
   public:
    /*!
    \brief Constructor with shape function specification

    Constructs an instance of this class and enables custom shape function types.<br>
    Note that this is \b not a collective call as coupling is
    performed in parallel by individual processes.

    */
    CoCoupling2d(DRT::Discretization& idiscret, int dim, bool quad, Teuchos::ParameterList& params,
        MORTAR::MortarElement& sele, MORTAR::MortarElement& mele);

    //! @name Evlauation methods

    /*!
    \brief Integrate overlap of slave / master pair (2D)

    Derived version! Most importantly, in this derived version
    a CONTACT::CoIntegrator instance is created, which also
    does integration of the mortar quantity linearizations

    This method integrates the overlap of the current MortarElement
    pair sele_ / mele_ based on the integration limits (xiproj). The
    integration includes the Mortar matrices D/M and the gap g.

    */
    bool IntegrateOverlap(const Teuchos::RCP<MORTAR::ParamsInterface>& mparams_ptr) override;

    /*!
    \brief Return type of wear surface definition

    */
    INPAR::WEAR::WearSide WearSide()
    {
      return INPUT::IntegralValue<INPAR::WEAR::WearSide>(imortar_, "BOTH_SIDED_WEAR");
    }

    /*!
    \brief Return type of wear surface definition

    */
    INPAR::WEAR::WearType WearType()
    {
      return INPUT::IntegralValue<INPAR::WEAR::WearType>(imortar_, "WEARTYPE");
    }

    //@}


   protected:
    // don't want = operator and cctor
    CoCoupling2d operator=(const CoCoupling2d& old) = delete;
    CoCoupling2d(const CoCoupling2d& old) = delete;

    // new variables as compared to base class
    INPAR::CONTACT::SolvingStrategy stype_;

  };  // class CoCoupling2d

  /*!
  \brief A class representing the framework for mortar coupling of ONE
         slave element and SEVERAL master elements of a mortar interface in
         2D. Concretely, this class simply stores several Coupling2d objects.

  */

  class CoCoupling2dManager : public MORTAR::Coupling2dManager
  {
   public:
    /*!
    \brief Constructor with shape function specification

    Constructs an instance of this class and enables custom shape function types.<br>
    Note that this is \b not a collective call as coupling is
    performed in parallel by individual processes.

    */
    CoCoupling2dManager(DRT::Discretization& idiscret, int dim, bool quad,
        Teuchos::ParameterList& params, MORTAR::MortarElement* sele,
        std::vector<MORTAR::MortarElement*> mele);


    /*!
    \brief Get communicator

    */
    virtual const Epetra_Comm& Comm() const;

    /*!
    \brief Get problem dimension

    */
    virtual const int& Dim() const { return dim_; }

    /*!
    \brief Return the LM shape fcn type

    */
    INPAR::MORTAR::ShapeFcn ShapeFcn()
    {
      return INPUT::IntegralValue<INPAR::MORTAR::ShapeFcn>(imortar_, "LM_SHAPEFCN");
    }

    /*!
    \brief Evaluate mortar coupling

    */
    void IntegrateCoupling(const Teuchos::RCP<MORTAR::ParamsInterface>& mparams_ptr) override;

    bool EvaluateCoupling(const Teuchos::RCP<MORTAR::ParamsInterface>& mparams_ptr) override;
    //@}
   private:
    /*!
    \brief Calculate consistent dual shape functions in boundary elements

    */
    void ConsistDualShape() override;

   protected:
    // don't want = operator and cctor
    CoCoupling2dManager operator=(const CoCoupling2dManager& old) = delete;
    CoCoupling2dManager(const CoCoupling2dManager& old) = delete;

    INPAR::CONTACT::SolvingStrategy stype_;  // solving strategy

  };  // class CoCoupling2dManager

}  // namespace CONTACT


BACI_NAMESPACE_CLOSE

#endif  // CONTACT_COUPLING2D_H
