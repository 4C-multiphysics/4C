/*-----------------------------------------------------------------------------------------------*/
/*! \file

\brief class to handle contact between a 3D beam element and a rigid sphere

\level 3

*/
/*-----------------------------------------------------------------------------------------------*/
#ifndef BEAMINTERACTION_BEAM_TO_SPHERE_CONTACT_PAIR_H
#define BEAMINTERACTION_BEAM_TO_SPHERE_CONTACT_PAIR_H

#include "beaminteraction_contact_pair.H"

// Todo get rid of header inclusions
#include <Teuchos_RCP.hpp>
#include <Epetra_SerialDenseMatrix.h>
#include <Epetra_SerialDenseVector.h>
#include <Epetra_Vector.h>

#include "beaminteraction_beam3contact_defines.H"
#include "lib_condition.H"
#include "linalg_serialdensematrix.H"
#include "linalg_serialdensevector.H"
#include "lib_node.H"
#include "lib_element.H"
#include "discretization_fem_general_utils_integration.H"
#include "linalg_fixedsizematrix.H"
#include "linalg_sparsematrix.H"
#include "headers_FAD_utils.H"

// forward declaration ...
namespace LINALG
{
  class SerialDenseVector;
  class SerialDenseMatrix;
}  // namespace LINALG

namespace DRT
{
  namespace ELEMENTS
  {
    class Rigidsphere;
    class Beam3Base;
  }  // namespace ELEMENTS
}  // namespace DRT

namespace BEAMINTERACTION
{
  template <unsigned int numnodes, unsigned int numnodalvalues>
  class BeamToSphereContactPair : public BeamContactPair
  {
   public:
    //! @name Friends
    // no friend classes defined
    //@}

    //! @name Constructors and destructors and related methods

    /*!
    \brief Standard Constructor
    */
    BeamToSphereContactPair();

    /*!
    \brief Destructor
    */
    virtual ~BeamToSphereContactPair(){};

    //! Setup
    virtual void Setup();

    //@}

    //! @name Derived methods from base class
    /*!
    \brief things that need to be done in a separate loop before the actual evaluation loop
           over all contact pairs
    */
    void PreEvaluate() override;

    /*!
    \brief Evaluate this contact element pair, return value indicates whether pair is active,
           i.e. non-zero values for force and stiffmat are returned
    */
    virtual bool Evaluate(LINALG::SerialDenseVector* forcevec1,
        LINALG::SerialDenseVector* forcevec2, LINALG::SerialDenseMatrix* stiffmat11,
        LINALG::SerialDenseMatrix* stiffmat12, LINALG::SerialDenseMatrix* stiffmat21,
        LINALG::SerialDenseMatrix* stiffmat22);

    /*
    \brief Update state of translational nodal DoFs (absolute positions (and tangents)) of both
    elements
    */
    virtual void ResetState(const std::vector<double>& centerline_dofvec_ele1,
        const std::vector<double>& centerline_dofvec_ele2);

    /** \brief print information about this beam contact element pair to screen
     *
     *  \author grill
     *  \date 05/16 */
    virtual void Print(std::ostream& out) const;


    /** \brief print this beam contact element pair to screen
     *
     *  \author grill
     *  \date 12/16 */
    virtual void PrintSummaryOneLinePerActiveSegmentPair(std::ostream& out) const;
    //@}

    //! @name Access methods

    /*!
    \brief Get beam element
    */
    inline DRT::ELEMENTS::Beam3Base const* BeamElement() { return beam_element_; };

    /*!
    \brief Get sphere element
    */
    inline DRT::ELEMENTS::Rigidsphere const* SphereElement() { return sphere_element_; };

    /*!
    \brief Get flag indicating whether contact is active (true) or inactive (false)
    */
    virtual inline bool GetContactFlag() const
    {
      return (contactflag_ or nodalcontactflag_[0] or nodalcontactflag_[1]);
    };

    /*!
    \brief Get number of active contact point pairs on this element pair
    */
    virtual unsigned int GetNumAllActiveContactPointPairs() const { return 1; }


    /*!
    \brief Get coordinates of all active contact points on element1 and element2
    */
    virtual inline void GetAllActiveContactPointCoordsElement1(
        std::vector<LINALG::Matrix<3, 1, double>>& coords) const
    {
      dserror("not implemented yet!");
    }

    virtual inline void GetAllActiveContactPointCoordsElement2(
        std::vector<LINALG::Matrix<3, 1, double>>& coords) const
    {
      dserror("not implemented yet!");
    }

    /*!
    \brief Get all (scalar) contact forces of this contact pair
    */
    virtual inline void GetAllActiveContactForces(std::vector<double>& forces) const
    {
      dserror("not implemented yet!");
    }

    /*!
    \brief Get all (scalar) gap values of this contact pair
    */
    virtual void GetAllActiveContactGaps(std::vector<double>& gaps) const
    {
      dserror("not implemented yet!");
    }

    /*!
    \brief Get energy of penalty contact.
    */
    double GetEnergy() const override
    {
      dserror("not implemented yet!");
      return 0.0;
    }
    //@}


   private:
    //! @name Private evaluation methods

    /*!
    \brief Find contact point via closest point projection
    */
    void ClosestPointProjection();

    /*!
    \brief Utility method for CPP (evaluate nonlinear function f)
    */
    void EvaluateOrthogonalityCondition(TYPE& f, const LINALG::Matrix<3, 1, TYPE>& delta_x,
        const double norm_delta_x, const LINALG::Matrix<3, 1, TYPE>& dx1);

    /*!
    \brief Utility method for CPP (evaluate Jacobian of nonlinear function f)
    */
    void EvaluateLinOrthogonalityCondition(TYPE& df, LINALG::Matrix<3, 1, TYPE>& delta_x,
        const double norm_delta_x, const LINALG::Matrix<3, 1, TYPE>& dx1,
        const LINALG::Matrix<3, 1, TYPE>& ddx1);

    /*!
    \brief Evaluate and assemble contact forces
    */
    void EvaluateFcContact(LINALG::SerialDenseVector& forcevec1,
        LINALG::SerialDenseVector& forcevec2, const double& pp, const TYPE& gap,
        const LINALG::Matrix<3, 1, TYPE>& normal,
        const LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i, const bool contactactive);

    /*!
    \brief Evaluate and assemble contact stiffness
    */
    void EvaluateStiffcContact(LINALG::SerialDenseMatrix& stiffmat11,
        LINALG::SerialDenseMatrix& stiffmat12, LINALG::SerialDenseMatrix& stiffmat21,
        LINALG::SerialDenseMatrix& stiffmat22, const double& pp, const TYPE& gap,
        const LINALG::Matrix<3, 1, TYPE>& normal, const TYPE& norm,
        const LINALG::Matrix<3, 1, TYPE>& x1, const LINALG::Matrix<3, 1, TYPE>& x2,
        const LINALG::Matrix<3, 1, TYPE>& dx1, const LINALG::Matrix<3, 1, TYPE>& ddx1,
        const LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i,
        const LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i_xi,
        const LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i_xixi, bool activecontact,
        bool linxi = true);

    /*!
    \brief Compute normal vector in contact point
    */
    void ComputeNormal(LINALG::Matrix<3, 1, TYPE>& normal, TYPE& gap, TYPE& norm,
        const LINALG::Matrix<3, 1, TYPE>& x1, const LINALG::Matrix<3, 1, TYPE>& x2);

    /*!
    \brief Evaluate gap function
    */
    void ComputeGap(TYPE& gap, const TYPE& norm);

    /*!
    \brief Compute radius of cross section based on moment of inertia
    */
    void ComputeEleRadius(double& radius, const double& moi);

    /*!
    \brief Compute coordinates and their derivatives from the discretization
    */
    void ComputeCoordsAndDerivs(LINALG::Matrix<3, 1, TYPE>& x1, LINALG::Matrix<3, 1, TYPE>& x2,
        LINALG::Matrix<3, 1, TYPE>& dx1, LINALG::Matrix<3, 1, TYPE>& ddx1,
        const LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i,
        const LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i_xi,
        const LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i_xixi);

    /*!
    \brief Get shape functions and their derivatives at eta
    */
    void GetShapeFunctions(LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i,
        LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i_xi,
        LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i_xixi, const TYPE& xi);

    /*!
    \brief Compute linearizations of contact point
    */
    void ComputeLinXi(LINALG::Matrix<3 * numnodes * numnodalvalues + 3, 1, TYPE>& delta_xi,
        const LINALG::Matrix<3, 1, TYPE>& x1, const LINALG::Matrix<3, 1, TYPE>& x2,
        const LINALG::Matrix<3, 1, TYPE>& dx1, const LINALG::Matrix<3, 1, TYPE>& ddx1,
        const LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i,
        const LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i_xi);

    /*!
    \brief Compute linearization of gap
    */
    void ComputeLinGap(LINALG::Matrix<3 * numnodes * numnodalvalues + 3, 1, TYPE>& delta_gap,
        LINALG::Matrix<3 * numnodes * numnodalvalues + 3, 1, TYPE>& delta_xi,
        const LINALG::Matrix<3, 1, TYPE>& x1, const LINALG::Matrix<3, 1, TYPE>& x2,
        const LINALG::Matrix<3, 1, TYPE>& dx1,
        const LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i, const TYPE& normdist,
        const LINALG::Matrix<3, 1, TYPE>& normal, const TYPE& norm, const TYPE& gap,
        LINALG::Matrix<3, 3 * numnodes * numnodalvalues + 3, TYPE>& delta_x1_minus_x2);

    /*!
    \brief Compute linearization of normal
    */

    void ComputeLinNormal(LINALG::Matrix<3, 3 * numnodes * numnodalvalues + 3, TYPE>& delta_normal,
        const LINALG::Matrix<3 * numnodes * numnodalvalues + 3, 1, TYPE>& delta_xi,
        const LINALG::Matrix<3, 1, TYPE>& normal, const TYPE& norm_delta_x,
        const LINALG::Matrix<3, 1, TYPE>& x1_xi,
        const LINALG::Matrix<1, numnodes * numnodalvalues, TYPE>& N1_i);

    /*!
    \brief Compute normal contact disctance
    */
    void ComputeDistance(LINALG::Matrix<3, 1, TYPE>& distance, TYPE& normdist,
        const LINALG::Matrix<3, 1, TYPE>& normal, const TYPE& norm);

    /*!
    \brief Check if contact is active and set flag accordingly
    */
    void CheckAndSetContactStatus();

    //@}

   private:
    //! @name member variables

    //! first element of contact pair
    DRT::ELEMENTS::Beam3Base const* beam_element_;

    //! second element of contact pair
    DRT::ELEMENTS::Rigidsphere const* sphere_element_;

    //! current node coordinates of the two elements
    LINALG::Matrix<3 * numnodes * numnodalvalues, 1, TYPE> ele1pos_;
    LINALG::Matrix<3, 1, TYPE> ele2pos_;

    //! beam element arc-length in stress-free reference configuration
    double beamele_reflength_;

    //! Cross-section radius of beam
    double radius1_;

    //! Cross-section radius of sphere
    double radius2_;

    //! gap function
    TYPE gap_;

    //! flag indicating contact (active/inactive)
    bool contactflag_;

    //! flag indicating contact of beam end points (nodes) (active/inactive)
    std::vector<bool> nodalcontactflag_;

    //! resulting nodal contact forces on ele 1/2
    LINALG::Matrix<3 * numnodes * numnodalvalues, 1, TYPE> fc1_;
    LINALG::Matrix<3, 1, TYPE> fc2_;

    //! coordinates of contact point on center lines of beams
    LINALG::Matrix<3, 1, TYPE> x1_;
    LINALG::Matrix<3, 1, TYPE> x2_;

    //! parameter value of contact point on beam element
    TYPE xicontact_;

    //! normal vector of current time step
    LINALG::Matrix<3, 1, TYPE> normal_;

    //@}
  };
}  // namespace BEAMINTERACTION

#endif
