/*-----------------------------------------------------------*/
/*!
\file str_model_evaluator_structure.cpp

\brief Evaluation and assembly of all structure terms

\maintainer Michael Hiermeier

\date Aug 11, 2015

\level 3

*/
/*-----------------------------------------------------------*/

#include "str_model_evaluator_structure.H"
#include "str_model_evaluator_data.H"
#include "str_timint_base.H"
#include "str_utils.H"
#include "str_integrator.H"
#include "str_dbc.H"

#include <Epetra_Vector.h>
#include <Epetra_Time.h>
#include <Teuchos_ParameterList.hpp>

#include "../linalg/linalg_sparseoperator.H"
#include "../linalg/linalg_sparsematrix.H"
#include "../drt_lib/drt_dserror.H"
#include "../drt_lib/drt_discret.H"

#include "../drt_io/io.H"

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
STR::MODELEVALUATOR::Structure::Structure()
    : fintnp_ptr_(Teuchos::null),
      fextnp_ptr_(Teuchos::null),
      finertialnp_ptr_(Teuchos::null),
      fvisconp_ptr_(Teuchos::null),
      disnp_ptr_(Teuchos::null),
      stiff_ptr_(Teuchos::null),
      mass_ptr_(Teuchos::null),
      damp_ptr_(Teuchos::null),
      dt_ele_ptr_(NULL),
      masslin_type_(INPAR::STR::ml_none),
      dis_incr_ptr_(Teuchos::null)
{
  // empty
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::Setup()
{
  if (not IsInit())
    dserror("Init() has not been called, yet!");

  // get the global state content
  {
    // setup the internal forces and the external force pointers
    fintnp_ptr_ = GState().GetMutableFintNp();
    fextnp_ptr_ = GState().GetMutableFextNp();
    // setup the viscous force vector
    fvisconp_ptr_ = GState().GetMutableFviscoNp();
    // setup the inertial force vector
    finertialnp_ptr_ = GState().GetMutableFinertialNp();
    // setup the displacement pointer
    disnp_ptr_ = GState().GetMutableDisNp();
    // setup the dynamic matrix pointers
    mass_ptr_ = GState().GetMutableMassMatrix();
    damp_ptr_ = GState().GetMutableDampMatrix();
    // structural element evaluation time
    dt_ele_ptr_ =
        &(GState().GetMutableElementEvaluationTime());
  }
  // displ-displ block
  stiff_ptr_ = Teuchos::rcp(new LINALG::SparseMatrix(
      *GState().DofRowMapView(), 81, true, true));
  // get the structural dynamic content
  {
    // setup important evaluation booleans
    masslin_type_ = TimInt().GetDataSDyn().GetMassLinType();
  }
  // setup new variables
  {
    dis_incr_ptr_ = Teuchos::rcp(new Epetra_Vector(disnp_ptr_->Map(),true));
  }
  // set flag
  issetup_ = true;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::Reset(const Epetra_Vector& x)
{
  CheckInitSetup();

  /* --- reset external forces
   * Please note, that PutScalar is safer (but maybe slower) than
   * Scale(0.0), because of possible NaN and inf values! */
  fextnp_ptr_->PutScalar(0.0);

  /* --- reset internal forces
   * Please note, that PutScalar is safer (but maybe slower) than
   * Scale(0.0), because of possible NaN and inf values! */
  fintnp_ptr_->PutScalar(0.0);

  // reset stiffness matrix
  stiff_ptr_->Zero();

  // set evaluation time back to zero
  *dt_ele_ptr_ = 0.0;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
bool STR::MODELEVALUATOR::Structure::EvaluateForce()
{
  CheckInitSetup();
  bool ok = true;
  // ---------------------------------------
  // (1) EXTERNAL FORCES
  // ---------------------------------------
  ok = ApplyForceExternal();

  // ---------------------------------------
  // (2) INTERNAL FORCES
  // ---------------------------------------
  // ordinary internal force
  ok = (ok ? ApplyForceInternal() : false);

  return ok;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
bool STR::MODELEVALUATOR::Structure::EvaluateStiff()
{
  CheckInitSetup();
  bool ok = true;

  /* We use the same routines as for the ApplyForceStiff case, but we
   * do not update the global force vector, which is used for the
   * solution process in the NOX library.
   * This is meaningful, since the computational overhead, which is
   * generated by evaluating the right hand side is negligible */
  // *********** time measurement ***********
  double dtcpu = GState().GetTimer()->WallTime();
  // *********** time measurement ***********
  // ---------------------------------------------------------------------
  // (1) EXTRERNAL FORCES and STIFFNESS ENTRIES
  // ---------------------------------------------------------------------
  ok = ApplyForceStiffExternal();

  // ---------------------------------------------------------------------
  // (2) INTERNAL FORCES and STIFFNESS ENTRIES
  // ---------------------------------------------------------------------
  // ordinary internal force
  ok = (ok ? ApplyForceStiffInternal() : false);

  // *********** time measurement ***********
  *dt_ele_ptr_ +=
      GState().GetTimer()->WallTime() - dtcpu;
  // *********** time measurement ***********

  return ok;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
bool STR::MODELEVALUATOR::Structure::EvaluateForceStiff()
{
  CheckInitSetup();
  bool ok = true;

  // *********** time measurement ***********
  double dtcpu = GState().GetTimer()->WallTime();
  // *********** time measurement ***********
  // ---------------------------------------------------------------------
  // (1) EXTRERNAL FORCES and STIFFNESS ENTRIES
  // ---------------------------------------------------------------------
  ok = ApplyForceStiffExternal();

  // ---------------------------------------------------------------------
  // (2) INTERNAL FORCES and STIFFNESS ENTRIES
  // ---------------------------------------------------------------------
  // ordinary internal force
  ok = (ok ? ApplyForceStiffInternal() : false);

  // *********** time measurement ***********
  *dt_ele_ptr_ +=
      GState().GetTimer()->WallTime() - dtcpu;
  // *********** time measurement ***********

  // that's it
  return ok;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
bool STR::MODELEVALUATOR::Structure::AssembleForce(Epetra_Vector& f,
    const double & timefac_np) const
{
  STR::AssembleVector(1.0,f,-timefac_np,*fextnp_ptr_);
  STR::AssembleVector(1.0,f,timefac_np,*fintnp_ptr_);

  // add the scaled force contributions of the old time step
  // structural dofs of the right-hand-side vector at t_{n+timefac_n} (read-only)
  Teuchos::RCP<const Epetra_Vector> fstructold_ptr =
      GState().GetFstructureOld();
  STR::AssembleVector(1.0,f,1.0,*fstructold_ptr);

  return true;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
bool STR::MODELEVALUATOR::Structure::AssembleJacobian(
    LINALG::SparseOperator& jac,
    const double & timefac_np) const
{
  int err = stiff_ptr_->Scale(timefac_np);
  GState().AssignModelBlock(jac,*stiff_ptr_,Type(),STR::block_displ_displ);
  return (err==0);
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
bool STR::MODELEVALUATOR::Structure::InitializeInertiaAndDamping()
{
  CheckInitSetup();

  // currently a fixed number of matrix and vector pointers are supported
  Teuchos::RCP<Epetra_Vector> eval_vec [3] =
      {Teuchos::null,Teuchos::null,Teuchos::null};
  Teuchos::RCP<LINALG::SparseOperator> eval_mat[2] =
      {Teuchos::null,Teuchos::null};

  // create vector with zero entries
  Teuchos::RCP<const Epetra_Vector> zeros = Int().GetDbc().GetZerosPtr();

  // set vector values needed by elements
  // --> initially zero !!!
  Discret().ClearState();
  Discret().SetState(0,"residual displacement", zeros);
  Discret().SetState(0,"displacement", zeros);

  // set action type and evaluation matrix and vector pointers
  StaticContributions(&eval_mat[0],&eval_vec[0]);
  MaterialDampingContributions(&eval_mat[0]);
  InertialContributions(&eval_mat[0],&eval_vec[0]);

  // evaluate
  EvaluateInternal(&eval_mat[0],&eval_vec[0]);

  // complete stiffness and mass matrix
  FillComplete();

  // assemble the rayleigh damping matrix
  RayleighDampingMatrix();

  return EvalErrorCheck();
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
bool STR::MODELEVALUATOR::Structure::ApplyForceInternal()
{
  CheckInitSetup();

  // currently a fixed number of matrix and vector pointers are supported
  Teuchos::RCP<Epetra_Vector> eval_vec [3] =
      {Teuchos::null,Teuchos::null,Teuchos::null};
  Teuchos::RCP<LINALG::SparseOperator> eval_mat[2] =
      {Teuchos::null,Teuchos::null};

  // set vector values needed by elements
  Discret().ClearState();
  Discret().SetState(0,"residual displacement", dis_incr_ptr_);
  Discret().SetState(0,"displacement", disnp_ptr_);

  // set action type and evaluation matrix and vector pointers
  StaticContributions(&eval_vec[0]);
  MaterialDampingContributions(&eval_mat[0]);
  if (masslin_type_!=INPAR::STR::ml_none)
    InertialContributions(&eval_vec[0]);

  // evaluate ...
  EvaluateInternal(&eval_mat[0],&eval_vec[0]);

  // evaluate inertia and visco forces
  InertialAndViscousForces();

  return EvalErrorCheck();
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
bool STR::MODELEVALUATOR::Structure::ApplyForceExternal()
{
  CheckInitSetup();

  // Set to default value, because it is unnecessary for the
  // EvaluateNeumann routine.
  EvalData().SetActionType(DRT::ELEMENTS::none);
  // set vector values needed by elements
  Discret().ClearState();
  Discret().SetState(0, "displacement", GState().GetDisN());
  if (EvalData().GetDampingType() == INPAR::STR::damp_material)
    Discret().SetState(0,"velocity", GState().GetVelN());
  Discret().SetState(0, "displacement new", disnp_ptr_);
  EvaluateNeumann(fextnp_ptr_,Teuchos::null);

  return EvalErrorCheck();
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
bool STR::MODELEVALUATOR::Structure::ApplyForceStiffExternal()
{
  CheckInitSetup();

  // set vector values needed by elements
  Discret().ClearState();
  Discret().SetState(0,"displacement",GState().GetDisN());

  if (EvalData().GetDampingType() == INPAR::STR::damp_material)
    Discret().SetState(0,"velocity", GState().GetVelN());

  // get load vector
  if (!TimInt().GetDataSDyn().GetLoadLin())
    EvaluateNeumann(fextnp_ptr_,Teuchos::null);
  else
  {
    Discret().SetState(0,"displacement new", disnp_ptr_);
    /* Add the linearization of the external force to the stiffness
     * matrix. */
    EvaluateNeumann(fextnp_ptr_,stiff_ptr_);
  }

  return EvalErrorCheck();
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
bool STR::MODELEVALUATOR::Structure::ApplyForceStiffInternal()
{
  CheckInitSetup();
  // currently a fixed number of matrix and vector pointers are supported
  Teuchos::RCP<Epetra_Vector> eval_vec [3] =
      {Teuchos::null,Teuchos::null,Teuchos::null};
  Teuchos::RCP<LINALG::SparseOperator> eval_mat[2] =
       {Teuchos::null,Teuchos::null};

  // set vector values needed by elements
  Discret().ClearState();
  Discret().SetState(0,"residual displacement", dis_incr_ptr_);
  Discret().SetState(0,"displacement", disnp_ptr_);

  // set action types and evaluate matrices/vectors
  StaticContributions(&eval_mat[0],&eval_vec[0]);
  MaterialDampingContributions(&eval_mat[0]);
  if (masslin_type_!=INPAR::STR::ml_none)
    InertialContributions(&eval_mat[0],&eval_vec[0]);

  // evaluate
  EvaluateInternal(&eval_mat[0],&eval_vec[0]);

  // complete stiffness and mass matrix
  FillComplete();

  // evaluate inertial and viscous forces
  InertialAndViscousForces();

  return EvalErrorCheck();
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::StaticContributions(
    Teuchos::RCP<LINALG::SparseOperator>* eval_mat,
    Teuchos::RCP<Epetra_Vector>* eval_vec)
{
  // action for elements
  EvalData().SetActionType(DRT::ELEMENTS::struct_calc_nlnstiff);
  // set default matrix
  eval_mat[0] = stiff_ptr_;
  // set default force vector
  eval_vec[0] = fintnp_ptr_;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::StaticContributions(
    Teuchos::RCP<Epetra_Vector>* eval_vec)
{
  // action for elements
  EvalData().SetActionType(DRT::ELEMENTS::struct_calc_internalforce);
  // set default force vector
  eval_vec[0] = fintnp_ptr_;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::MaterialDampingContributions(
    Teuchos::RCP<LINALG::SparseOperator>* eval_mat)
{
  if (EvalData().GetDampingType()!=INPAR::STR::damp_material)
    return;

  // action for elements
  // (reset the action type to be independent of the calling order)
  EvalData().SetActionType(DRT::ELEMENTS::struct_calc_nlnstiff);
  // set the discretization state
  Discret().SetState(0,"velocity", GState().GetVelNp());
  // reset damping matrix
  damp_ptr_->Zero();
  // add the stiffness matrix as well (also for the ApplyForce case!)
  eval_mat[0] = stiff_ptr_;
  // set damping matrix
  eval_mat[1] = damp_ptr_;

  return;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::InertialContributions(
    Teuchos::RCP<LINALG::SparseOperator>* eval_mat,
    Teuchos::RCP<Epetra_Vector>* eval_vec)
{
  CheckInitSetup();

  // overwrite element action
  if (TimInt().GetDataSDyn().IsMassLumping())
    EvalData().SetActionType(DRT::ELEMENTS::struct_calc_nlnstifflmass);
  else
    EvalData().SetActionType(DRT::ELEMENTS::struct_calc_nlnstiffmass);

  // set the discretization state
  Discret().SetState(0,"velocity", GState().GetVelNp());
  Discret().SetState(0,"acceleration", GState().GetAccNp());
  // reset the mass matrix
  mass_ptr_->Zero();
  // set mass matrix
  eval_mat[1] = mass_ptr_;
  // set inertial vector if necessary
  eval_vec[1] = GetInertialForce();

  return;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::InertialContributions(
    Teuchos::RCP<Epetra_Vector>* eval_vec)
{
  CheckInitSetup();

  // overwrite element action
  EvalData().SetActionType(DRT::ELEMENTS::struct_calc_internalinertiaforce);
  // set the discretization state
  Discret().SetState(0,"velocity", GState().GetVelNp());
  Discret().SetState(0,"acceleration", GState().GetAccNp());

  // set inertial vector if necessary
  eval_vec[1] = GetInertialForce();

  return;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::InertialAndViscousForces()
{
  CheckInitSetup();

  if (masslin_type_==INPAR::STR::ml_none)
  {
    // calculate the inertial force at t_{n+1}
    mass_ptr_->Multiply(false,
        *GState().GetAccNp(),*finertialnp_ptr_);
  }

  // calculate the viscous/damping force at t_{n+1}
  if (EvalData().GetDampingType()!=INPAR::STR::damp_none)
  {
    if (not damp_ptr_->Filled())
      damp_ptr_->Complete();
    damp_ptr_->Multiply(false,
        *GState().GetVelNp(),*fvisconp_ptr_);
  }
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::FillComplete()
{
  if (not stiff_ptr_->Filled())
    stiff_ptr_->Complete();

  if (not mass_ptr_->Filled())
    mass_ptr_->Complete();
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::RayleighDampingMatrix()
{
  if (EvalData().GetDampingType()!=INPAR::STR::damp_rayleigh)
    return;

  const double& dampk =
      TimInt().GetDataSDyn().GetDampingStiffnessFactor();
  const double& dampm =
      TimInt().GetDataSDyn().GetDampingMassFactor();

  // damping matrix with initial stiffness
  damp_ptr_->Add(*stiff_ptr_,false,dampk,0.0);
  damp_ptr_->Add(*mass_ptr_,false,dampm,1.0);
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
Teuchos::RCP<Epetra_Vector> STR::MODELEVALUATOR::Structure::GetInertialForce()
{
  switch (masslin_type_)
  {
    case INPAR::STR::ml_rotations:
    case INPAR::STR::ml_standard:
    {
      finertialnp_ptr_->PutScalar(0.0);
      // set inertial force
      return finertialnp_ptr_;
      break;
    }
    case INPAR::STR::ml_none:
      // do nothing
      break;
    default:
      dserror("Unknown mass linearization type!");
      exit(EXIT_FAILURE);
  }

  return Teuchos::null;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::EvaluateInternal(
    Teuchos::RCP<LINALG::SparseOperator>* eval_mat,
    Teuchos::RCP<Epetra_Vector>* eval_vec)
{
  PreEvaluateInternal();

  Teuchos::ParameterList p;
  p.set<Teuchos::RCP<DRT::ELEMENTS::ParamsInterface> >("interface",
      EvalDataPtr());

  EvaluateInternal(p,eval_mat,eval_vec);
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::EvaluateInternal(
    Teuchos::ParameterList& p,
    Teuchos::RCP<LINALG::SparseOperator>* eval_mat,
    Teuchos::RCP<Epetra_Vector>* eval_vec)
{
  if (p.numParams()>1)
    dserror("Please use the STR::ELEMENTS::Interface and its derived "
        "classes to set and get parameters.");
  if (not p.INVALID_TEMPLATE_QUALIFIER
        isType< Teuchos::RCP<DRT::ELEMENTS::ParamsInterface> > ("interface"))
    dserror("The given parameter has the wrong type!");
  Discret().Evaluate(p, eval_mat[0], eval_mat[1],
      eval_vec[0], eval_vec[1], eval_vec[2]);
  Discret().ClearState();
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::EvaluateNeumann(
    Teuchos::RCP<Epetra_Vector> eval_vec,
    Teuchos::RCP<LINALG::SparseOperator> eval_mat)
{
  Teuchos::ParameterList p;
  p.set<Teuchos::RCP<DRT::ELEMENTS::ParamsInterface> >("interface",
      EvalDataPtr());
  EvaluateNeumann(p,eval_vec,eval_mat);
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::EvaluateNeumann(
    Teuchos::ParameterList& p,
    Teuchos::RCP<Epetra_Vector> eval_vec,
    Teuchos::RCP<LINALG::SparseOperator> eval_mat)
{
  if (p.numParams()>1)
    dserror("Please use the STR::ELEMENTS::Interface and its derived "
        "classes to set and get parameters.");
  if (not p.INVALID_TEMPLATE_QUALIFIER
        isType< Teuchos::RCP<DRT::ELEMENTS::ParamsInterface> > ("interface"))
    dserror("The given parameter has the wrong type!");
  Discret().EvaluateNeumann(p,eval_vec,eval_mat);
  Discret().ClearState();
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::WriteRestart(
    IO::DiscretizationWriter& iowriter,
    const bool& forced_writerestart) const
{
  // write forces
  iowriter.WriteVector("fstructure_old",GState().GetFstructureOld());

  if (forced_writerestart)
    return;

  iowriter.WriteVector("displacement",GState().GetDisN());
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::ReadRestart(
    IO::DiscretizationReader& ioreader)
{
  CheckInitSetup();
  // read structural force vector
  ioreader.ReadVector(GState().GetMutableFstructureOld(),"fstructure_old");
  // read displacement field
  Teuchos::RCP<Epetra_Vector>& disnp = GState().GetMutableDisNp();
  ioreader.ReadVector(disnp,"displacement");
  GState().GetMutableMultiDis()->UpdateSteps(*disnp);
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::RecoverState(
    const Epetra_Vector& xold,
    const Epetra_Vector& dir,
    const Epetra_Vector& xnew)
{
  CheckInitSetup();
  Reset(xnew);
  /* set the class internal displacement increment vector. Check if it is
   * meaningful/necessary in some cases, like incremental strains etc. */
  dis_incr_ptr_ = GState().ExtractDisplEntries(dir);
  // set vector values needed by elements
  Discret().ClearState();
  Discret().SetState(0,"residual displacement",dis_incr_ptr_);
  Discret().SetState(0,"displacement",disnp_ptr_);
  // set the element action
  EvalData().SetActionType(DRT::ELEMENTS::struct_calc_recover);
  // set the matrix and vector pointers to Teuchos::null
  Teuchos::RCP<Epetra_Vector> eval_vec [3] =
      {Teuchos::null,Teuchos::null,Teuchos::null};
  Teuchos::RCP<LINALG::SparseOperator> eval_mat[2] =
      {Teuchos::null,Teuchos::null};

  EvaluateInternal(eval_mat,eval_vec);
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::UpdateStepState(
    const double& timefac_n)
{
  CheckInitSetup();
  // update state
  // new displacements at t_{n+1} -> t_n
  //    D_{n} := D_{n+1}
  GState().GetMutableMultiDis()->UpdateSteps(*disnp_ptr_);

  // new velocities at t_{n+1} -> t_{n}
  //    V_{n} := V_{n+1}
  GState().GetMutableMultiVel()->UpdateSteps(*GState().GetVelNp());

  // new at t_{n+1} -> t_n
  //    A_{n} := A_{n+1}
  GState().GetMutableMultiAcc()->UpdateSteps(*GState().GetAccNp());

  // new at t_{n+1} -> t_{n+timefac_n}
  //    F^{struct}_{n+timefac_n} := timefac_n * F^{struct}_{n+1}
  Teuchos::RCP<Epetra_Vector>& fstructold_ptr =
      GState().GetMutableFstructureOld();
  fstructold_ptr->Update(timefac_n,*fintnp_ptr_,1.0);
  fstructold_ptr->Update(-timefac_n,*fextnp_ptr_,1.0);

  // set the displacement increment back to zero
  dis_incr_ptr_->Scale(0.0);
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::UpdateStepElement()
{
  CheckInitSetup();
  // other parameters that might be needed by the elements
  EvalData().SetTotalTime(GState().GetTimeNp());
  EvalData().SetDeltaTime((*GState().GetDeltaTime())[0]);
  // action for elements
  EvalData().SetActionType(DRT::ELEMENTS::struct_calc_update_istep);
  // go to elements
  Discret().ClearState();
  Discret().SetState("displacement",GState().GetDisN());

  // set dummy evaluation vectors and matrices
  Teuchos::RCP<Epetra_Vector> eval_vec [3] =
      {Teuchos::null,Teuchos::null,Teuchos::null};
  Teuchos::RCP<LINALG::SparseOperator> eval_mat[2] =
      {Teuchos::null,Teuchos::null};
  EvaluateInternal(eval_mat,eval_vec);
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::DetermineStressStrain()
{
  CheckInitSetup();

  if (GInOutput().GetStressOutputType() == INPAR::STR::stress_none and
      GInOutput().GetCouplingStressOutputType() == INPAR::STR::stress_none and
      GInOutput().GetStrainOutputType() == INPAR::STR::strain_none and
      GInOutput().GetPlasticStrainOutputType() == INPAR::STR::strain_none)
    return;

  // set all parameters in the evaluation data container
  EvalData().SetActionType(DRT::ELEMENTS::struct_calc_stress);
  EvalData().SetTotalTime(GState().GetTimeNp());
  EvalData().SetDeltaTime((*GState().GetDeltaTime())[0]);
  EvalData().SetStressData(Teuchos::rcp(new std::vector<char>()));
  EvalData().SetStrainData(Teuchos::rcp(new std::vector<char>()));
  EvalData().SetPlasticStrainData(Teuchos::rcp(new std::vector<char>()));

  // set vector values needed by elements
  Discret().ClearState();
  Discret().SetState(0,"displacement",GState().GetDisNp());
  Discret().SetState(0,"residual displacement", dis_incr_ptr_);

  // set dummy evaluation vectors and matrices
  Teuchos::RCP<Epetra_Vector> eval_vec [3] =
      {Teuchos::null,Teuchos::null,Teuchos::null};
  Teuchos::RCP<LINALG::SparseOperator> eval_mat[2] =
      {Teuchos::null,Teuchos::null};

  EvaluateInternal(eval_mat,eval_vec);
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::DetermineEnergy()
{
  CheckInitSetup();
  dserror("Not yet implemented!");
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::OutputStepState(
    IO::DiscretizationWriter& iowriter) const
{
  CheckInitSetup();

  // write output every iteration for debug purposes
  if (GInOutput().IsOutputEveryIter())
  {
    iowriter.WriteVector("displacement",GState().GetDisNp());
    /* for visualization of vel and acc do not forget to comment in
     * corresponding lines in StructureEnsightWriter */
    if (GInOutput().IsWriteVelAcc())
    {
      iowriter.WriteVector("velocity", GState().GetVelNp());
      iowriter.WriteVector("acceleration", GState().GetAccNp());
    }
    return;
  }
  else
  {
    // write default output...
    iowriter.WriteVector("displacement", GState().GetDisN());

    /* for visualization of vel and acc do not forget to comment in
     * corresponding lines in StructureEnsightWriter */
    if (GInOutput().IsWriteVelAcc())
    {
      iowriter.WriteVector("velocity", GState().GetVelN());
      iowriter.WriteVector("acceleration", GState().GetAccN());
    }
  }
  return;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::ResetStepState()
{
  CheckInitSetup();

  // reset disp, vel, acc state vector
  GStatePtr()->GetMutableDisNp()->Update(1.0, (*GStatePtr()->GetDisN()), 0.0);
  GStatePtr()->GetMutableVelNp()->Update(1.0, (*GStatePtr()->GetVelN()), 0.0);
  GStatePtr()->GetMutableAccNp()->Update(1.0, (*GStatePtr()->GetAccN()), 0.0);

  // other parameters that might be needed by the elements
  EvalData().SetTotalTime(GState().GetTimeNp());
  EvalData().SetDeltaTime((*GState().GetDeltaTime())[0]);
  // action for elements
  EvalData().SetActionType(DRT::ELEMENTS::struct_calc_reset_istep);

  // set dummy evaluation vectors and matrices
  Teuchos::RCP<Epetra_Vector> eval_vec [3] =
      {Teuchos::null,Teuchos::null,Teuchos::null};
  Teuchos::RCP<LINALG::SparseOperator> eval_mat[2] =
      {Teuchos::null,Teuchos::null};
  EvaluateInternal(eval_mat,eval_vec);

  DiscretPtr()->ClearState();

  return;
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
Teuchos::RCP<const Epetra_Map> STR::MODELEVALUATOR::Structure::
    GetBlockDofRowMapPtr() const
{
  CheckInitSetup();
  return GState().DofRowMap();
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
Teuchos::RCP<const Epetra_Vector> STR::MODELEVALUATOR::Structure::
    GetCurrentSolutionPtr() const
{
  CheckInit();
  return GState().GetDisNp();
}

/*----------------------------------------------------------------------------*
 *----------------------------------------------------------------------------*/
Teuchos::RCP<const Epetra_Vector> STR::MODELEVALUATOR::Structure::
    GetLastTimeStepSolutionPtr() const
{
  CheckInit();
  return GState().GetDisN();
}

/*----------------------------------------------------------------------*
 *----------------------------------------------------------------------*/
void STR::MODELEVALUATOR::Structure::PostOutput()
{
  CheckInitSetup();
 // empty

  return;
} // PostOutput()
