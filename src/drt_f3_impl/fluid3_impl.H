/*!
\file fluid3_impl.H

\brief Internal implementation of Fluid3 element

<pre>
Maintainer: Volker Gravemeier / Andreas Ehrl
            vgravem@lnm.mw.tum.de
            ehrl@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15245
</pre>
*/

#ifdef D_FLUID3
#ifdef CCADISCRET

#ifndef FLUID3_IMPL_H
#define FLUID3_IMPL_H

#include "fluid3_interface.H"
#include "../drt_fluid/fluid_rotsym_periodicbc.H"
#include "../drt_lib/drt_utils.H"

namespace DRT
{
namespace ELEMENTS
{

  /// Internal Fluid3 implementation
  /*!
    This internal class keeps all the working arrays needed to
    calculate the Fluid3 element. Additionally the method Sysmat()
    provides a clean and fast element implementation.

    <h3>Purpose</h3>

    The idea is to separate the element maintenance (class Fluid3) from the
    mathematical contents (this class). There are different implementations of
    the Fluid3 element, this is just one such implementation.

    The Fluid3 will allocate exactly one object of this class for all
    fluid elements with the same number of nodes in the mesh. This
    allows us to use exactly matching working arrays (and keep them
    around.)

    The code is meant to be as clean as possible. This is the only way
    to keep it fast. The number of working arrays has to be reduced to
    a minimum so that the element fits into the cache. (There might be
    room for improvements.)

    <h3>Usability</h3>

    The calculations are done by the Evaluate() method. There are two
    version. The virtual method that is inherited from Fluid3ImplInterface
    (and called from Fluid3) and the non-virtual one that does the actual
    work. The non-virtual Evaluate() method must be callable without an actual
    Fluid3 object.

    <h3>History</h3>

    The implementation here is based on the work by Christiane
    Foerster. The core element code has been linearized using MuPAD.
    The reaction terms have been removed from the lhs.

    \author u.kue
    \date 07/07
  */
  template<DRT::Element::DiscretizationType distype>
  class Fluid3Impl : public Fluid3ImplInterface
  {
    friend class Fluid3ImplParameter;

    /// private Constructor since we are a Singleton.
    Fluid3Impl();

  public:

    virtual ~Fluid3Impl() {}

    /// Singleton access method
    static Fluid3Impl<distype> * Instance( bool create=true );

    //! nen_: number of element nodes (P. Hughes: The Finite Element Method)
    static const int nen_ = DRT::UTILS::DisTypeToNumNodePerEle<distype>::numNodePerElement;

    //! number of space dimensions
    static const int nsd_ = DRT::UTILS::DisTypeToDim<distype>::dim;

    static const int numdofpernode_ = nsd_+1;

    /// called upon destruction
    virtual void Done();

    virtual int IntegrateShapeFunction(
        DRT::ELEMENTS::Fluid3*    ele,
        DRT::Discretization&      discretization,
        vector<int>&              lm            ,
        Epetra_SerialDenseVector& elevec1       );

    /// Evaluate element ERROR
    /*!
        general function to compute the error (analytical solution) for particular problem type
     */

    virtual int ComputeError(
        DRT::ELEMENTS::Fluid3*          ele,
        ParameterList&                  params,
        Teuchos::RCP<MAT::Material>&    mat,
        DRT::Discretization&            discretization,
        vector<int>&                    lm,
        Epetra_SerialDenseVector&       elevec1);


    virtual int ComputeErrorXFEM(
        DRT::ELEMENTS::Fluid3*          ele,
        ParameterList&                  params,
        Teuchos::RCP<MAT::Material>&    mat,
        DRT::Discretization&            discretization,
        vector<int>&                    lm,
        Epetra_SerialDenseVector&       elevec);

    virtual int ComputeErrorXFEM(
        DRT::ELEMENTS::Fluid3*          ele,
        ParameterList&                  params,
        Teuchos::RCP<MAT::Material>&    mat,
        DRT::Discretization&            discretization,
        vector<int>&                    lm,
        Epetra_SerialDenseVector&       elevec1,
        const DRT::UTILS::GaussIntegration & intpoints2);

    /// Evaluate the element
    /*!
      Generic virtual interface function. Called via base pointer.
     */
    virtual int Evaluate(DRT::ELEMENTS::Fluid3*        ele,
                         DRT::Discretization &         discretization,
                         const std::vector<int> &      lm,
                         Teuchos::ParameterList&       params,
                         Teuchos::RCP<MAT::Material> & mat,
                         Epetra_SerialDenseMatrix&     elemat1_epetra,
                         Epetra_SerialDenseMatrix&     elemat2_epetra,
                         Epetra_SerialDenseVector&     elevec1_epetra,
                         Epetra_SerialDenseVector&     elevec2_epetra,
                         Epetra_SerialDenseVector&     elevec3_epetra );

    /// Evaluate the element at specified gauss points
    virtual int Evaluate(DRT::ELEMENTS::Fluid3*               ele,
                         DRT::Discretization &                discretization,
                         const std::vector<int> &             lm,
                         Teuchos::ParameterList&              params,
                         Teuchos::RCP<MAT::Material> &        mat,
                         Epetra_SerialDenseMatrix&            elemat1_epetra,
                         Epetra_SerialDenseMatrix&            elemat2_epetra,
                         Epetra_SerialDenseVector&            elevec1_epetra,
                         Epetra_SerialDenseVector&            elevec2_epetra,
                         Epetra_SerialDenseVector&            elevec3_epetra,
                         const DRT::UTILS::GaussIntegration & intpoints );

    /*!
      \brief evaluate function for Fluid3 element

      Specific evaluate function without any knowledge about DRT objects. This
      way the element evaluation is independent of the specific mesh storage.
     */
    int Evaluate(int                                           eid,
                 Teuchos::ParameterList&                       params,
                 const LINALG::Matrix<nsd_,nen_> &             ebofoaf,
                 const LINALG::Matrix<nsd_,nen_> &             eprescpgaf,
                 LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_> & elemat1,
                 LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_> & elemat2,
                 LINALG::Matrix<(nsd_+1)*nen_,            1> & elevec1,
                 const LINALG::Matrix<nsd_,nen_> &             evelaf,
                 const LINALG::Matrix<nen_,1>    &             epreaf,
                 const LINALG::Matrix<nsd_,nen_> &             evelnp,
                 const LINALG::Matrix<nen_,1>    &             escaaf,
                 const LINALG::Matrix<nsd_,nen_> &             emhist,
                 const LINALG::Matrix<nsd_,nen_> &             eaccam,
                 const LINALG::Matrix<nen_,1>    &             escadtam,
                 const LINALG::Matrix<nen_,1>    &             escabofoaf,
                 const LINALG::Matrix<nsd_,nen_> &             eveln,
                 const LINALG::Matrix<nen_,1>    &             escaam,
                 const LINALG::Matrix<nsd_,nen_> &             edispnp,
                 const LINALG::Matrix<nsd_,nen_> &             egridv,
                 const LINALG::Matrix<nsd_,nen_> &             fsevelaf,
                 const LINALG::Matrix<nsd_,nen_> &             evel_hat,
                 const LINALG::Matrix<nsd_*nsd_,nen_> &        ereynoldsstress_hat,
                 const LINALG::Matrix<nen_,1> &                eporo,
                 Teuchos::RCP<MAT::Material>                   mat,
                 bool                                          isale,
                 bool                                          isowned,
                 double                                        CsDeltaSq,
                 double *                                      saccn,
                 double *                                      sveln,
                 double *                                      svelnp,
                 const DRT::UTILS::GaussIntegration &          intpoints);

    virtual int CalcDissipation(Fluid3*                    ele,
                                ParameterList&             params,
                                DRT::Discretization&       discretization,
                                vector<int>&               lm,
                                RefCountPtr<MAT::Material> mat);

    virtual void ElementXfemInterface( DRT::ELEMENTS::Fluid3 * ele,
                                       DRT::Discretization & dis,
                                       const std::vector<int> & lm,
                                       const DRT::UTILS::GaussIntegration & intpoints,
                                       DRT::Discretization & cutdis,
                                       const std::map<int, std::vector<GEO::CUT::BoundaryCell*> > & bcells,
                                       const std::map<int, std::vector<DRT::UTILS::GaussIntegration> > & cutintpoints,
                                       std::map<int, std::vector<Epetra_SerialDenseMatrix> > & side_coupling,
                                       //std::map<int, std::vector<RCP<Epetra_SerialDenseMatrix> > > side_coupling,
                                       Teuchos::ParameterList&    params,
                                       Epetra_SerialDenseMatrix&  elemat1_epetra,
                                       Epetra_SerialDenseVector&  elevec1_epetra,
                                       Epetra_SerialDenseMatrix&  Cuiui
      );

    virtual void ElementXfemInterfaceNitsche( DRT::ELEMENTS::Fluid3 * ele,
                                       DRT::Discretization & dis,
                                       const std::vector<int> & lm,
                                       const DRT::UTILS::GaussIntegration & intpoints,
                                       DRT::Discretization & cutdis,
                                       const std::map<int, std::vector<GEO::CUT::BoundaryCell*> > & bcells,
                                       const std::map<int, std::vector<DRT::UTILS::GaussIntegration> > & cutintpoints,
                                       std::map<int, std::vector<Epetra_SerialDenseMatrix> > & side_coupling,
                                       //std::map<int, std::vector<RCP<Epetra_SerialDenseMatrix> > > side_coupling,
                                       Teuchos::ParameterList&    params,
                                       Epetra_SerialDenseMatrix&  elemat1_epetra,
                                       Epetra_SerialDenseVector&  elevec1_epetra,
                                       Epetra_SerialDenseMatrix&  Cuiui
      );

    virtual void ElementXfemInterfaceNitscheTwoSided( DRT::ELEMENTS::Fluid3 * ele,
                                       DRT::Discretization & dis,
                                       const std::vector<int> & lm,
                                       const DRT::UTILS::GaussIntegration & intpoints,
                                       DRT::Discretization & cutdis,
                                       const std::map<int, std::vector<GEO::CUT::BoundaryCell*> > & bcells,
                                       const std::map<int, std::vector<DRT::UTILS::GaussIntegration> > & cutintpoints,
                                       std::map<int, std::vector<Epetra_SerialDenseMatrix> > & side_coupling,
                                       //std::map<int, std::vector<RCP<Epetra_SerialDenseMatrix> > > side_coupling,
                                       Teuchos::ParameterList&    params,
                                       DRT::Discretization & alediscret,
                                       map<int,int> & boundary_emb_gid_map,
                                       Epetra_SerialDenseMatrix&  elemat1_epetra,
                                       Epetra_SerialDenseVector&  elevec1_epetra,
                                       Epetra_SerialDenseMatrix&  Cuiui
      );
//
//    virtual void ElementXfemInterfaceNeumann( DRT::ELEMENTS::Fluid3 * ele,
//                                       DRT::Discretization & dis,
//                                       const std::vector<int> & lm,
//                                       const DRT::UTILS::GaussIntegration & intpoints,
//                                       DRT::Discretization & cutdis,
//                                       const std::map<int, std::vector<GEO::CUT::BoundaryCell*> > & bcells,
//                                       const std::map<int, std::vector<DRT::UTILS::GaussIntegration> > & cutintpoints,
//                                       std::map<int, std::vector<Epetra_SerialDenseMatrix> > & side_coupling,
//                                       //std::map<int, std::vector<RCP<Epetra_SerialDenseMatrix> > > side_coupling,
//                                       Teuchos::ParameterList&    params,
//                                       Epetra_SerialDenseMatrix&  elemat1_epetra,
//                                       Epetra_SerialDenseVector&  elevec1_epetra,
//                                       Epetra_SerialDenseMatrix&  Cuiui
//      );

    /// Evaluate the element for porous flow
    /*!
      Generic virtual interface function. Called via base pointer.
     */
    virtual int PoroEvaluate(DRT::ELEMENTS::Fluid3*        ele,
                             DRT::Discretization &         discretization,
                             const std::vector<int> &      lm,
                             Teuchos::ParameterList&       params,
                             Teuchos::RCP<MAT::Material> & mat,
                             Epetra_SerialDenseMatrix&     elemat1_epetra,
                             Epetra_SerialDenseMatrix&     elemat2_epetra,
                             Epetra_SerialDenseVector&     elevec1_epetra,
                             Epetra_SerialDenseVector&     elevec2_epetra,
                             Epetra_SerialDenseVector&     elevec3_epetra );

    /// Evaluate the element at specified gauss points for porous flow
    virtual int PoroEvaluate(DRT::ELEMENTS::Fluid3*               ele,
                             DRT::Discretization &                discretization,
                             const std::vector<int> &             lm,
                             Teuchos::ParameterList&              params,
                             Teuchos::RCP<MAT::Material> &        mat,
                             Epetra_SerialDenseMatrix&            elemat1_epetra,
                             Epetra_SerialDenseMatrix&            elemat2_epetra,
                             Epetra_SerialDenseVector&            elevec1_epetra,
                             Epetra_SerialDenseVector&            elevec2_epetra,
                             Epetra_SerialDenseVector&            elevec3_epetra,
                             const DRT::UTILS::GaussIntegration & intpoints );

    /*!
      \brief evaluate function for Fluid3 element for porous flow

      Specific evaluate function without any knowledge about DRT objects. This
      way the element evaluation is independent of the specific mesh storage.
     */
    int PoroEvaluate(int                                           eid,
                     Teuchos::ParameterList&                       params,
                     const LINALG::Matrix<nsd_,nen_> &             ebofoaf,
                     LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_> & elemat1,
                     LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_> & elemat2,
                     LINALG::Matrix<(nsd_+1)*nen_,            1> & elevec1,
                     const LINALG::Matrix<nsd_,nen_> &             evelaf,
                     const LINALG::Matrix<nen_,1>    &             epreaf,
                     const LINALG::Matrix<nsd_,nen_> &             evelnp,
                     const LINALG::Matrix<nsd_,nen_> &             emhist,
                     const LINALG::Matrix<nen_,1>    &             epren,
                     const LINALG::Matrix<nen_,1>    &             epressn_timederiv,
                     const LINALG::Matrix<nen_,1>    &             epressnp_timederiv,
                     const LINALG::Matrix<nsd_,nen_> &             eaccam,
                     const LINALG::Matrix<nsd_,nen_> &             edispnp,
                     const LINALG::Matrix<nsd_,nen_> &             edispn,
                     const LINALG::Matrix<nsd_,nen_> &             egridv,
                     Teuchos::RCP<MAT::Material>                   mat,
                     bool                                          isale,
                     const DRT::UTILS::GaussIntegration &          intpoints);

    /// Evaluate the element for porous flow
    /*!
      Generic virtual interface function. Called via base pointer.
     */
    virtual int PoroEvaluateCoupl(DRT::ELEMENTS::Fluid3*        ele,
                             DRT::Discretization &         discretization,
                             const std::vector<int> &      lm,
                             Teuchos::ParameterList&       params,
                             Teuchos::RCP<MAT::Material> & mat,
                             Epetra_SerialDenseMatrix&     elemat1_epetra,
                             Epetra_SerialDenseMatrix&     elemat2_epetra,
                             Epetra_SerialDenseVector&     elevec1_epetra,
                             Epetra_SerialDenseVector&     elevec2_epetra,
                             Epetra_SerialDenseVector&     elevec3_epetra );

    /// Evaluate the element at specified gauss points for porous flow
    virtual int PoroEvaluateCoupl(DRT::ELEMENTS::Fluid3*               ele,
                             DRT::Discretization &                discretization,
                             const std::vector<int> &             lm,
                             Teuchos::ParameterList&              params,
                             Teuchos::RCP<MAT::Material> &        mat,
                             Epetra_SerialDenseMatrix&            elemat1_epetra,
                             Epetra_SerialDenseMatrix&            elemat2_epetra,
                             Epetra_SerialDenseVector&            elevec1_epetra,
                             Epetra_SerialDenseVector&            elevec2_epetra,
                             Epetra_SerialDenseVector&            elevec3_epetra,
                             const DRT::UTILS::GaussIntegration & intpoints );

    /*!
      \brief evaluate function for Fluid3 element for porous flow

      Specific evaluate function without any knowledge about DRT objects. This
      way the element evaluation is independent of the specific mesh storage.
     */
    int PoroEvaluateCoupl(  int                                           eid,
							Teuchos::ParameterList&                       params,
							const LINALG::Matrix<nsd_,nen_> &             edeadaf,
							LINALG::Matrix<(nsd_+1)*nen_,nsd_*nen_>      & elemat1,
						 //   LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_> & elemat2,
							LINALG::Matrix<(nsd_+1)*nen_,            1> & elevec1,
							const LINALG::Matrix<nsd_,nen_> &             evelaf,
							const LINALG::Matrix<nen_,1>    &             epreaf,
							const LINALG::Matrix<nsd_,nen_> &             evelnp,
							const LINALG::Matrix<nsd_,nen_> &             emhist,
							const LINALG::Matrix<nen_,1>    &             epren,
							const LINALG::Matrix<nen_,1>    &             epressnp_timederiv,
							const LINALG::Matrix<nsd_,nen_> &             eaccam,
							const LINALG::Matrix<nsd_,nen_> &             edispnp,
							const LINALG::Matrix<nsd_,nen_> &             edispn,
							const LINALG::Matrix<nsd_,nen_> &             egridv,
							Teuchos::RCP<MAT::Material>                   mat,
							bool                                          isale,
							const DRT::UTILS::GaussIntegration &          intpoints);

    /// evaluation of off-diagonal matrix block for monolithic loma solver
    /*!
      Generic virtual interface function. Called via base pointer.
     */
    virtual int LomaMonoODBlockEvaluate(DRT::ELEMENTS::Fluid3*        ele,
                                        DRT::Discretization &         discretization,
                                        const std::vector<int> &      lm,
                                        Teuchos::ParameterList&       params,
                                        Teuchos::RCP<MAT::Material> & mat,
                                        Epetra_SerialDenseMatrix&     elemat1_epetra,
                                        Epetra_SerialDenseMatrix&     elemat2_epetra,
                                        Epetra_SerialDenseVector&     elevec1_epetra,
                                        Epetra_SerialDenseVector&     elevec2_epetra,
                                        Epetra_SerialDenseVector&     elevec3_epetra );

    /// evaluation of off-diagonal matrix block for monolithic loma solver at specified gauss points
    virtual int LomaMonoODBlockEvaluate(DRT::ELEMENTS::Fluid3*               ele,
                                        DRT::Discretization &                discretization,
                                        const std::vector<int> &             lm,
                                        Teuchos::ParameterList&              params,
                                        Teuchos::RCP<MAT::Material> &        mat,
                                        Epetra_SerialDenseMatrix&            elemat1_epetra,
                                        Epetra_SerialDenseMatrix&            elemat2_epetra,
                                        Epetra_SerialDenseVector&            elevec1_epetra,
                                        Epetra_SerialDenseVector&            elevec2_epetra,
                                        Epetra_SerialDenseVector&            elevec3_epetra,
                                        const DRT::UTILS::GaussIntegration & intpoints );

    /*!
      \brief evaluation of off-diagonal matrix block for monolithic loma solver for fluid3 element

      Specific evaluate function without any knowledge about DRT objects. This
      way the element evaluation is independent of the specific mesh storage.
     */
    int LomaMonoODBlockEvaluate(int                                  eid,
                                Teuchos::ParameterList&              params,
                                const LINALG::Matrix<nsd_,nen_> &    ebofoaf,
                                const LINALG::Matrix<nsd_,nen_> &    eprescpgaf,
                                LINALG::Matrix<(nsd_+1)*nen_,nen_> & elemat1,
                                const LINALG::Matrix<nsd_,nen_> &    evelaf,
                                const LINALG::Matrix<nen_,1>    &    epreaf,
                                const LINALG::Matrix<nen_,1>    &    escaaf,
                                const LINALG::Matrix<nsd_,nen_> &    emhist,
                                const LINALG::Matrix<nsd_,nen_> &    eaccam,
                                const LINALG::Matrix<nen_,1>    &    escadtam,
                                const LINALG::Matrix<nen_,1>    &    escabofoaf,
                                const LINALG::Matrix<nsd_,nen_> &    eveln,
                                const LINALG::Matrix<nen_,1>    &    escaam,
                                const LINALG::Matrix<nsd_,nen_> &    edispnp,
                                const LINALG::Matrix<nsd_,nen_> &    egridv,
                                Teuchos::RCP<MAT::Material>          mat,
                                bool                                 isale,
                                double                               CsDeltaSq,
                                const DRT::UTILS::GaussIntegration & intpoints);

    /*!
      \brief calculate element matrix and rhs

      \param eid              (i) element id
      \param ebofoaf          (i) body force at n+alpha_F/n+1
      \param eprescpgaf       (i) prescribed pressure gradient at n+alpha_F/n+1 (required for turbulent channel flow)
      \param evelaf           (i) nodal velocities at n+alpha_F/n+1
      \param eveln            (i) nodal velocities at n
      \param evelnp           (i) nodal velocities at n+1 (np_genalpha)
      \param fsevelaf         (i) fine-scale nodal velocities at n+alpha_F/n+1
      \param epreaf           (i) nodal pressure at n+alpha_F/n+1
      \param eaccam           (i) nodal accelerations at n+alpha_M
      \param escaaf           (i) nodal scalar at n+alpha_F/n+1
      \param escaam           (i) nodal scalar at n+alpha_M/n
      \param escadtam         (i) nodal scalar derivatives at n+alpha_M/n+1
      \param emhist           (i) time rhs for momentum equation
      \param edispnp          (i) nodal displacements (on moving mesh)
      \param egridv           (i) grid velocity (on moving mesh)
      \param estif            (o) element matrix to calculate
      \param emesh            (o) linearization wrt mesh motion
      \param eforce           (o) element rhs to calculate
      \param thermpressaf     (i) thermodynamic pressure at n+alpha_F/n+1
      \param thermpressam     (i) thermodynamic pressure at n+alpha_M/n
      \param thermpressdtaf   (i) thermodynamic pressure derivative at n+alpha_F/n+1
      \param thermpressdtam   (i) thermodynamic pressure derivative at n+alpha_M/n+1
      \param material         (i) fluid material
      \param Cs_delta_sq      (i) parameter for dynamic Smagorinsky model (Cs*h*h)
      \param isale            (i) ALE flag
      \param intpoints        (i) Gaussian integration points

      */
    void Sysmat(int                                            eid,
                const LINALG::Matrix<nsd_,nen_> &              ebofoaf,
                const LINALG::Matrix<nsd_,nen_> &              eprescpgaf,
                const LINALG::Matrix<nsd_,nen_>&               evelaf,
                const LINALG::Matrix<nsd_,nen_>&               eveln,
                const LINALG::Matrix<nsd_,nen_> &              evelnp,
                const LINALG::Matrix<nsd_,nen_>&               fsevelaf,
                const LINALG::Matrix<nsd_,nen_>&               evel_hat,
                const LINALG::Matrix<nsd_*nsd_,nen_>&          ereynoldsstress_hat,
                const LINALG::Matrix<nen_,1>&                  epreaf,
                const LINALG::Matrix<nsd_,nen_>&               eaccam,
                const LINALG::Matrix<nen_,1>&                  escaaf,
                const LINALG::Matrix<nen_,1>&                  escaam,
                const LINALG::Matrix<nen_,1>&                  escadtam,
                const LINALG::Matrix<nen_,1>&                  escabofoaf,
                const LINALG::Matrix<nsd_,nen_>&               emhist,
                const LINALG::Matrix<nsd_,nen_>&               edispnp,
                const LINALG::Matrix<nsd_,nen_>&               egridv,
                LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_>&   estif,
                LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_>&   emesh,
                LINALG::Matrix<(nsd_+1)*nen_,    1>&           eforce,
                const LINALG::Matrix<nen_,1> &                eporo,
                const double                                   thermpressaf,
                const double                                   thermpressam,
                const double                                   thermpressdtaf,
                const double                                   thermpressdtam,
                Teuchos::RCP<const MAT::Material>              material,
                double&                                        Cs_delta_sq,
                bool                                           isale,
                double *                                       saccn,
                double *                                       sveln,
                double *                                       svelnp,
                const DRT::UTILS::GaussIntegration &           intpoints);

    /*!
      \brief calculate element matrix for off-diagonal matrix block for monolithic low-Mach-number solver

      \param eid              (i) element id
      \param ebofoaf          (i) body force at n+alpha_F/n+1
      \param eprescpgaf       (i) prescribed pressure gradient at n+alpha_F/n+1 (required for turbulent channel flow)
      \param evelaf           (i) nodal velocities at n+alpha_F/n+1
      \param epreaf           (i) nodal pressure at n+alpha_F/n+1
      \param eaccam           (i) nodal accelerations at n+alpha_M
      \param escaaf           (i) nodal scalar at n+alpha_F/n+1
      \param escaam           (i) nodal scalar at n+alpha_M/n
      \param emhist           (i) time rhs for momentum equation
      \param edispnp          (i) nodal displacements (on moving mesh)
      \param egridv           (i) grid velocity (on moving mesh)
      \param estif            (o) element matrix to calculate
      \param thermpressaf     (i) thermodynamic pressure at n+alpha_F/n+1
      \param thermpressam     (i) thermodynamic pressure at n+alpha_M/n
      \param thermpressdtaf   (i) thermodynamic pressure derivative at n+alpha_F/n+1
      \param thermpressdtam   (i) thermodynamic pressure derivative at n+alpha_M/n+1
      \param material         (i) fluid material
      \param Cs_delta_sq      (i) parameter for dynamic Smagorinsky model (Cs*h*h)
      \param isale            (i) ALE flag
      \param intpoints        (i) Gaussian integration points

      */
    void LomaMonoODBlockSysmat(int                                  eid,
                               const LINALG::Matrix<nsd_,nen_> &    ebofoaf,
                               const LINALG::Matrix<nsd_,nen_> &    eprescpgaf,
                               const LINALG::Matrix<nsd_,nen_>&     evelaf,
                               const LINALG::Matrix<nsd_,nen_>&     eveln,
                               const LINALG::Matrix<nen_,1>&        epreaf,
                               const LINALG::Matrix<nsd_,nen_>&     eaccam,
                               const LINALG::Matrix<nen_,1>&        escaaf,
                               const LINALG::Matrix<nen_,1>&        escaam,
                               const LINALG::Matrix<nen_,1>&        escadtam,
                               const LINALG::Matrix<nen_,1>&        escabofoaf,
                               const LINALG::Matrix<nsd_,nen_>&     emhist,
                               const LINALG::Matrix<nsd_,nen_>&     edispnp,
                               const LINALG::Matrix<nsd_,nen_>&     egridv,
                               LINALG::Matrix<(nsd_+1)*nen_,nen_>&  estif,
                               const double                         thermpressaf,
                               const double                         thermpressam,
                               const double                         thermpressdtaf,
                               const double                         thermpressdtam,
                               Teuchos::RCP<const MAT::Material>    material,
                               double&                              Cs_delta_sq,
                               bool                                 isale,
                               const DRT::UTILS::GaussIntegration & intpoints);


      /*!
      \brief calculate element matrix and rhs for porous flow

      \param eid              (i) element id
      \param ebofoaf          (i) body force at n+alpha_F/n+1
      \param evelaf           (i) nodal velocities at n+alpha_F/n+1
      \param evelnp           (i) nodal velocities at n+1 (np_genalpha)
      \param epreaf           (i) nodal pressure at n+alpha_F/n+1
      \param eaccam           (i) nodal accelerations at n+alpha_M
      \param emhist           (i) time rhs for momentum equation
      \param edispnp          (i) nodal displacements (on moving mesh)
      \param egridv           (i) grid velocity (on moving mesh)
      \param estif            (o) element matrix to calculate
      \param emesh            (o) linearization wrt mesh motion
      \param eforce           (o) element rhs to calculate
      \param material         (i) fluid material
      \param isale            (i) ALE flag
      \param intpoints        (i) Gaussian integration points

      */
    void PoroSysmat(int                                            eid,
                    const LINALG::Matrix<nsd_,nen_> &              ebofoaf,
                    const LINALG::Matrix<nsd_,nen_>&               evelaf,
                    const LINALG::Matrix<nsd_,nen_> &              evelnp,
                    const LINALG::Matrix<nen_,1>&                  epreaf,
                    const LINALG::Matrix<nsd_,nen_>&               eaccam,
                    const LINALG::Matrix<nsd_,nen_>&               emhist,
                    const LINALG::Matrix<nen_,1>    &              epren,
                    const LINALG::Matrix<nen_,1>    &              epressn_timederiv,
                    const LINALG::Matrix<nen_,1>    &              epressnp_timederiv,
                    const LINALG::Matrix<nsd_,nen_>&               edispnp,
                    const LINALG::Matrix<nsd_,nen_>&               edispn,
                    const LINALG::Matrix<nsd_,nen_>&               egridv,
                    LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_>&   estif,
                    LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_>&   emesh,
                    LINALG::Matrix<(nsd_+1)*nen_,    1>&           eforce,
                    Teuchos::RCP<const MAT::Material>              material,
                    bool                                           isale,
                    const DRT::UTILS::GaussIntegration &           intpoints);

    void PoroSysmatCoupl(int                                            eid,
						const LINALG::Matrix<nsd_,nen_> &              ebofoaf,
						const LINALG::Matrix<nsd_,nen_>&               evelaf,
						const LINALG::Matrix<nsd_,nen_> &              evelnp,
						const LINALG::Matrix<nen_,1>&                  epreaf,
						const LINALG::Matrix<nsd_,nen_>&               eaccam,
						const LINALG::Matrix<nsd_,nen_>&               emhist,
						const LINALG::Matrix<nen_,1>    &              epren,
						const LINALG::Matrix<nen_,1>    &              epressnp_timederiv,
						const LINALG::Matrix<nsd_,nen_>&               edispnp,
						const LINALG::Matrix<nsd_,nen_>&               edispn,
						const LINALG::Matrix<nsd_,nen_>&               egridv,
						LINALG::Matrix<(nsd_+1)*nen_,nsd_*nen_>&      ecoupl,
					//	LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_>&   emesh,
						LINALG::Matrix<(nsd_+1)*nen_,    1>&           eforce,
						Teuchos::RCP<const MAT::Material>              material,
						bool                                           isale,
						const DRT::UTILS::GaussIntegration &           intpoints);

    /*!
      \brief FD-check for debugging
    */

    void FDcheck(
      int                                                   eid,
      const LINALG::Matrix<nsd_,nen_>&                      evelaf,
      const LINALG::Matrix<nsd_,nen_>&                      eveln,
      const LINALG::Matrix<nsd_,nen_>&                      fsevelaf,
      const LINALG::Matrix<nen_,1>&                         epreaf,
      const LINALG::Matrix<nsd_,nen_>&                      eaccam,
      const LINALG::Matrix<nen_,1>&                         escaaf,
      const LINALG::Matrix<nen_,1>&                         escaam,
      const LINALG::Matrix<nen_,1>&                         escadtam,
      const LINALG::Matrix<nsd_,nen_>&                      emhist,
      const LINALG::Matrix<nsd_,nen_>&                      edispnp,
      const LINALG::Matrix<nsd_,nen_>&                      egridv,
      const LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_>&    estif,
      const LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_>&    emesh,
      const LINALG::Matrix<(nsd_+1)*nen_,    1>&            eforce,
      const double                                          thermpressaf,
      const double                                          thermpressam,
      const double                                          thermpressdtaf,
      const double                                          thermpressdtam,
      const Teuchos::RCP<const MAT::Material>               material,
      const double                                          timefac,
      const double&                                         Cs,
      const double&                                         Cs_delta_sq,
      const double&                                         l_tau);

    LINALG::Matrix<nsd_,nen_> & xyz() { return xyze_; }

  private:

    //! number of components necessary to store second derivatives
    /*!
     1 component  for nsd=1:  (N,xx)

     3 components for nsd=2:  (N,xx ; N,yy ; N,xy)

     6 components for nsd=3:  (N,xx ; N,yy ; N,zz ; N,xy ; N,xz ; N,yz)
    */
    static const int numderiv2_ = DRT::UTILS::DisTypeToNumDeriv2<distype>::numderiv2;

    /// calculate body force from nodal conditions
    void BodyForce(
      DRT::ELEMENTS::Fluid3*               ele,         //< pointer to element
      DRT::ELEMENTS::Fluid3ImplParameter*  f3Parameter, //< pointer to fluid parameter
      LINALG::Matrix<nsd_,nen_> &          ebofoaf,     //< body force at nodes
      LINALG::Matrix<nsd_,nen_> &          eprescpgaf,  //< prescribed pressure gradient (required for turbulent channel flow!)
      LINALG::Matrix<nen_,1> &             escabofoaf   //< scatra body force at nodes
      );

    //! evaluate shape functions and their derivatives at element center
    void EvalShapeFuncAndDerivsAtEleCenter(
         const int  eleid  ///< element ID
          );

    //! brief evaluate shape functions and their derivatives at integration point
    void EvalShapeFuncAndDerivsAtIntPoint(
        DRT::UTILS::GaussIntegration::iterator & iquad,             ///< actual integration point
        const int                                eleid              ///< element ID
        );


    //! get material parameters
    void GetMaterialParams(Teuchos::RCP<const MAT::Material>       material,  ///< reference pointer to material
                           const LINALG::Matrix<nsd_,nen_>&        evelaf,    ///< velocity at time n+alpha_f / n+1
                           const LINALG::Matrix<nen_,1>&           escaaf,    ///< scalar at time n+alpha_f / n+1
                           const LINALG::Matrix<nen_,1>&           escaam,    ///< scalar at time n+alpha_m / n
                           const LINALG::Matrix<nen_,1>&           escabofoaf,   ///< body force for scalar transport at time n+alpha_f / n+1
                           const double                            thermpressaf,    ///< thermodynamic pressure at time n+alpha_f / n+1
                           const double                            thermpressam,    ///< thermodynamic pressure at time n+alpha_m / n
                           const double                            thermpressdtaf, ///< time derivative of thermodynamic pressure at time n+alpha_f / n+1
                           const double                            thermpressdtam ///< time derivative of thermodynamic pressure at time n+alpha_m / n+1
                           );

    //! update material parameters including subgrid-scale part of scalar
    void UpdateMaterialParams(Teuchos::RCP<const MAT::Material> material,  ///< reference pointer to material
                           const LINALG::Matrix<nsd_,nen_>&     evelaf,    ///< velocity at time n+alpha_f / n+1
                           const LINALG::Matrix<nen_,1>&        escaaf,    ///< scalar at time n+alpha_f / n+1
                           const LINALG::Matrix<nen_,1>&        escaam,    ///< scalar at time n+alpha_m / n
                           const double                         thermpressaf,    ///< thermodynamic pressure at time n+alpha_f / n+1
                           const double                         thermpressam    ///< thermodynamic pressure at time n+alpha_m / n
                           );

    //! get parameters for multifractal subgrid scales
    void PrepareMultifractalSubgrScales(LINALG::Matrix<nsd_,1>&           B,         ///< coefficient multifractal subgrid scales
                                        const LINALG::Matrix<nsd_,nen_>&  evelaf,    ///< velocity at time n+alpha_f / n+1
                                        const LINALG::Matrix<nsd_,nen_>&  fsevelaf,  ///< fine scale velocity at time n+alpha_f / n+1
                                        const double                      vol        ///< volume
                                        );

    //! get turbulence parameter
    void GetTurbulenceParams(ParameterList&             turbmodelparams,    ///< pointer general turbulence parameter list
                             double&                    Cs_delta_sq,        ///< parameter CS in dynamic Smagorinsky
                             int&                       nlayer,             ///< number of layers for computation of parameter CS in dynamic Smagorinsky
                             double CsDeltaSq                               ///< parameter CS in dynamic Smagorinsky computed in DynSmagFilter()
                             );

    //! calculate (all-scale) subgrid viscosity
    void CalcSubgrVisc(const LINALG::Matrix<nsd_,nen_>&     evelaf,   ///< velocity at time n+alpha_f / n+1
                       const double                        vol,       ///< volume
                       double&                             Cs,        ///< parameter CS in fixed Smagorinsky
                       double&                             Cs_delta_sq,   ///< parameter CS in dynamic Smagorinsky
                       double&                             l_tau          ///< channel length to normalize the normal wall distance
                       );

    //! calculate fine-scale subgrid viscosity
    void CalcFineScaleSubgrVisc(const LINALG::Matrix<nsd_,nen_>&     evelaf,    ///< velocity at time n+alpha_f / n+1
                                const LINALG::Matrix<nsd_,nen_>&     fsevelaf,  ///< fine scale velocity at time n+alpha_f / n+1
                                const double                        vol,        ///< volume
                                double&                             Cs          ///< parameter CS in fixed Smagorinsky
                                );

    void CalcMultiFracSubgridVelCoef(
      const double            Csgs,
      const double            alpha,
      const vector<double>    N,
      LINALG::Matrix<nsd_,1>& B
      );

    //! calculate stabilization parameter
    void CalcStabParameter(const double  vol);  ///< volume

    //! calculate characteristic element length
    void CalcCharEleLength(const double  vol,       ///< volume
                           const double  vel_norm,  ///< norm of velocity vector
                           double&       strle,     ///< streamlength (for tau_Mu)
                           double&       hk);       ///< length for tau_Mp


    //! calculate div(epsilon(u))
    void CalcDivEps(
        const LINALG::Matrix<nsd_,nen_>&        evelaf   ///< velocity at time n+alpha_f / n+1
        );

    //! compute residual of momentum equation and subgrid-scale velocity
    void ComputeSubgridScaleVelocity(
        const LINALG::Matrix<nsd_,nen_>& eaccam,  ///< acceleration at time n+alpha_M
        double &                         fac1,    ///< factor for old s.-s. velocities
        double &                         fac2,    ///< factor for old s.-s. accelerations
        double &                         fac3,    ///< factor for residual in current s.-s. velocities
        double &                         facMtau, ///< facMtau = modified tau_M (see code)
        int                              iquad,   ///< integration point
        double *                         saccn,   ///< s.-s. acceleration at time n+alpha_a / n
        double *                         sveln,   ///< s.-s. velocity at time n+alpha_a / n
        double *                         svelnp   ///< s.-s. velocity at time n+alpha_f / n+1
      );

    //! compute additional Galerkin terms on right-hand side of continuity equation
    //! (only required for variable-density flow at low Mach number)
    void ComputeGalRHSContEq(
        const LINALG::Matrix<nsd_,nen_>&  eveln,    ///< velocity at time n
        const LINALG::Matrix<nen_,1>&     escaaf,   ///< scalar at time n+alpha_F/n+1
        const LINALG::Matrix<nen_,1>&     escaam,   ///< scalar at time n+alpha_M/n
        const LINALG::Matrix<nen_,1>&     escadtam, ///< acceleration at time n+alpha_M/n
        bool                              isale     ///< flag for ALE case
        );

    //! compute residual of scalar equation and subgrid-scale part of scalar
    //! (only required for variable-density flow at low Mach number)
    void ComputeSubgridScaleScalar(
        const LINALG::Matrix<nen_,1>&             escaaf,  ///< scalar at time n+alpha_F/n+1
        const LINALG::Matrix<nen_,1>&             escaam  ///< scalar at time n+alpha_M/n
        );

    //! recompute Galerkin terms based on updated material parameters
    //! including s.-s. part of scalar and compute cross-stress term on
    //! right-hand side of continuity equation
    //! (only required for variable-density flow at low Mach number)
    void RecomputeGalAndComputeCrossRHSContEq();

    //! Provide linearization of Garlerkin momentum residual with respect to the velocities
    void LinGalMomResU(
        LINALG::Matrix<nsd_*nsd_,nen_> &        lin_resM_Du,    ///< linearisation of the Garlerkin momentum residual
        const double &                          timefacfac      ///< = timefac x fac
        );

    //! Provide linearization of Garlerkin momentum residual with respect to the velocities in the case if subscales
    void LinGalMomResU_subscales(
        LINALG::Matrix<nen_*nsd_,nen_>          estif_p_v,      ///< block (weighting function v x pressure)
        LINALG::Matrix<nsd_*nsd_,nen_> &        lin_resM_Du,    ///< linearisation of the Garlerkin momentum residual
        LINALG::Matrix<nsd_,1> &                resM_Du,        ///< residual of the fluid momentum equation
        const double &                          timefacfac,     ///< (time factor) x (integration factor)
        const double &                          facMtau         ///< facMtau = modified tau_M (see code)
        );

    //! Compute element matrix and rhs entries: inertia, convective and
    //! reactive terms of the Galerkin part
    void InertiaConvectionReactionGalPart(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &   estif_u,        ///< block (weighting function v x u)
        LINALG::Matrix<nsd_,nen_> &             velforce,       ///< rhs forces velocity
        LINALG::Matrix<nsd_*nsd_,nen_> &        lin_resM_Du,    ///< linearisation of the Garlerkin momentum residual
        LINALG::Matrix<nsd_,1> &                resM_Du,        ///< linearisation of the Garlerkin momentum residual
        const double &                          rhsfac          ///< right-hand-side factor
        );

    //! Compute element matrix entries: for the viscous terms of the Galerkin part
    void ViscousGalPart(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &   estif_u,        ///< block (weighting function v x u)
        LINALG::Matrix<nsd_,nen_> &             velforce,       ///< rhs forces velocity
        LINALG::Matrix<nsd_,nsd_> &             viscstress,     ///< viscous stresses
        const double &                          timefacfac,     ///< = timefac x fac
        const double &                          rhsfac          ///< right-hand-side factor
        );

    //! Compute element matrix entries: div-grad stabilization and the rhs of the viscous term
    void ContStab(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &     estif_u,        ///< block (weighting function v x u)
        LINALG::Matrix<nsd_,nen_> &               velforce,       ///< rhs forces velocity
        const double &                            timefac,        ///< time factor
        const double &                            timefacfac,     ///< = timefac x fac
        const double &                            timefacfacpre,     ///< = timefac x fac
        const double &                            rhsfac         ///< right-hand-side factor
        );

    //! Compute element matrix entries: pressure terms of the Garlerkin part and rhs
    void PressureGalPart(
        LINALG::Matrix<nen_*nsd_,nen_> &          estif_p_v,      ///< block (weighting function v x pressure)
        LINALG::Matrix<nsd_,nen_> &               velforce,       ///< rhs forces velocity
        const double &                            timefacfac,     ///< = timefac x fac
        const double &                            timefacfacpre,
        const double &                            rhsfac,         ///< right-hand-side factor
        const double &                            press           ///< pressure at integration point
        );

    //! Compute element matrix entries: continuity terms of the Garlerkin part and rhs
    void ContinuityGalPart(
        LINALG::Matrix<nen_, nen_*nsd_> &         estif_q_u,    ///< block (weighting function q x u)
        LINALG::Matrix<nen_,1> &                  preforce,     ///< rhs forces pressure
        const double &                            timefacfac,   ///< = timefac x fac
        const double &                            timefacfacpre,
        const double &                            rhsfac        ///< right-hand-side factor
        );

    //! Compute element matrix entries: body force terms on rhs
    void BodyForceRhsTerm(
        LINALG::Matrix<nsd_,nen_> &               velforce,     ///< rhs forces velocity
        const double &                            rhsfac     ///< right-hand-side factor for residuals
        );

    //TODO: look over it
    //! Compute element matrix entries: conservative formulation
    void ConservativeFormulation(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &     estif_u,      ///< block (weighting function v x u)
        LINALG::Matrix<nsd_,nen_> &               velforce,     ///< rhs forces velocity
        const double &                            timefacfac,   ///< = timefac x fac
        const double &                            rhsfac        ///< right-hand-side factor
        );

    //! Compute element matrix entries: LOMA
    void LomaGalPart(
        LINALG::Matrix<nen_, nen_*nsd_> &       estif_q_u,      ///< block (weighting function q x u)
        LINALG::Matrix<nen_,1> &                preforce,       ///< rhs forces pressure
        const double &                          timefacfac,     ///< = timefac x fac
        const double &                          rhsfac       ///< right-hand-side factor for residuals
        );

    //! Provide linearization of stabilization residual with respect to the velocities
    void StabLinGalMomResU(
        LINALG::Matrix<nsd_*nsd_,nen_> &          lin_resM_Du,    ///< linearisation of the stabilization residual
        const double&                             timefacfac      ///< = timefac x fac
        );

    //! Compute element matrix entries: PSPG
    void PSPG(
        LINALG::Matrix<nen_, nen_*nsd_> &         estif_q_u,      ///< block (weighting function q x u)
        LINALG::Matrix<nen_,nen_> &               ppmat,          ///< block (weighting function q x p)
        LINALG::Matrix<nen_,1> &                  preforce,       ///< rhs forces pressure
        LINALG::Matrix<nsd_*nsd_,nen_> &          lin_resM_Du,    ///< linearisation of the stabilization residual
        const double &                            fac3,           ///< factor for residual in current subgrid velocities
        const double &                            timefacfac,     ///< = timefac x fac
        const double &                            timefacfacpre,
        const double &                            rhsfac       ///< right-hand-side factor for residuals
        );

    //! Compute element matrix entries: SUPG
    void SUPG(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &     estif_u,        ///< block (weighting function v x u)
        LINALG::Matrix<nen_*nsd_,nen_> &          estif_p_v,      ///< block (weighting function v x p)
        LINALG::Matrix<nsd_,nen_> &               velforce,       ///< rhs forces velocity
        LINALG::Matrix<nsd_*nsd_,nen_> &          lin_resM_Du,    ///< linearisation of the stabilization residual
        const double &                            fac3,           ///< factor for residual in current subgrid velocities
        const double &                            timefacfac,     ///< = timefac x fac
        const double &                            timefacfacpre,
        const double &                            rhsfac       ///< right-hand-side factor for residuals
        );

    //! Compute element matrix entries: reactive stabilization
    void ReacStab(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &     estif_u,        ///< block (weighting function v x u)
        LINALG::Matrix<nen_*nsd_,nen_> &          estif_p_v,      ///< block (weighting function v x p)
        LINALG::Matrix<nsd_,nen_> &               velforce,       ///< rhs forces velocity
        LINALG::Matrix<nsd_*nsd_,nen_> &          lin_resM_Du,    ///< linearisation of the stabilization residual
        const double &                            timefacfac,     ///< = timefac x fac
        const double &                            timefacfacpre,  ///< = timefacpre x fac
        const double &                            rhsfac,      ///< right-hand-side factor for residuals
        const double &                            fac3            ///< factor for residual in current subgrid velocities
        );

    //! Compute element matrix entries: viscous stabilization
    void ViscStab(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &     estif_u,        ///< block (weighting function v x u)
        LINALG::Matrix<nen_*nsd_,nen_> &          estif_p_v,      ///< block (weighting function v x p)
        LINALG::Matrix<nsd_,nen_> &               velforce,       ///< rhs forces velocity
        LINALG::Matrix<nsd_*nsd_,nen_> &          lin_resM_Du,    ///< linearisation of the stabilization residual
        const double &                            timefacfac,     ///< = timefac x fac
        const double &                            timefacfacpre,     ///< = timefac x fac
        const double &                            rhsfac,      ///< right-hand-side factor for residuals
        const double &                            fac3            ///< factor for residual in current subgrid velocities
        );

    //! Compute element matrix entries: convective divergence stabilization for XFEM
    void ConvDivStab(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &     estif_u,         ///< block (weighting function v x u)
        LINALG::Matrix<nsd_,nen_> &               velforce,        ///< rhs forces velocity
        const double &                            timefacfac,      ///< = timefac x fac
        const double &                            rhsfac           ///< right-hand-side factor for residuals
        );

    //! Compute element matrix entries: cross stress stabilization
    void CrossStressStab(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &     estif_u,        ///< block (weighting function v x u)
        LINALG::Matrix<nen_*nsd_,nen_> &          estif_p_v,      ///< block (weighting function v x p)
        LINALG::Matrix<nsd_,nen_> &               velforce,       ///< rhs forces velocity
        LINALG::Matrix<nsd_*nsd_,nen_> &          lin_resM_Du,    ///< linearisation of the stabilization residual
        const double &                            timefacfac,     ///< = timefac x fac
        const double &                            timefacfacpre,
        const double &                            rhsfac,      ///< right-hand-side factor for residuals
        const double &                            fac3            ///< factor for residual in current subgrid velocities
        );

    //! Compute element matrix entries: Reynolds stress stabilization
    void ReynoldsStressStab(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &     estif_u,        ///< block (weighting function v x u)
        LINALG::Matrix<nen_*nsd_,nen_> &          estif_p_v,      ///< block (weighting function v x p)
        LINALG::Matrix<nsd_*nsd_,nen_> &          lin_resM_Du,    ///< linearisation of the stabilization residual
        const double &                            timefacfac,     ///< timefac x fac
        const double &                            timefacfacpre,
        const double &                            fac3            ///< factor for residual in current subgrid velocities
        );

    //! Compute element matrix entries: fine scale subgrid viscousity rhs term
    void FineScaleSubGridViscosityTerm(
        LINALG::Matrix<nsd_,nen_> &               velforce,       ///< rhs forces velocity
        const double &                            fssgviscfac     ///< = (fine scale subgrid viscousity) x timefacfac
        );

    void ScaleSimSubGridStressTermPrefiltering(
        LINALG::Matrix<nsd_,nen_> &               velforce,
        const double &                            rhsfac,
        const double &                            Cl);

    void ScaleSimSubGridStressTermCross(
        LINALG::Matrix<nsd_,nen_> &               velforce,
        const double &                            rhsfac,
        const double &                            Cl);

    void ScaleSimSubGridStressTermReynolds(
        LINALG::Matrix<nsd_,nen_> &               velforce,
        const double &                            rhsfac,
        const double &                            Cl);

    void MultfracSubGridScalesCross(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &     estif_u,
        LINALG::Matrix<nsd_,nen_> &               velforce,
        const double &                            timefacfac,
        const double &                            rhsfac);

    void MultfracSubGridScalesReynolds(
        LINALG::Matrix<nen_*nsd_,nen_*nsd_> &     estif_u,
        LINALG::Matrix<nsd_,nen_> &               velforce,
        const double &                            timefacfac,
        const double &                            rhsfac);

    void FineScaleSimilaritySubGridViscosityTerm(
        LINALG::Matrix<nsd_,nen_> &             velforce,
        const double &                          fssgviscfac);

    //! linearisation in the case of mesh motion 2-D
    void LinMeshMotion_2D(
        LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_>&  emesh,        ///< mesh motion
        const LINALG::Matrix<nsd_,nen_>&              evelaf,       ///< velocity at time n+alpha_f / n+1
        const double &                                press,        ///< pressure at integration point
        const double &                                timefac,      ///< time factor
        const double &                                timefacfac    ///< = timefac x fac
        );

    //! linearisation in the case of mesh motion 3-D
    void LinMeshMotion_3D(
        LINALG::Matrix<(nsd_+1)*nen_,(nsd_+1)*nen_>&  emesh,        ///< mesh motion
        const LINALG::Matrix<nsd_,nen_>&              evelaf,       ///< velocity at time n+alpha_f / n+1
        const double &                                press,        ///< pressure at integration point
        const double &                                timefac,      ///< time factor
        const double &                                timefacfac    ///< = timefac x fac
        );

    //! linearisation in the case of mesh motion 3-D for Poroelasticity
    void PoroLinMeshMotion_3D(
        LINALG::Matrix<(nsd_+1)*nen_,(nsd_)*nen_>&    emesh,        ///< mesh motion
        const LINALG::Matrix<nsd_,nen_>&              evelaf,       ///< velocity at time n+alpha_f / n+1
        const LINALG::Matrix<nsd_,nen_>&              egridv,       ///< grid velocity at time n+alpha_f / n+1
        const double &                                press,        ///< pressure at integration point
        const double &                                press_dot,   ///< pressure at integration point
        const double &                                porosity,     ///< time derivative of pressure at integration point
        const double &                                dphi_dp,      ///< d(porosity)/d(pressure) at integration point
        const double &                                dphi_dJ,      ///< d(porosity)/d(J) at integration point
        const double &                                J,            ///< Jacobian at integration point
        LINALG::Matrix<1,nsd_>& 					  gradJ,        ///< derivative of Jacobian w.r.t. x,y,z
        const double &                                timefac,      ///< time factor
        const double &                                timefacfac    ///< = timefac x fac
        );

    /*!
      \brief calculate rate of strain of (fine-scale) velocity

      \param evel       (i) nodal velocity values
      \param derxy      (i) shape function derivatives
      \param velderxy   (o) velocity derivatives

      \return computed rate of strain
     */
    double GetStrainRate(const LINALG::Matrix<nsd_,nen_>& evel)
    {
      double rateofstrain=0.0;

      // velderxy is computed here since the evaluation of the strain rate can be performed
      // at the element center before the gauss loop

      // get velocity derivatives at integration point
      //
      //              +-----  dN (x)
      //   dvel (x)    \        k
      //   -------- =   +     ------ * vel
      //      dx       /        dx        k
      //        j     +-----      j
      //              node k
      //
      // j : direction of derivative x/y/z
      //
      LINALG::Matrix<nsd_,nsd_> velderxy;
      velderxy.MultiplyNT(evel,derxy_);

      // compute (resolved) rate of strain
      //
      //          +-                                 -+ 1
      //          |          /   \           /   \    | -
      //          | 2 * eps | vel |   * eps | vel |   | 2
      //          |          \   / ij        \   / ij |
      //          +-                                 -+
      //
      LINALG::Matrix<nsd_,nsd_> two_epsilon;
      for(int rr=0;rr<nsd_;++rr)
      {
        for(int mm=0;mm<nsd_;++mm)
        {
          two_epsilon(rr,mm) = velderxy(rr,mm) + velderxy(mm,rr);
        }
      }

      for(int rr=0;rr<nsd_;++rr)
      {
        for(int mm=0;mm<nsd_;++mm)
        {
          rateofstrain += two_epsilon(rr,mm)*two_epsilon(mm,rr);
        }
      }

      // sqrt(two_epsilon(rr,mm)*two_epsilon(mm,rr)/4.0*2.0)

      return(sqrt(rateofstrain/2.0));
    }


    /*!
     * \brief fill elment matrix and vectors with the global values
     */
    void ExtractValuesFromGlobalVector( const DRT::Discretization&   discretization, ///< discretization
                                        const vector<int>&           lm,             ///<
                                        FLD::RotationallySymmetricPeriodicBC<distype> & rotsymmpbc, ///<
                                        LINALG::Matrix<nsd_,nen_> *  matrixtofill,   ///< vector field
                                        LINALG::Matrix<nen_,1> *     vectortofill,   ///< scalar field
                                        const std::string            state)          ///< state of the global vector
    {
      // get state of the global vector
      Teuchos::RCP<const Epetra_Vector> matrix_state = discretization.GetState(state);
      if(matrix_state == null)
        dserror("Cannot get state vector %s", state.c_str());

      // extract local values of the global vectors
      std::vector<double> mymatrix(lm.size());
      DRT::UTILS::ExtractMyValues(*matrix_state,mymatrix,lm);

      // rotate the vector field in the case of rotationally symmetric boundary conditions
      if(matrixtofill != NULL)
        rotsymmpbc.RotateMyValuesIfNecessary(mymatrix);

      for (int inode=0; inode<nen_; ++inode)  // number of nodes
      {
        // fill a vector field via a pointer
        if (matrixtofill != NULL)
        {
          for(int idim=0; idim<nsd_; ++idim) // number of dimensions
          {
            (*matrixtofill)(idim,inode) = mymatrix[idim+(inode*numdofpernode_)];
          }  // end for(idim)
        }
        // fill a scalar field via a pointer
        if (vectortofill != NULL)
          (*vectortofill)(inode,0) = mymatrix[nsd_+(inode*numdofpernode_)];
      }
    }



    //! node coordinates
    LINALG::Matrix<nsd_,nen_> xyze_;
    //! array for shape functions
    LINALG::Matrix<nen_,1> funct_;
    //! array for shape function derivatives w.r.t r,s,t
    LINALG::Matrix<nsd_,nen_> deriv_;
    //! array for second derivatives of shape function w.r.t r,s,t
    LINALG::Matrix<numderiv2_,nen_> deriv2_;
    //! transposed jacobian "dx/ds"
    LINALG::Matrix<nsd_,nsd_> xjm_;
    //! inverse of transposed jacobian "ds/dx"
    LINALG::Matrix<nsd_,nsd_> xji_;
    //! global velocity derivatives in gausspoint w.r.t x,y,z
    LINALG::Matrix<nsd_,nsd_> vderxy_;
    //! fine-scale global velocity derivatives in gausspoint w.r.t x,y,z
    LINALG::Matrix<nsd_,nsd_> fsvderxy_;
    //! fine-scale global velocity derivatives in gausspoint w.r.t x,y,z for multifractal subgrid-scale modeling
    LINALG::Matrix<nsd_,nsd_> mffsvderxy_;
    //! global derivatives of shape functions w.r.t x,y,z
    LINALG::Matrix<nsd_,nen_> derxy_;
    //! global second derivatives of shape functions w.r.t x,y,z
    LINALG::Matrix<numderiv2_,nen_> derxy2_;
    //! bodyforce in gausspoint
    LINALG::Matrix<nsd_,1> bodyforce_;
    //! prescribed pressure gradient (required for turbulent channel flow!)
    LINALG::Matrix<nsd_,1> prescribedpgrad_;
    //! vector containing all values from previous timelevel n for momentum equation
    LINALG::Matrix<nsd_,1> histmom_;
    //! velocity vector in gausspoint
    LINALG::Matrix<nsd_,1> velint_;
    //! fine-scale velocity vector in gausspoint
    LINALG::Matrix<nsd_,1> fsvelint_;
    //! subgrid-scale velocity vector in gausspoint
    LINALG::Matrix<nsd_,1> sgvelint_;
    //! fine-scale velocity vector in gausspoint for multifractal subgrid-scale modeling
    LINALG::Matrix<nsd_,1> mffsvelint_;
    //! filtered velocity in gausspoint
    LINALG::Matrix<nsd_,1> velinthat_;
    //! global filtered velocity derivatives in gausspoint w.r.t x,y,z
    LINALG::Matrix<nsd_,nsd_> velhatderxy_;
    //! filtered reynoldsstess in gausspoint
    LINALG::Matrix<nsd_,nsd_> reystressinthat_;
    //! divergence of filtered reynoldsstess in gausspoint
    LINALG::Matrix<nsd_,1> reystresshatdiv_;
    //! divergence of convective term of filtered velocity in gausspoint
    LINALG::Matrix<nsd_,1> velhativelhatjdiv_;
    //! filtered velocity divergence
    double velhatdiv_;
    //! grid velocity u_G at integration point
    LINALG::Matrix<nsd_,1> gridvelint_;
    //! ale convective velocity c=u-u_G at integration point
    LINALG::Matrix<nsd_,1> convvelint_;
    //! acceleration vector in gausspoint
    LINALG::Matrix<nsd_,1> accint_;
    //! pressure gradient in gausspoint
    LINALG::Matrix<nsd_,1> gradp_;
    //! the stabilisation parameters -> it is a (3,1) vector for 2D and 3D
    LINALG::Matrix<3,1> tau_;
    //! viscous term including 2nd derivatives
    //! (This array once had three dimensions, now the first two are combined to one.)
    LINALG::Matrix<nsd_*nsd_,nen_> viscs2_;
    //! linearisation of convection, convective part
    LINALG::Matrix<nen_,1> conv_c_;
    //! linearisation of subgrid-scale convection, convective part
    LINALG::Matrix<nen_,1> sgconv_c_;
    //! velocity divergenceat at t_(n+alpha_F) or t_(n+1)
    double vdiv_;
    //! fine scale velocity divergence for multifractal subgrid-scale modeling
    double mffsvdiv_;
    //! total right hand side terms at int.-point for momentum equation
    LINALG::Matrix<nsd_,1> rhsmom_;
    //! (u_old*nabla)u_old
    LINALG::Matrix<nsd_,1> conv_old_;
    //! div epsilon(u_old)
    LINALG::Matrix<nsd_,1> visc_old_;
    //! old residual of momentum equation
    LINALG::Matrix<nsd_,1> momres_old_;
    //! old residual of continuity equation
    double conres_old_;
    //! 2nd derivatives of coord.-functions w.r.t r,s,t
    LINALG::Matrix<numderiv2_,nsd_> xder2_;
    //! global velocity second derivatives in gausspoint w.r.t x,y,z
    LINALG::Matrix<nsd_,nsd_> vderiv_;

    //! residual of momentum equation, velocity part which is not integrated by parts (precomputed)
    LINALG::Matrix<nsd_,1> resM_Du_;
    //! linearisation of residual of momentum equation wrt velocities (precomputed)
    LINALG::Matrix<nsd_*nsd_,nen_> lin_resM_Du_;
    //! block (weighting function v x u)
    LINALG::Matrix<nen_*nsd_,nen_*nsd_>     estif_;
    //! block (weighting function v x p)
    LINALG::Matrix<nen_*nsd_,nen_>          estif_p_v_;
    //! block (weighting function q x u)
    LINALG::Matrix<nen_, nen_*nsd_>         estif_q_u_;
    //! block (weighting function q x p)
    LINALG::Matrix<nen_,nen_>               ppmat;
    //! rhs forces pressure
    LINALG::Matrix<nen_,1>      preforce;
    //! rhs forces velocity
    LINALG::Matrix<nsd_,nen_>   velforce;

    //! coordinates of current integration point in reference coordinates
    LINALG::Matrix<nsd_,1> xsi_;
    //! Jacobian determinant
    double det_;
    //! integration factor
    double fac_;
    //! physical viscosity
    double visc_;
    //! (all-scale) subgrid viscosity
    double sgvisc_;
    //! effective viscosity = physical viscosity + (all-scale) subgrid viscosity
    double visceff_;
    //! reaction coefficient
    double reacoeff_;
    //! fine-scale subgrid viscosity
    double fssgvisc_;
    //! LOMA-specific variables:
    //! physical diffusivity of scalar equation
    double diffus_;
    //! right-hand-side term at int.-point for continuity equation
    double rhscon_;
    //! density at t_(n+alpha_F) or t_(n+1)
    double densaf_;
    //! density at t_(n+alpha_M)
    double densam_;
    //! density at t_(n)
    double densn_;
    //! delta density for Boussinesq Approximation
    double deltadens_;
    //! factor for scalar time derivative
    double scadtfac_;
    //! factor for convective scalar term at t_(n+alpha_F) or t_(n+1)
    double scaconvfacaf_;
    //! factor for convective scalar term at t_(n)
    double scaconvfacn_;
    //! addition to continuity equation due to thermodynamic pressure
    double thermpressadd_;
    //! convective velocity vector in gausspoint at t_(n)
    LINALG::Matrix<nsd_,1> convvelintn_;
    //! global velocity derivatives in gausspoint w.r.t x,y,z at t_(n)
    LINALG::Matrix<nsd_,nsd_> vderxyn_;
    //! velocity divergenceat at t_(n)
    double vdivn_;
    //! scalar gradient at t_(n+alpha_F) or t_(n+1)
    LINALG::Matrix<nsd_,1> grad_scaaf_;
    //! scalar gradient at t_(n)
    LINALG::Matrix<nsd_,1> grad_scan_;
    //! scalar at t_(n+alpha_F) or t_(n+1)
    double scaaf_;
    //! scalar at t_(n)
    double scan_;
    //! time derivative of scalar term (only required for generalized-alpha scheme)
    double tder_sca_;
    //! convective scalar term at t_(n+alpha_F) or t_(n+1)
    double conv_scaaf_;
    //! convective scalar term at t_(n)
    double conv_scan_;
    //! right-hand side of scalar equation
    double scarhs_;
    //! subgrid-scale part of scalar at integration point
    double sgscaint_;
    //! for the handling of rotationally symmetric periodic boundary conditions
    FLD::RotationallySymmetricPeriodicBC<distype>* rotsymmpbc_;
    //! Flag to (de)activate higher order elements
    //! elements with only mixed second order derivatives are not counted as higher order elements
    //! (see definition of higher order elements in fluid3_ele_impl_utils.cpp)
    bool is_higher_order_ele_;
    //! pointer to parameter list
    DRT::ELEMENTS::Fluid3ImplParameter* f3Parameter_;
    //! element type: nurbs
    bool isNurbs_;
    //! weights for nurbs elements
    LINALG::Matrix<nen_,1> weights_;
    //! knot vector for nurbs elements
    std::vector<Epetra_SerialDenseVector> myknots_;

    DRT::UTILS::GaussIntegration intpoints_;

    double L2_; //Jeffery-Hamel

    //! initial porosity
    LINALG::Matrix<nen_,1> initporosityfield_;

    //! bulkmodulus of porous media (only for poroelasticty problems)
    double bulkmodulus_;
    double penalty_;
    double initporosity_;
  };
}
}

#endif

#endif
#endif
