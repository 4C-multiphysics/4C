/*!----------------------------------------------------------------------
\file drt_utils.H
\brief A collection of helper methods for namespace DRT
<pre>
Maintainer: Michael Gee
            gee@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15239
</pre>

*----------------------------------------------------------------------*/
#ifndef UTILS_H
#define UTILS_H


#include "drt_node.H"
#include "drt_element.H"

#include "Teuchos_RCP.hpp"
#include "Epetra_SerialDenseMatrix.h"
#include "Epetra_SerialDenseVector.h"

#include <boost/random.hpp>


namespace DRT
{
/// collection of useful and important but less central stuff
namespace UTILS
{
  /*!
  \brief Locally extract a subset of values from an Epetra_Vector

  Extracts lm.size() values from a distributed epetra vector and stores them into local.
  this is NOT a parallel method, meaning that all values to be extracted on a processor
  must be present in global on that specific processor. This usually means that global
  has to be in column map style.

  \param global (in): global distributed vector with values to be extracted
  \param local (out): vector holding values extracted from global
  \param lm     (in): vector containing global ids to be extracted. Size of lm
                      determines number of values to be extracted.
  */
  void ExtractMyValues(const Epetra_Vector& global, std::vector<double>& local, const std::vector<int>& lm);

  void ExtractMyValues(const Epetra_Vector& global, Epetra_SerialDenseVector& local, const std::vector<int>& lm);

  /// Locally extract a subset of values from a (column)-nodemap-based Epetra_MultiVector
  /*  \author henke
   *  \date 06/09
   */
  void ExtractMyNodeBasedValues
  (
    const DRT::Element* ele,            ///< pointer to current element
    std::vector<double>& local,         ///< local vector on element-level
    const Epetra_MultiVector& global    ///< global (multi) vector
    );


  /// Locally extract a subset of values from a (column)-nodemap-based Epetra_MultiVector
  /*  \author g.bau
   *  \date 08/08
   */
  void ExtractMyNodeBasedValues
  (
    const DRT::Element* ele,                         ///< pointer to current element
    Epetra_SerialDenseVector& local,                 ///< local vector on element-level
    const Teuchos::RCP<Epetra_MultiVector>& global,  ///< global vector
    const int nsd                                    ///< number of space dimensions
    );

  /// For the given Epetra_Vector, equate the values at dofs of global node ids, original and copy.
  /// Both original and copy nodes should be owned by the same processor
  /*  \author sudhakar
   *  \date 12/13
   */
  void EquateValuesAtTheseNodes( Epetra_Vector& vec,                      ///< given vector
                                 Teuchos::RCP<DRT::Discretization> dis,   ///< underlying discretization
                                 int original,                            ///< id of original node. Values are copied from this node
                                 int copy );                              ///< id of node to which copied values are set

  /// Locally extract a subset of values from a (column)-nodemap-based Epetra_MultiVector
  /// and fill a local matrix that has implemented the (.,.) operator
  /*  \author g.bau
   *  \date 04/09
   */
  template <class M>
  void ExtractMyNodeBasedValues(
      const DRT::Element* ele,                       ///< pointer to current element
      M& localmatrix,                                ///< local matrix on element-level
      const Teuchos::RCP<Epetra_MultiVector>& global,///< global vector
      const int nsd                                  ///< number of space dimensions
      )
  {
    if (global==Teuchos::null) dserror("received a TEUCHOS::null pointer");
    if (nsd > global->NumVectors())
      dserror("Requested %d of %d available columns", nsd,global->NumVectors());
    const int iel = ele->NumNode(); // number of nodes
    if (((int) localmatrix.N())!=iel) dserror("local matrix has wrong number of columns");
    if (((int) localmatrix.M())!=nsd) dserror("local matrix has wrong number of rows");

    for (int i=0; i<nsd; i++)
    {
      // access actual component column of multi-vector
      double* globalcolumn = (*global)[i];
      // loop over the element nodes
      for (int j=0;j<iel;j++)
      {
        const int nodegid = (ele->Nodes()[j])->Id();
        const int lid = global->Map().LID(nodegid);
        if (lid<0) dserror("Proc %d: Cannot find gid=%d in Epetra_Vector",(*global).Comm().MyPID(),nodegid);
        localmatrix(i,j) = globalcolumn[lid];
      }
    }
    return;
  }

  /*!
  \brief extract local values from global node-based (multi) vector

  This function returns a column vector!

  \author henke
 */
  template <class M>
  void ExtractMyNodeBasedValues(
    const DRT::Element* ele,
    M& local,
    const Epetra_MultiVector& global)
{
  const int numnode = ele->NumNode();
  const int numcol = global.NumVectors();
  if (((int) local.N())!=1) dserror("local matrix must have one column");
  if (((int) local.M())!=numnode*numcol) dserror("local matrix has wrong number of rows");

  // loop over element nodes
  for (int i=0; i<numnode; ++i)
  {
    const int nodegid = (ele->Nodes()[i])->Id();
    const int lid = global.Map().LID(nodegid);
    if (lid<0) dserror("Proc %d: Cannot find gid=%d in Epetra_Vector",global.Comm().MyPID(),nodegid);

    // loop over multi vector columns (numcol=1 for Epetra_Vector)
    for (int col=0; col<numcol; col++)
    {
      double* globalcolumn = (global)[col];
      local((col+(numcol*i)),0) = globalcolumn[lid];
    }
  }
  return;
}


  /*!
  \brief extract location vector of the element dofs based on the numdof of the discretization

  Instead of the element function "location vector" here the discretization is
  used to identify the number of degrees of freedom of each node

  \author henke
 */
  void DisBasedLocationVector(
      const DRT::Discretization & dis,
      const DRT::Element& ele,
      std::vector<int>& lm,
      const int num);

  /*!
    \brief compute L2 projection of a dof based field onto a node based field in a least
    squares sense

    \return an Epetra_MultiVector based on the discret's node row map containing numvec vectors
            with the projected state

    \author Georg Hammerl
    \date 06/14
   */
  Teuchos::RCP<Epetra_MultiVector> ComputeNodalL2Projection(
      Teuchos::RCP<DRT::Discretization> dis,   ///< underlying discretization
      Teuchos::RCP<const Epetra_Vector> state, ///< state vector needed on element level
      const std::string statename,             ///< name of state which will be set
      const int numvec,                        ///< number of entries per node to project
      Teuchos::ParameterList& params,          ///< parameter list that contains the element action
      const int solvernumber                   ///< solver number for solving the resulting global system
    );


/*!
\brief handles random numbers through boost

\author wichmann
*/
class Random
{
public:
  Random();

  virtual ~Random();

  /// get a random number
  double Uni();

  /// get a random number
  double Normal();

  /// set the random seed
  void SetRandSeed(const unsigned int seed);

  /// set the range for the uniform rng
  void SetRandRange(const double lower, const double upper);

  /// set the mean and variance for the normal rng
  void SetMeanVariance(const double mean, const double var);

protected:
/// @name Random number generation
#if (BOOST_MAJOR_VERSION == 1) && (BOOST_MINOR_VERSION >= 47)
  /// random number engine
  boost::random::mt19937 rand_engine_;

  /// uniform random number distribution
  boost::random::uniform_real_distribution<double> uni_dist_;

  /// uniform random number generator
  boost::random::variate_generator<boost::random::mt19937&, boost::random::uniform_real_distribution<double> > uni_rand_no_;

  /// normal random number distribution
  boost::random::normal_distribution<double> norm_dist_;

  /// uniform random number generator
  boost::random::variate_generator<boost::random::mt19937&, boost::random::normal_distribution<double> > norm_rand_no_;
#else
  /********************************************************
   * The following declarations are deprecated in current *
   * Boosts, but they are all we got on FC8 and F12       *
   ********************************************************/
  /// random number engine
  boost::mt19937 rand_engine_;

  /// uniform random number distribution
  boost::uniform_real<double> uni_dist_;

  /// uniform random number generator
  boost::variate_generator<boost::mt19937&, boost::uniform_real<double> > uni_rand_no_;

  /// normal random number distribution
  boost::normal_distribution<double> norm_dist_;

  /// uniform random number generator
  boost::variate_generator<boost::mt19937&, boost::normal_distribution<double> > norm_rand_no_;
#endif
//@}
};

} // namespace UTILS
} // namespace DRT


#endif  // #ifndef UTILS_H




