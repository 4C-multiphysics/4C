/*----------------------------------------------------------------------*/
/*!
\file drt_globalproblem.H

\brief internal representation of an input file

<pre>
Maintainer: Ulrich Kuettler
            kuettler@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15238
</pre>
*/
/*----------------------------------------------------------------------*/


#ifndef DRT_GLOBALPROBLEM_H
#define DRT_GLOBALPROBLEM_H

#include <vector>

#include <Epetra_Comm.h>
#include <Teuchos_RCP.hpp>
#include <Teuchos_ParameterListAcceptorDefaultBase.hpp>

#include "drt_globalproblem_enums.H"
#include "drt_function.H"
#include "drt_timecurve.H"
#include "drt_resulttest.H"


using namespace std;
using Teuchos::RCP;
using Teuchos::ParameterList;

namespace IO
{
  class OutputControl;
  class InputControl;
  class ErrorFileControl;
}

namespace COMM_UTILS
{
  class NestedParGroup;
}

namespace MAT
{
namespace PAR
{
class Bundle;
}
}


namespace DRT
{
class Discretization;
class SingletonDestruction;

namespace INPUT
{
class DatFileReader;
}


/// Global problem instance that keeps the discretizations
/*!

  The global problem represents the input file passed to baci. This
  class organizes the reading of a dat file (utilizing the
  DatFileReader of course). That is way, in all but the most eccentric
  cases there will be exactly one object of this class during a baci
  run. This object contains all parameters read from the input file as
  well as any material definitions and even all the discretizations.

  <h3>Input parameters</h3>

  All input parameters are known by the global problem object. These
  parameters are guaranteed to be valid (because they passed the
  validation) and are guaranteed to be there (because default values
  have been set for all parameters missing from the input file.) This
  is Teuchos::ParameterList magic, that just requires the list of
  valid parameters in the file drt_validparameters.cpp to be
  complete.

  The algorithms are meant to ask the global problem object for their
  parameters and extract them from the respective parameter list
  directly.

  <h3>Discretizations</h3>

  The global problem object knows the discretizations defined by the
  input file. In order to access a particular discretization you get
  the global problem object and ask.

  <h3>Materials</h3>

  The global problem object knows the material descriptions from the
  input file. These are not to be confused with the material classes
  the elements know and work with. The global problem object does not
  keep track of gauss point material values, all that is known here
  are the definitions from the input file.

  <h3>Purpose</h3>

  baci evolved out of ccarat in a (somewhat) smooth fashion. The old
  ccarat used global C struct variables all over the place. It is
  indeed the aim of the global problem to collect these variables in
  one place and provide a sane interface to the data. The transition
  is already pretty advanced, however there are still many places
  where global variables are used. These places will have to be
  revised some day.

  The global problem class is still evolving.

  \note It is illegal to introduce new global variables in baci. It is
  illegal to use global variables where other means to do the job are
  available. We just did not get around to remove all of them yet.

  <h3>Singleton behavior</h3>

  \warning This is a guru only section!

  The global problem behaves like a singleton, so there is always one
  instance available. But you can have more than one instance of
  Problem. In normal situations this will not be needed. So don't
  bother. Just call the static Instance() function to get the global
  instance and access your discretizations.

  In the special case that you want to read more that one input file,
  however, you will need to handle the fields from each file
  separately. This is something you cannot do with ccarat's field
  variable so in that case you will have to rely on a second Problem
  instance.

  One artefact that comes from using global variables together with
  multiple Problem objects is the notion of activating of problem
  object. This translates to setting the global variable pointers to
  this Problem object's internal variables. Normally, if there is just
  one Problem object, this is done by default. If you need more that
  one, however, you will have to activate the global problems
  yourself.

  \author u.kue
  \date 06/07
 */
class Problem : public Teuchos::ParameterListAcceptorDefaultBase
{
public:

  /// @name Instances

  /// return an instance of this class
  static Problem* Instance(int num=0);

  /// return number of problem instances
  static unsigned NumInstances() { return instances_.size(); }

  /// calculation done, clean up
  /*!
    There can be a variety of objects to a problem. Some of them might
    require proper cleanup. Make sure we always do it.
   */
  static void Done();

  /// register singleton objects that need explicit destruction
  void Register(DRT::SingletonDestruction * sd) { sds_.push_back(sd); }

  //@}

  ~Problem();

  /// @name Input

  /// read global parameters
  void ReadParameter(DRT::INPUT::DatFileReader& reader);

  /// setup the discretizations
  void ReadFields(DRT::INPUT::DatFileReader& reader, const bool readmesh = true);

  /// set up micro-scale discretizations in case of structure multi-scale simulations
  void ReadMicroFields(DRT::INPUT::DatFileReader& reader);

  /// set up supporting processors for micro-scale discretizations
  void ReadMicrofields_NPsupport();

  /// set up multilvel discetizations for mulit level monte carlo simulations
  void ReadMultiLevelDiscretization(DRT::INPUT::DatFileReader& reader);

  /// input of materials
  void ReadMaterials(DRT::INPUT::DatFileReader& reader);

  /// setup map between materials of original and cloned elements
  void ReadClonedMaterials(DRT::INPUT::DatFileReader& reader);

  /// input of conditions
  void ReadConditions(DRT::INPUT::DatFileReader& reader);

  /// input of time curves, functions and result tests
  void ReadTimeFunctionResult(DRT::INPUT::DatFileReader& reader);

  /// input of knots for isogeometric analysis
  void ReadKnots(DRT::INPUT::DatFileReader& reader);

  /// set restart step which was read from the command line
  void SetRestartStep(int r);

  //@}

  /// @name General query methods
  /// Once and for all definitions

  /// give enum of my problem type
  PROBLEM_TYP ProblemType() const;

  /// give string name of my problem type
  std::string ProblemName() const;

  /// return restart step
  int Restart() const;

  /// number of space dimensions (as specified in the input file)
  int NDim() const;

  // give string name of my basis function type (polynomial/nurbs)
  std::string SpatialApproximation() const;

  //@}

  /// @name Control file

  /// create control file for output and read restart data if required
  void OpenControlFile(const Epetra_Comm& comm, std::string inputfile, std::string prefix, std::string restartkenner);

  /// error files
  void OpenErrorFile(const Epetra_Comm& comm, std::string prefix);

  /// control file for restart read
  Teuchos::RCP<IO::InputControl> InputControlFile() { return inputcontrol_; }

  /// control file for normal output
  Teuchos::RCP<IO::OutputControl> OutputControlFile() { return outputcontrol_; }

  /// control error files
  Teuchos::RCP<IO::ErrorFileControl> ErrorFile() { return errorfilecontrol_; }

  /// write parameters read from input file for documentation
  void WriteInputParameters();

  //@}

  /// @name Parameters read from file

  /// Set parameters from a parameter list and return with default values.
  void setParameterList(Teuchos::RCP< Teuchos::ParameterList > const &paramList);

  /// Return a const parameter list of all of the valid parameters that this->setParameterList(...) will accept.
  Teuchos::RCP<const Teuchos::ParameterList> getValidParameters() const;

  /// @name Nested parallelism group

  /// nested parallelism group is initialized
  void NPGroup(
    int groupId,  //!< group id
    int ngroup, //!< number of groups in nested parallelism
    std::map<int, int> lpidgpid,  //!< map of local and global proc ids
    Teuchos::RCP<Epetra_Comm> lcomm,  //!< local communicator
    Teuchos::RCP<Epetra_Comm> gcomm,  //!< global communicator
    NP_TYPE npType  //!< nested parallelism type
    );

  /// return nested parallelism group
  Teuchos::RCP<COMM_UTILS::NestedParGroup> GetNPGroup();

  //@}

  //@}

  /// @name Input parameter sections
  /// direct access to parameters from input file sections

//<<<<<<< .mine
//  const Teuchos::ParameterList& DiscretisationParams() const { return getParameterList()->sublist("DISCRETISATION"); }
//  const Teuchos::ParameterList& ProblemTypeParams() const { return getParameterList()->sublist("PROBLEM TYP"); }
//  const Teuchos::ParameterList& ProblemSizeParams() const { return getParameterList()->sublist("PROBLEM SIZE"); }
//=======
//>>>>>>> .r16680
  const Teuchos::ParameterList& MeshfreeParams() const { return getParameterList()->sublist("MESHFREE"); }
  const Teuchos::ParameterList& IOParams() const { return getParameterList()->sublist("IO"); }
//<<<<<<< .mine
//=======
////  const Teuchos::ParameterList& DiscretisationParams() const { return getParameterList()->sublist("DISCRETISATION"); }
//>>>>>>> .r16680
  const Teuchos::ParameterList& DesignDescriptionParams() const { return getParameterList()->sublist("DESIGN DESCRIPTION"); }
  const Teuchos::ParameterList& PatSpecParams() const { return getParameterList()->sublist("PATIENT SPECIFIC"); }
  const Teuchos::ParameterList& StructuralDynamicParams() const { return getParameterList()->sublist("STRUCTURAL DYNAMIC"); }
  const Teuchos::ParameterList& InverseAnalysisParams() const { return getParameterList()->sublist("INVERSE ANALYSIS"); }
  const Teuchos::ParameterList& MultiLevelMonteCarloParams() const { return getParameterList()->sublist("MULTI LEVEL MONTE CARLO"); }
  const Teuchos::ParameterList& MeshtyingAndContactParams() const { return getParameterList()->sublist("MESHTYING AND CONTACT"); }
  const Teuchos::ParameterList& InteractionPotentialParams() const { return getParameterList()->sublist("INTERACTION POTENTIAL"); }
  const Teuchos::ParameterList& FluctuatingHydrodynamicsParams() const { return getParameterList()->sublist("FLUCTUATING HYDRODYNAMICS"); }
  const Teuchos::ParameterList& StatisticalMechanicsParams() const { return getParameterList()->sublist("STATISTICAL MECHANICS"); }
  const Teuchos::ParameterList& ThermalDynamicParams() const { return getParameterList()->sublist("THERMAL DYNAMIC"); }
  const Teuchos::ParameterList& TSIDynamicParams() const { return getParameterList()->sublist("TSI DYNAMIC"); }
  const Teuchos::ParameterList& FluidDynamicParams() const { return getParameterList()->sublist("FLUID DYNAMIC"); }
  const Teuchos::ParameterList& ScalarTransportDynamicParams() const { return getParameterList()->sublist("SCALAR TRANSPORT DYNAMIC"); }
  const Teuchos::ParameterList& FS3IControlParams() const { return getParameterList()->sublist("FS3I CONTROL"); }
  const Teuchos::ParameterList& CombustionDynamicParams() const { return getParameterList()->sublist("COMBUSTION CONTROL"); }
  const Teuchos::ParameterList& AleDynamicParams() const { return getParameterList()->sublist("ALE DYNAMIC"); }
  const Teuchos::ParameterList& FSIDynamicParams() const { return getParameterList()->sublist("FSI DYNAMIC"); }
  const Teuchos::ParameterList& XFEMGeneralParams() const { return getParameterList()->sublist("XFEM GENERAL"); }
  const Teuchos::ParameterList& XFluidDynamicParams() const { return getParameterList()->sublist("XFLUID DYNAMIC"); }
  const Teuchos::ParameterList& LOMAControlParams() const { return getParameterList()->sublist("LOMA CONTROL"); }
  const Teuchos::ParameterList& BIOFILMControlParams() const { return getParameterList()->sublist("BIOFILM CONTROL"); }
  const Teuchos::ParameterList& ELCHControlParams() const { return getParameterList()->sublist("ELCH CONTROL"); }
  const Teuchos::ParameterList& ArterialDynamicParams() const { return getParameterList()->sublist("ARTERIAL DYNAMIC"); }
  const Teuchos::ParameterList& ReducedDAirwayDynamicParams() const { return getParameterList()->sublist("REDUCED DIMENSIONAL AIRWAYS DYNAMIC"); }
  const Teuchos::ParameterList& PoroelastDynamicParams() const { return getParameterList()->sublist("POROELASTICITY DYNAMIC"); }
  const Teuchos::ParameterList& PoroScatraControlParams() const { return getParameterList()->sublist("POROSCATRA CONTROL"); }
  const Teuchos::ParameterList& SSIControlParams() const { return getParameterList()->sublist("SSI CONTROL"); }
  const Teuchos::ParameterList& OptimizationControlParams() const { return getParameterList()->sublist("TOPOLOGY OPTIMIZATION CONTROL"); }
  const Teuchos::ParameterList& SearchtreeParams() const { return getParameterList()->sublist("SEARCH TREE"); }
  const Teuchos::ParameterList& StructuralNoxParams() const { return getParameterList()->sublist("STRUCT NOX"); }
  const Teuchos::ParameterList& ConditionNamesParams() const { return getParameterList()->sublist("CONDITION NAMES"); }

  const Teuchos::ParameterList& SolverParams(int solverNr) const;

  const Teuchos::ParameterList& UMFPACKSolverParams();

  //@}

  /// @name Discretizations

  /// get access to a particular discretization
  RCP<DRT::Discretization> GetDis(const std::string name) const;

  /// tell number of known fields
  unsigned NumFields() const { return discretizationmap_.size(); }

  /// tell names of known fields
  std::vector<std::string> GetDisNames() const;

  /// check whether a certain discretization exists or not
  bool DoesExistDis(const std::string name) const;

  /// add a discretization to the global problem
  void AddDis(const std::string name, RCP<Discretization> dis);


  //@}

  /// @name Materials

  /// return pointer to materials bundled to the problem
  Teuchos::RCP<MAT::PAR::Bundle> Materials() { return materials_; }

  //@}

  std::map<std::pair<string,string>,std::map<int,int> > ClonedMaterialMap() { return clonefieldmatmap_; }

  /// @name Spatial Functions

  /// return a specified function
  DRT::UTILS::Function& Funct(int num);

  //@}

  /// @name Spatial Functions

  /// return a specified time curve
  DRT::UTILS::TimeCurve& Curve(int num);

  //@}

  /// @name Result Tests

  /// Do the testing
  void TestAll(const Epetra_Comm& comm) { resulttest_.TestAll(comm); }

  /// add field specific result test object
  void AddFieldTest(Teuchos::RCP<ResultTest> test) { resulttest_.AddFieldTest(test); }

  //@}

private:

  /// private default constructor to disallow creation of instances
  Problem();

  /// no copying
  Problem(const Problem&);

  /// no copying
  Problem& operator=(const Problem&);

  /// @name Private access to parameters from certain input file sections

  /// for internal use only! Use Restart(), SpatialApproximation() etc. instead !!!
  const Teuchos::ParameterList& ProblemTypeParams() const { return getParameterList()->sublist("PROBLEM TYP"); }

  /// for internal use only! Use NDim() to access the number of space dimensions
  const Teuchos::ParameterList& ProblemSizeParams() const { return getParameterList()->sublist("PROBLEM SIZE"); }
  //@}

  /// the single instance
  static vector<Problem* > instances_;

  /// the problem type
  PROBLEM_TYP probtype_;

  /// the restart step (given by command line or input file)
  int restartstep_;

  /// discretizations of this problem
  map<std::string,RCP<Discretization> > discretizationmap_;

  /// keep a list of all active element implementations
  vector<DRT::SingletonDestruction *> sds_;

  /// material bundle
  Teuchos::RCP<MAT::PAR::Bundle> materials_;

  /// basket of spatial function
  DRT::UTILS::FunctionManager functionmanager_;

  /// basket of time curves
  DRT::UTILS::TimeCurveManager timecurvemanager_;

  /// all test values we might have
  DRT::ResultTestManager resulttest_;

  /// map of coupled fields and corresponding material IDs (needed for cloning
  /// of discretizations)
  std::map<std::pair<string,string>,std::map<int,int> > clonefieldmatmap_;

  /// nested parallelism group
  Teuchos::RCP<COMM_UTILS::NestedParGroup> npgroup_;

  /// @name File IO

  Teuchos::RCP<IO::InputControl>  inputcontrol_;
  Teuchos::RCP<IO::OutputControl> outputcontrol_;
  Teuchos::RCP<IO::ErrorFileControl> errorfilecontrol_;  ///< error file handles

  //@}
};

}

#endif
