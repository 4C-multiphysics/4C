/*!----------------------------------------------------------------------
\file drt_periodicbc.cpp

\brief Methods to apply periodic boundary conditions


<pre>
Maintainer: Peter Gamnitzer
            gamnitzer@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15235
</pre>

*----------------------------------------------------------------------*/
#ifdef CCADISCRET
#ifdef TRILINOS_PACKAGE
#ifndef PERIODICBC_H
#define PERIODICBC_H

#include "Teuchos_RefCountPtr.hpp"
#include "drt_discret.H"
#include "drt_dofset.H"
#include "drt_pbcdofset.H"
#include "drt_nodematchingoctree.H"
#include <Teuchos_TimeMonitor.hpp>

using namespace Teuchos;

/*!
\class PeriodicBoundaryConditions

\brief  update dofrowmap and dofsets for periodic boundary conditions

        o effects distribution of master and slave nodes. Master and
          slave are owned by one proc afterwards.
          
        o effects ghosting of nodes. Master and slave nodes are ghosted
          in pairs.
          
        o passes list of coupled nodes to the dofset
        

\author gammi

        

<pre>
Maintainer: Peter Gamnitzer
            gamnitzer@lnm.mw.tum.de
            http://www.lnm.mw.tum.de
            089 - 289-15235
</pre>

*/
class PeriodicBoundaryConditions
{
public:

  /*!
  \brief Standard Constructor

  This method gets the periodic boundary conditions from the discretisation
  and creates some empty maps which will be filled by the node matching.

  
  \param  dis (i) Discretisation which contains the nodes of the
                  periodic boundary condition

                  
  \return void
  
  */
  PeriodicBoundaryConditions(RefCountPtr<DRT::Discretization> dis);
  
  /*!
  \brief Destructor

  */
  virtual ~PeriodicBoundaryConditions();


  //! @name Framework

  /*!
    \brief This method contains a loop over all existing pairs of
    periodic boundary conditions (always two surfaces (3d) or lines
    (2d) belong to the same condition. They are usually referred to
    as corresponding "master" and "slave" conditons).

    For every pair a node coupling is generated by a call to the
    method CreateNodeCouplingForSinglePBC. This means, that we have
    the information which masternode id is coupled to which
    slavenode id (map midtosid).

    This node coupling is added to the connectivity map of all
    previous periodic boundary conditions (this allows pbcs in
    several spatial directions which are nescessary for example
    for 3d channel flows).

    After this loop, the nodes and elements are distributed among the
    processors according to the generated connectivity. During this
    procedure, the dof set is changed (coupled dofs are eliminated)
    and the dofs are renumbered.
    
  \return void

  */
  void UpdateDofsForPeriodicBoundaryConditions();
  //@}


  //! @name Methods to process one pair of pbcs

  
  /*!
  \brief Couple nodes for specific pair of periodic boundary conditions.

  On input, this method needs two lists of nodes (master- and
  slavenodes). For every masternode, the method will look for the
  "closest" slavenode and insert this connectivity in the midtosid map.
  In this context, "closest" means, that one coordinate of the slavenode
  is replaced by the coordinate of the masternode plane for the search
  of the closest point. This is controlled by the parameter dofsforpbcplane,
  an int vector of length 3:


                     (1,1,0)    xy-plane
  
                     (0,1,1)    yz-plane
  
                     (1,0,1)    xz-plane
                                                                      
  The search algorithm will substitute the coordinate with 0 of the
  slavenodes by the corresponding coordinate of the masternode plane
  to calculate the closest node.
  
  Keep in mind that the masternodes and the slavenodes are distributed
  among several processors. The connectivity information will be only
  available on the proc which owns the specific masternode --- but the
  corresponding closest slavenode will be searched on all procs!

  The node matching is created in two steps. Step one generates a
  processor local octree that contains all masternodes available on
  this proc (NodeMatchingOctree nodematchingoctree).
  The second part searches for the closest slave node on
  all processors (nodematchingoctree.CreateGlobalNodeMatching).
  
  
  \param  midtosid        (o) map from master to slavenodes
  \param  masternodeids   (i) all master node ids
  \param  slavenodeids    (i) all slave node ids
  \param  dofsforpbcplane (i) periodic boundary is in this plane

  \return void
  
  */
  void CreateNodeCouplingForSinglePBC(
    map<int,int>       &midtosid,
    const vector <int>  masternodeids,
    const vector <int>  slavenodeids,
    const vector <int>  dofsforpbcplane);

  /*!
  \brief Add the connectivity from this condition (midtosid, on input)
  to the connectivity of all previously processed periodic boundary
  conditions (allcoupledrownodes_).

  We are interested in a map of all coupled nodes. For nodes, which have
  several periodic boundary conditions (for example edge nodes for
  3d channel flow, see figure below), only one node (the pure master node)
  is allowed to have its own degrees of freedom. The mixed master/slave
  nodes must be eliminated and all connectivity information must be
  transferred to the pure master.

        MM----------MS

         |xxxxxxxxxx|

         |xxxxxxxxxx|

         |xxxxxxxxxx|

        SM----------SS
         
  Since not all information is available on every proc, the completion
  of this coupling requires some additional communication of the coupling
  behaviour of multiple coupled nodes.
  

  \param  midtosid        (i) map from master to slavenodes of current condition
  \param  pbcid           (i) the id of the current periodic boundary condition
  
  \return void

  */
  void AddConnectivity(
    map<int,int> &midtosid,const int pbcid);
  
  //@}


  //! @name Methods to finish the coupling after the list of coupled nodes is known.

  /*!
  \brief Redistribute the nodes and assign the dofs to the
  current distribution of nodes

  o Create a new rownodemap using the map allcoupledrownodes_

  o Build graph and temporary nodecolmap

  o Fix ghosting (if slaves are ghosted, masternodes have to
    be ghosted, too)
    This leads to the newnodecolmap

  o Create a new dofset specialisation for periodic boundary
    conditions

  o Redistribute nodes and call FillComplete including a call
    to the modified AssignDegreeesOfFreedom
    
  \return void

  */
  void RedistributeAndCreateDofCoupling();
  
  
  //@}

  
protected:
  //!\brief the discretisation
  RefCountPtr<DRT::Discretization> discret_;
  
  //!\brief number of pairs of periodic boundary conditions
  int                     numpbcpairs_;

  //!\brief vector of periodic surface boundary conditions
  vector<DRT::Condition*> mysurfpbcs_;

  //!\brief map connecting master to slave nodes owned by this proc
  //       master node -> list of his slave node(s)
  RefCountPtr<map<int,vector<int> > > allcoupledrownodes_;

  //!\brief map connecting master to slave nodes owned or ghosted by this proc
  //       master node -> list of his slave node(s)
  RefCountPtr<map<int,vector<int> > > allcoupledcolnodes_;



  //!\brief time measurement (total)
  RefCountPtr<Time> timepbctot_     ;
  //!\brief time measurement (create master slave matching for pairs)
  RefCountPtr<Time> timepbcmidtosid_;
  //!\brief time measurement (create octree)
  RefCountPtr<Time> timepbcmidoct_  ;
  //!\brief time measurement (search in octree)
  RefCountPtr<Time> timepbcmidmatch_;
  //!\brief time measurement (redistribute nodes)
  RefCountPtr<Time> timepbcreddis_  ;
  //!\brief time measurement (add connectivity to previous pbcs)
  RefCountPtr<Time> timepbcaddcon_  ;
  //!\brief time measurement (repair ghosting)
  RefCountPtr<Time> timepbcghost_   ;
  //!\brief time measurement (make colmap for ghosting) 
  RefCountPtr<Time> timepbcmakeghostmap_   ;
  //!\brief time measurement (discret->Redistribute)
  RefCountPtr<Time> timepbcrenumdofs_   ;

  
  //!\brief time measurement (total)
  RefCountPtr<TimeMonitor> tm0_ref_ ;
  //!\brief time measurement (create master slave matching for pairs)
  RefCountPtr<TimeMonitor> tm1_ref_ ;
  //!\brief time measurement (create octree)
  RefCountPtr<TimeMonitor> tm2_ref_ ;
  //!\brief time measurement (search in octree)
  RefCountPtr<TimeMonitor> tm3_ref_ ;
  //!\brief time measurement (add connectivity to previous pbcs)
  RefCountPtr<TimeMonitor> tm4_ref_ ;
  //!\brief time measurement (redistribute nodes)
  RefCountPtr<TimeMonitor> tm5_ref_ ;
  //!\brief time measurement (make row and colmap for ghosting) 
  RefCountPtr<TimeMonitor> tm6_ref_ ;
  //!\brief time measurement (repair ghosting)
  RefCountPtr<TimeMonitor> tm7_ref_ ;
  //!\brief time measurement (discret->Redistribute)
  RefCountPtr<TimeMonitor> tm8_ref_ ;
  
};

#endif  // #ifndef PERIODICBC_H
#endif  // #ifdef TRILINOS_PACKAGE
#endif  // #ifdef CCADISCRET
