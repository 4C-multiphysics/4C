/*----------------------------------------------------------------------*/
/*! \file

\brief Collection of functions that are not problem-specific

The functions in this file are not problem-specific and may be useful for a number of applications.


\level 3

*/
/*----------------------------------------------------------------------*/



#include "drt_function.H"

namespace DRT
{
  namespace UTILS
  {
    /**
     * @brief translation of a function's coordinate system by another function
     *
     * This class defines a translated function generated by the composition of a local and an
     * origin function. The origin function \f$ g(x) \f$ determines the location of the coordinate
     * system used for evaluation of the local function \f$ f(x) \f$. Mathematically, the translated
     * function \f$ h(x,t) \f$ can be written as,
     *
     * \f[
     *    h(x,t) = f(x-g(x,t),t)
     * \f]
     *
     * Thus, \f$ g(x) \f$ is required to have three components for the three spatial dimensions.
     */
    class TranslatedFunction : public Function
    {
     public:
      /**
       * \brief Construct a new TranslatedFunction
       *
       * @param origin function describing the position of the local origin
       * @param local function to evaluate in the translated coordinate system
       */
      TranslatedFunction(Teuchos::RCP<Function> origin, Teuchos::RCP<Function> local);

      /**
       * \brief Evaluation of the translated function
       *
       * Evaluate the specified component of the translated function at the specified position and
       * point in time.
       *
       * @param index (i) For vector-valued functions, index defines the
                       function-component which should be evaluated
       * @param t     (i) The point in time in which the
                       function will be evaluated
       * @param x     (i) The point in 3-dimensional space in which the
                       function will be evaluated
         @return function value
       */
      double Evaluate(int index, const double* x, double t) override;

      /**
       * \brief Evaluate time derivative and value of the translated function
       *
       * Evaluate the specified component of the translated function at the specified position and
       * point in time and calculate the time derivative.
       *
       * @param index (i) For vector-valued functions, index defines the
                       function-component which should be evaluated
       * @param t     (i) The point in time in which the
                       function will be evaluated
       * @param x     (i) The point in 3-dimensional space in which the
                       function will be evaluated
       * @param deg   (i) maximum time derivative degree, has to be 0 or 1 for this implementation
         @return vector containing value and derivative
       */
      std::vector<double> EvaluateTimeDerivative(int index,  ///< component of function
          const double* x,                                   ///< coordinates
          double t,                                          ///< time
          unsigned deg                                       ///< degree of maximal derivative
          ) override;

      //! number of spatial dimensions required to shift the origin
      const static int nsd_originTranslation = 3;

     private:
      //! function describing the position of the local origin
      Teuchos::RCP<Function> originFunction_;
      //! function to evaluate in the translated coordinate system
      Teuchos::RCP<Function> localFunction_;
    };

    /// special implementation for controlled rotations
    class ControlledRotationFunction : public Function
    {
     public:
      /// ctor
      ControlledRotationFunction(std::string fileName, std::string type, double origin_x,
          double origin_y, double origin_z);

      /// evaluate function at given position in space
      double Evaluate(const int index, const double* x, double t);

      /// type of physics that a controlled rotation is applied to
      enum PhysicalField
      {
        Structure,
        Fluid
      };

     private:
      //! the physics type used for this function
      PhysicalField physicsType_;

      //! Origin, about which the rotation shall be performed
      LINALG::Matrix<3, 1> origin_;

      //! Time of previous time step (at t-deltaT)
      double timeOld_;

      //! Number of maneuver cells (variables)
      const int NUMMANEUVERCELLS_;

      //! Number of maneuvers
      int numManeuvers_;

      //! Double Vector containing maneuver information (t, omegaDot_x_B, omegaDot_y_B,
      //! omegaDot_z_B)
      std::vector<double> maneuvers_;

      //! Previous angular acceleration (at t-deltaT)
      LINALG::Matrix<3, 1> omegaDotOld_B_;

      //! Current angular rate (at t)
      LINALG::Matrix<3, 1> omega_B_;

      //! Satellite's current attitude trafo matrix from B- to I-system (at t)
      LINALG::Matrix<3, 3> satAtt_dcm_IB_;

      //! Satellite's current attitude quaternion from B- to I-system (at t)
      LINALG::Matrix<4, 1> satAtt_q_IB_;
    };

    /// special implementation for acceleration profiles
    class AccelerationProfileFunction : public Function
    {
     public:
      /// ctor
      AccelerationProfileFunction(std::string fileName);

      /// evaluate function at given position in space
      double Evaluate(const int index, const double* x, double t);

     private:
      //! Time of previous time step (at t-deltaT)
      double timeOld_;

      //! Number of cells (variables) (time + 3-dim acc = 4)
      const int NUMACCELERATIONCELLS_;

      //! Number of acceleration rows
      int numAccelerations_;

      //! Double Vector containing acceleration information (t, acc_x_B, acc_y_B, acc_z_B)
      std::vector<double> accelerations_;

      //! Current acceleration (at t)
      LINALG::Matrix<3, 1> acc_B_;
    };

    /**
     * @brief special implementation of a 1D polynomial function
     *
     * This class defines a generic polynomial that that takes one argument. The polynomial can be
     * evaluated and the first derivative is also provided.
     *
     * This class does circumvent using automatic differentiation and may be used in
     * performance-sensitive applications (e.g. operations on Gauss-point level).
     * In particular, evaluating the derivative is faster for this function compared to
     * a VariableExprFunction representing the same polynomial.
     */
    class FastPolynomialFunction : public Function
    {
     public:
      /**
       * ctor
       *
       * @param coefficients the coefficients of the monomials in ascending order
       */
      FastPolynomialFunction(std::vector<double>* coefficients);

      /**
       * @brief Evaluate the polynomial.
       *
       * This is the only supported evaluation call for this class
       *
       * @param argument point to evaluate
       * @return value of the polynomial at `argument`
       */
      double Evaluate(const double argument) const;

      /**
       * Evaluate first derivative of polynomial.
       *
       * @param argument point to evaluate
       * @return value of first derivative of polynomial at `argument`
       */
      double EvaluateDerivative(const double argument) const;

      /*!
      \brief evaluate function at given time and position

      \param index (i) For vector-valued functions, index defines the
                       function-component which should be evaluated
                       For scalar functions, index is always set to 0
      \param t     (i) The point in time in which the
                       function will be evaluated
      \param x     (i) The point in 3-dimensional space in which the
                       function will be evaluated
      \throws dserror
      */
      virtual double Evaluate(const int index, const double* x, double t)
      {
        dserror("FastPolynomialFunction does not support this call.");
        return 0;
      }

     private:
      //! internal polynomial representation
      const DRT::UTILS::Polynomial* const mypoly_;
    };
  }  // namespace UTILS
}  // namespace DRT
