/*----------------------------------------------------------------------*/
/*!
 \file wall1_poro_p1.H

 \brief

 <pre>
   Maintainer: Anh-Tu Vuong
               vuong@lnm.mw.tum.de
               http://www.lnm.mw.tum.de
               089 - 289-15264
 </pre>
 *----------------------------------------------------------------------*/


#ifndef WALL1_PORO_P1_H_
#define WALL1_PORO_P1_H_

#include "wall1_poro.H"

namespace DRT
{
// forward declarations
class Discretization;

namespace ELEMENTS
{

  /*!
  \brief A C++ version of a 2 dimensional solid element with modifications for porous media

  */
  template<DRT::Element::DiscretizationType distype>
  class Wall1_PoroP1 : public Wall1_Poro<distype>
  {

    typedef DRT::ELEMENTS::Wall1_Poro<distype> my;

  public:

    //@}
    //! @name Constructors and destructors and related methods

    /*!
    \brief Standard Constructor

    \param id : A unique global id
    \param owner : elements owner
    */
    Wall1_PoroP1(int id, int owner);

    /*!
    \brief Copy Constructor

    Makes a deep copy of a Element

    */
    Wall1_PoroP1(const Wall1_PoroP1& old);

    /*!
    \brief Destructor

    */
    virtual ~Wall1_PoroP1(){};

    //@}

    //! number of dofs per node
    static const int noddof_ = my::noddof_+1;

    //! total dofs per element
    static const int numdof_ = noddof_ * my::numnod_;

    //! @name Acess methods

    /*!
    \brief Deep copy this instance of Solid3 and return pointer to the copy

    The Clone() method is used from the virtual base class Element in cases
    where the type of the derived class is unknown and a copy-ctor is needed

    */
    DRT::Element* Clone() const ;

    /*!
    \brief Return unique ParObject id

    every class implementing ParObject needs a unique id defined at the
    top of this file.
    */
    virtual int UniqueParObjectId() const;

    /*!
    \brief Pack this class so it can be communicated

    \ref Pack and \ref Unpack are used to communicate this element

    */
    virtual void Pack(DRT::PackBuffer& data) const;

    /*!
    \brief Unpack data from a char vector into this class

    \ref Pack and \ref Unpack are used to communicate this element

    */
    virtual void Unpack(const std::vector<char>& data);

    /// Get vector of RCPs to the lines of this element
    virtual std::vector<Teuchos::RCP<DRT::Element> > Lines();

    /// Get vector of RCPs to the surfaces of this element
    virtual std::vector<Teuchos::RCP<DRT::Element> > Surfaces();

    //! @name Access methods

    /*!
    \brief Get number of degrees of freedom of a certain node
           (implements pure virtual DRT::Element)

    The element decides how many degrees of freedom its nodes must have.
    As this may vary along a simulation, the element can redecide the
    number of degrees of freedom per node along the way for each of it's nodes
    separately.
    */
    virtual int NumDofPerNode(const DRT::Node& node) const {return 3;}

    /*!
    \brief Get number of degrees of freedom of a certain node in case of multiple
           dofsets (implements pure virtual DRT::Element)

    The element decides how many degrees of freedom its nodes must have.
    As this may vary along a simulation, the element can redecide the
    number of degrees of freedom per node along the way for each of it's nodes
    separately.
    */
    virtual int NumDofPerNode(const unsigned nds, const DRT::Node& node, const std::string disname) const
    {
      /* here we assume the dofset numbers to be assigned as follows
       *     structure = dofset 0
       *     fluid     = dofset 1
       *     scatra    = dofset 2
       * this is kind of implicit. One might think of a better solution ...
      */
      if (nds==0)
        // structure, 2D: 2+1 Dofs per node
        return NumDofPerNode(node);
      else if (nds==1)
        // in case of porous media: nds=1 (second discretization) fluid: 3Dof/Node
        return 3;
      else if (nds==2)
        // in case of scalar transport in porous media: nds=2 (third discretization) scatra: 1Dof/Node
        return 1;
      dserror("invalid number of dof sets");
      return -1;
    };

    /*!
    \brief Print this element
    */
    void Print(std::ostream& os) const  ;

    virtual DRT::ElementType & ElementType() const;

    //@}

    //! @name Evaluation

    /*!
    \brief Evaluate an element

    Evaluate So_tet4fbar element stiffness, mass, internal forces, etc.

    If NULL on input, the controlling method does not expect the element
    to fill these matrices or vectors.

    \return 0 if successful, negative otherwise
    */
    virtual int Evaluate
    (
      Teuchos::ParameterList& params,  ///< ParameterList for communication between control routine and elements
      DRT::Discretization&      discretization,  ///< pointer to discretization for de-assembly
      DRT::Element::LocationArray& la, ///< location array for de-assembly
      Epetra_SerialDenseMatrix& elemat1,  ///< (stiffness-)matrix to be filled by element.
      Epetra_SerialDenseMatrix& elemat2,  ///< (mass-)matrix to be filled by element.
      Epetra_SerialDenseVector& elevec1,  ///< (internal force-)vector to be filled by element
      Epetra_SerialDenseVector& elevec2,  ///< vector to be filled by element
      Epetra_SerialDenseVector& elevec3  ///< vector to be filled by element
    );

    /// Evaluate a Neumann boundary condition
    ///
    /// this method evaluates a surfaces Neumann condition on the wall element
    ///
    /// \return 0 if successful, negative otherwise
    virtual int EvaluateNeumann(
      Teuchos::ParameterList& params,   ///< (in/out) ParameterList for communication between control routine
                               ///< and elements
      DRT::Discretization& discretization,  ///< A reference to the underlying discretization
      DRT::Condition& condition,  ///<  The condition to be evaluated
      std::vector<int>& lm,  ///< location vector of this element
      Epetra_SerialDenseVector& elevec1,  ///< vector to be filled by element. If NULL on input
      Epetra_SerialDenseMatrix* elemat1 = NULL);

    //@}

    //! initialize the inverse of the jacobian and its determinant in the material configuration
    virtual void InitElement();

    //! return number of degrees of freedom
    virtual int NumDof(){return 3;};

    //! return whether this element has more degrees of freedom than standard solid elements
    virtual bool HasExtraDof(){return true;}

  protected:

    //! don't want = operator
    Wall1_PoroP1& operator = (const Wall1_PoroP1& old);

    /*!
    \brief Evaluate an element

    Evaluate So3_poro element stiffness, mass, internal forces, etc.
    Templated evaluate routine of element matrixes

    If NULL on input, the controlling method does not expect the element
    to fill these matrices or vectors.

    \return 0 if successful, negative otherwise
    */
    virtual int MyEvaluate
    (
      Teuchos::ParameterList& params,  ///< ParameterList for communication between control routine and elements
      DRT::Discretization&      discretization,  ///< pointer to discretization for de-assembly
      DRT::Element::LocationArray& la, ///< location array for de-assembly
      Epetra_SerialDenseMatrix& elemat1,  ///< (stiffness-)matrix to be filled by element.
      Epetra_SerialDenseMatrix& elemat2,  ///< (mass-)matrix to be filled by element.
      Epetra_SerialDenseVector& elevec1,  ///< (internal force-)vector to be filled by element
      Epetra_SerialDenseVector& elevec2,  ///< vector to be filled by element
      Epetra_SerialDenseVector& elevec3  ///< vector to be filled by element
    );

    //! Calculate nonlinear stiffness and internal force for poroelasticity problems
    void nlnstiff_poroelast(
        std::vector<int>& lm, ///< location matrix
        LINALG::Matrix<my::numdim_, my::numnod_>&               disp,         // current displacements
        LINALG::Matrix<my::numdim_, my::numnod_>&               vel,          // current velocities
        LINALG::Matrix<my::numnod_, 1>*               porosity,
        //    std::vector<double>&      residual,       ///< current residual displ
        LINALG::Matrix<my::numdim_,my::numnod_> & evelnp, //< fluid velocity of element
        LINALG::Matrix<my::numnod_,1> & epreaf, //< fluid pressure of element
        LINALG::Matrix<numdof_,numdof_>* stiffmatrix, ///< element stiffness matrix
        LINALG::Matrix<numdof_,numdof_>* reamatrix, // element reactive matrix
        LINALG::Matrix<numdof_,1>* force, ///< element internal force vector
        Teuchos::ParameterList& params ///< algorithmic parameters e.g. time
        );

    //! Calculate coupling terms in nonlinear stiffness and internal force for poroelasticity problems
    void coupling_poroelast(
        std::vector<int>& lm, ///< location matrix
        LINALG::Matrix<my::numdim_, my::numnod_>&               disp,         // current displacements
        LINALG::Matrix<my::numdim_, my::numnod_>&               vel,          // current velocities
        LINALG::Matrix<my::numnod_, 1>*               porosity,
        LINALG::Matrix<my::numdim_, my::numnod_> & evelnp, //< fluid velocity of element
        LINALG::Matrix<my::numnod_,1> & epreaf, //< fluid pressure of element
        LINALG::Matrix<numdof_,(my::numdim_+1)*my::numnod_>* stiffmatrix, ///< element stiffness matrix
        LINALG::Matrix<numdof_,(my::numdim_+1)*my::numnod_>* reamatrix, //< element reactive matrix
        LINALG::Matrix<numdof_,1>* force, ///< element internal force vector
        Teuchos::ParameterList& params); ///< algorithmic parameters e.g. time

    //compute porosity at gausspoint and linearization of porosity w.r.t. structural displacements
    virtual void ComputePorosityAndLinearization(Teuchos::ParameterList&                params,
                                                 const double&                          press,
                                                 const double&                          J,
                                                 const int&                             gp,
                                                 const LINALG::Matrix<my::numnod_,1>&   shapfct,
                                                 const LINALG::Matrix<my::numnod_,1>*   myporosity,
                                                 const LINALG::Matrix<1,my::numdof_>&   dJ_dus,
                                                 double &                               porosity,
                                                 LINALG::Matrix<1,my::numdof_>&         dphi_dus);

    //compute porosity at gausspoint and linearization of porosity w.r.t. fluid pressure
    virtual void ComputePorosityAndLinearizationOD(Teuchos::ParameterList&              params,
                                                 const double&                          press,
                                                 const double&                          J,
                                                 const int&                             gp,
                                                 const LINALG::Matrix<my::numnod_,1>&    shapfct,
                                                 const LINALG::Matrix<my::numnod_,1>*    myporosity,
                                                 double &                               porosity,
                                                 double &                               dphi_dp);

    //! evaluate gauss points for diagonal terms
    void GaussPointLoopP1(   Teuchos::ParameterList& params,
                                        const LINALG::Matrix<my::numdim_,my::numnod_>& xrefe,
                                        const LINALG::Matrix<my::numdim_,my::numnod_>& xcurr,
                                        const LINALG::Matrix<my::numdim_,my::numnod_>& nodaldisp,
                                        const LINALG::Matrix<my::numdim_,my::numnod_>& nodalvel,
                                        const LINALG::Matrix<my::numdim_,my::numnod_> & evelnp,
                                        const LINALG::Matrix<my::numnod_,1> & epreaf,
                                        const LINALG::Matrix<my::numnod_, 1>*  porosity_dof,
                                        LINALG::Matrix<my::numdof_,my::numdof_>& erea_v,
                                        LINALG::Matrix<my::numdof_,my::numdof_>* sub_stiff,
                                        LINALG::Matrix<my::numdof_,1>*       sub_force,
                                        LINALG::Matrix<my::numdof_,my::numnod_>& ecoupl_p1,
                                        LINALG::Matrix<my::numnod_,numdof_>& estiff_p1,
                                        LINALG::Matrix<my::numnod_,1>& ecoupl_force_p1
                                            );

    //! evaluate gauss points for off-diagonal terms
    void GaussPointLoopP1OD(   Teuchos::ParameterList& params,
                                        const LINALG::Matrix<my::numdim_,my::numnod_>& xrefe,
                                        const LINALG::Matrix<my::numdim_,my::numnod_>& xcurr,
                                        const LINALG::Matrix<my::numdim_,my::numnod_>& nodaldisp,
                                        const LINALG::Matrix<my::numdim_,my::numnod_>& nodalvel,
                                        const LINALG::Matrix<my::numdim_,my::numnod_> & evelnp,
                                        const LINALG::Matrix<my::numnod_,1> & epreaf,
                                        const LINALG::Matrix<my::numnod_, 1>*  porosity_dof,
                                        LINALG::Matrix<my::numnod_,my::numnod_>& estiff_p1,
                                        LINALG::Matrix<my::numdof_, (my::numdim_ + 1) * my::numnod_>& sub_stiff
                                            );

  };
}
}


#endif /* WALL1_PORO_P1_H_ */
