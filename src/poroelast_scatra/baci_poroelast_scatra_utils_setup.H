/*----------------------------------------------------------------------*/
/*! \file

\brief utility functions for poroelast-scatra setup

\level 2

 *----------------------------------------------------------------------*/


#ifndef BACI_POROELAST_SCATRA_UTILS_SETUP_H
#define BACI_POROELAST_SCATRA_UTILS_SETUP_H

#include "baci_lib_dofset_gidbased_wrapper.H"
#include "baci_lib_dofset_predefineddofnumber.H"
#include "baci_lib_globalproblem.H"
#include "baci_lib_utils_createdis.H"
#include "baci_lib_utils_parallel.H"
#include "baci_poroelast_scatra_utils.H"
#include "baci_poroelast_scatra_utils_clonestrategy.H"
#include "baci_poroelast_utils_setup.H"


namespace POROELASTSCATRA
{
  namespace UTILS
  {
    //! setup discretization, includes cloning the structure discretization
    template <class PoroCloneStrategy, class PoroScatraCloneStrategy>
    void SetupPoroScatraDiscretizations()
    {
      // Scheme    : the structure discretization is received from the input. Then, an ale-fluid
      // disc.is cloned from the struct. one.
      //  After that, an ale-scatra disc. is cloned from the structure discretization.

      DRT::Problem* problem = DRT::Problem::Instance();

      // 1.-Initialization.
      Teuchos::RCP<DRT::Discretization> structdis = problem->GetDis("structure");
      Teuchos::RCP<DRT::Discretization> fluiddis = problem->GetDis("porofluid");
      Teuchos::RCP<DRT::Discretization> scatradis = problem->GetDis("scatra");

      // setup of the discretizations, including clone strategy (do not set material pointers, this
      // will be done here)
      POROELAST::UTILS::SetupPoro<PoroCloneStrategy>(false);

      // 3.-Access the scatra discretization, make sure it's empty, and fill it by cloning the
      // structural one.
      if (fluiddis->NumGlobalNodes() == 0) dserror("Fluid discretization is empty!");

      if (!scatradis->Filled()) scatradis->FillComplete();

      if (scatradis->NumGlobalNodes() == 0)
      {
        // fill scatra discretization by cloning structure discretization
        DRT::UTILS::CloneDiscretization<PoroScatraCloneStrategy>(structdis, scatradis);
        scatradis->FillComplete();

        // assign materials. Order is important here!
        POROELAST::UTILS::SetMaterialPointersMatchingGrid(structdis, fluiddis);
        POROELAST::UTILS::SetMaterialPointersMatchingGrid(structdis, scatradis);
        POROELAST::UTILS::SetMaterialPointersMatchingGrid(fluiddis, scatradis);

        // the problem is two way coupled, thus each discretization must know the other
        // discretization

        // build a proxy of the structure discretization for the scatra field
        Teuchos::RCP<DRT::DofSetInterface> structdofset = structdis->GetDofSetProxy();
        // build a proxy of the fluid discretization for the scatra field
        Teuchos::RCP<DRT::DofSetInterface> fluiddofset = fluiddis->GetDofSetProxy();
        // build a proxy of the fluid discretization for the structure/fluid field
        Teuchos::RCP<DRT::DofSetInterface> scatradofset = scatradis->GetDofSetProxy();

        // check if ScatraField has 2 discretizations, so that coupling is possible
        if (scatradis->AddDofSet(structdofset) != 1) dserror("unexpected dof sets in scatra field");
        if (scatradis->AddDofSet(fluiddofset) != 2) dserror("unexpected dof sets in scatra field");
        if (structdis->AddDofSet(scatradofset) != 2)
          dserror("unexpected dof sets in structure field");
        if (fluiddis->AddDofSet(scatradofset) != 2) dserror("unexpected dof sets in fluid field");

        structdis->FillComplete();
        fluiddis->FillComplete();
        scatradis->FillComplete();
      }
      else
      {
        // create vector of discr.
        std::vector<Teuchos::RCP<DRT::Discretization>> dis;
        dis.push_back(structdis);
        dis.push_back(fluiddis);
        dis.push_back(scatradis);

        DRT::UTILS::RedistributeDiscretizationsByBinning(dis, false);

        // set material pointers
        POROELAST::UTILS::SetMaterialPointersMatchingGrid(structdis, fluiddis);

        // first call FillComplete for single discretizations.
        // This way the physical dofs are numbered successively
        structdis->FillComplete();
        fluiddis->FillComplete();
        scatradis->FillComplete();

        // build auxiliary dofsets, i.e. pseudo dofs on each discretization
        const int ndofpernode_fluid = fluiddis->NumDof(0, fluiddis->lRowNode(0));
        const int ndofperelement_fluid = 0;
        const int ndofpernode_struct = structdis->NumDof(0, structdis->lRowNode(0));
        const int ndofperelement_struct = 0;
        const int ndofpernode_scatra = scatradis->NumDof(0, scatradis->lRowNode(0));
        const int ndofperelement_scatra = 0;

        Teuchos::RCP<DRT::DofSetInterface> dofsetaux;
        dofsetaux = Teuchos::rcp(
            new DRT::DofSetPredefinedDoFNumber(ndofpernode_scatra, ndofperelement_scatra, 0, true));
        if (structdis->AddDofSet(dofsetaux) != 2) dserror("unexpected dof sets in structure field");
        dofsetaux = Teuchos::rcp(
            new DRT::DofSetPredefinedDoFNumber(ndofpernode_scatra, ndofperelement_scatra, 0, true));
        if (fluiddis->AddDofSet(dofsetaux) != 2) dserror("unexpected dof sets in fluid field");
        dofsetaux = Teuchos::rcp(
            new DRT::DofSetPredefinedDoFNumber(ndofpernode_struct, ndofperelement_struct, 0, true));
        if (scatradis->AddDofSet(dofsetaux) != 1) dserror("unexpected dof sets in scatra field");
        dofsetaux = Teuchos::rcp(
            new DRT::DofSetPredefinedDoFNumber(ndofpernode_fluid, ndofperelement_fluid, 0, true));
        if (scatradis->AddDofSet(dofsetaux) != 2) dserror("unexpected dof sets in scatra field");

        // call AssignDegreesOfFreedom also for auxiliary dofsets
        // note: the order of FillComplete() calls determines the gid numbering!
        // 1. structure dofs
        // 2. fluiddis dofs
        // 3. scatradis dofs
        // 4. auxiliary dofs
        structdis->FillComplete(true, false, false);
        fluiddis->FillComplete(true, false, false);
        scatradis->FillComplete(true, false, false);
      }
    }
  }  // namespace UTILS
}  // namespace POROELASTSCATRA

#endif
