// This test was automatically generated by CUT::OUTPUT::GmshElementCutTest(),
// as the cut crashed for this configuration!

#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "cut_test_utils.H"

#include "../../src/drt_cut/cut_side.H"
#include "../../src/drt_cut/cut_meshintersection.H"
#include "../../src/drt_cut/cut_tetmeshintersection.H"
#include "../../src/drt_cut/cut_options.H"
#include "../../src/drt_cut/cut_volumecell.H"
#include "../../src/drt_cut/cut_combintersection.H"

#include "../../src/drt_fem_general/drt_utils_local_connectivity_matrices.H"


void test_bacigenerated_1()
{
  GEO::CUT::MeshIntersection intersection;
  std::vector<int> nids;

  int sidecount = 0;
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.126125;
    tri3_xyze(1,0) = 0;
    tri3_xyze(2,0) = 0.757368;
    nids.push_back( 452678 );
    tri3_xyze(0,1) = 0.129389;
    tri3_xyze(1,1) = 0;
    tri3_xyze(2,1) = 0.759549;
    nids.push_back( 452677 );
    tri3_xyze(0,2) = 0.0958178;
    tri3_xyze(1,2) = -0.0553204;
    tri3_xyze(2,2) = 0.758459;
    nids.push_back( -294 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.0630625;
    tri3_xyze(1,0) = -0.109227;
    tri3_xyze(2,0) = 0.757368;
    nids.push_back( 452062 );
    tri3_xyze(0,1) = 0.126125;
    tri3_xyze(1,1) = 0;
    tri3_xyze(2,1) = 0.757368;
    nids.push_back( 452678 );
    tri3_xyze(0,2) = 0.0958178;
    tri3_xyze(1,2) = -0.0553204;
    tri3_xyze(2,2) = 0.758459;
    nids.push_back( -294 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.1227;
    tri3_xyze(1,0) = 0;
    tri3_xyze(2,0) = 0.75545;
    nids.push_back( 452679 );
    tri3_xyze(0,1) = 0.126125;
    tri3_xyze(1,1) = 0;
    tri3_xyze(2,1) = 0.757368;
    nids.push_back( 452678 );
    tri3_xyze(0,2) = 0.0933092;
    tri3_xyze(1,2) = -0.0538721;
    tri3_xyze(2,2) = 0.756409;
    nids.push_back( -295 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.126125;
    tri3_xyze(1,0) = 0;
    tri3_xyze(2,0) = 0.757368;
    nids.push_back( 452678 );
    tri3_xyze(0,1) = 0.0630625;
    tri3_xyze(1,1) = -0.109227;
    tri3_xyze(2,1) = 0.757368;
    nids.push_back( 452062 );
    tri3_xyze(0,2) = 0.0933092;
    tri3_xyze(1,2) = -0.0538721;
    tri3_xyze(2,2) = 0.756409;
    nids.push_back( -295 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.129389;
    tri3_xyze(1,0) = 0;
    tri3_xyze(2,0) = 0.759549;
    nids.push_back( 452677 );
    tri3_xyze(0,1) = 0.126125;
    tri3_xyze(1,1) = 0;
    tri3_xyze(2,1) = 0.757368;
    nids.push_back( 452678 );
    tri3_xyze(0,2) = 0.0958178;
    tri3_xyze(1,2) = 0.0553204;
    tri3_xyze(2,2) = 0.758459;
    nids.push_back( -374 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.126125;
    tri3_xyze(1,0) = 0;
    tri3_xyze(2,0) = 0.757368;
    nids.push_back( 452678 );
    tri3_xyze(0,1) = 0.0630625;
    tri3_xyze(1,1) = 0.109227;
    tri3_xyze(2,1) = 0.757368;
    nids.push_back( 453910 );
    tri3_xyze(0,2) = 0.0958178;
    tri3_xyze(1,2) = 0.0553204;
    tri3_xyze(2,2) = 0.758459;
    nids.push_back( -374 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.0630625;
    tri3_xyze(1,0) = 0.109227;
    tri3_xyze(2,0) = 0.757368;
    nids.push_back( 453910 );
    tri3_xyze(0,1) = 0.126125;
    tri3_xyze(1,1) = 0;
    tri3_xyze(2,1) = 0.757368;
    nids.push_back( 452678 );
    tri3_xyze(0,2) = 0.0933092;
    tri3_xyze(1,2) = 0.0538721;
    tri3_xyze(2,2) = 0.756409;
    nids.push_back( -375 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.126125;
    tri3_xyze(1,0) = 0;
    tri3_xyze(2,0) = 0.757368;
    nids.push_back( 452678 );
    tri3_xyze(0,1) = 0.1227;
    tri3_xyze(1,1) = 0;
    tri3_xyze(2,1) = 0.75545;
    nids.push_back( 452679 );
    tri3_xyze(0,2) = 0.0933092;
    tri3_xyze(1,2) = 0.0538721;
    tri3_xyze(2,2) = 0.756409;
    nids.push_back( -375 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
  Epetra_SerialDenseMatrix hex8_xyze( 3, 8 );

    nids.clear();
  hex8_xyze(0,0) = 0.133333;
  hex8_xyze(1,0) = 8.67362e-19;
  hex8_xyze(2,0) = 0.75;
  nids.push_back( 335774 );
  hex8_xyze(0,1) = 0.133333;
  hex8_xyze(1,1) = 0.00833333;
  hex8_xyze(2,1) = 0.75;
  nids.push_back( 335775 );
  hex8_xyze(0,2) = 0.125;
  hex8_xyze(1,2) = 0.00833333;
  hex8_xyze(2,2) = 0.75;
  nids.push_back( 335836 );
  hex8_xyze(0,3) = 0.125;
  hex8_xyze(1,3) = 0;
  hex8_xyze(2,3) = 0.75;
  nids.push_back( 335835 );
  hex8_xyze(0,4) = 0.133333;
  hex8_xyze(1,4) = 8.96274e-19;
  hex8_xyze(2,4) = 0.758333;
  nids.push_back( 339495 );
  hex8_xyze(0,5) = 0.133333;
  hex8_xyze(1,5) = 0.00833333;
  hex8_xyze(2,5) = 0.758333;
  nids.push_back( 339496 );
  hex8_xyze(0,6) = 0.125;
  hex8_xyze(1,6) = 0.00833333;
  hex8_xyze(2,6) = 0.758333;
  nids.push_back( 339557 );
  hex8_xyze(0,7) = 0.125;
  hex8_xyze(1,7) = 0;
  hex8_xyze(2,7) = 0.758333;
  nids.push_back( 339556 );

  intersection.AddElement( 1, nids, hex8_xyze, DRT::Element::hex8 );

  intersection.Status();

  intersection.Cut( true, INPAR::CUT::VCellGaussPts_Tessellation );
  }

  std::vector<double> tessVol,momFitVol,dirDivVol;

  GEO::CUT::Mesh mesh = intersection.NormalMesh();
  const std::list<Teuchos::RCP<GEO::CUT::VolumeCell> > & other_cells = mesh.VolumeCells();
  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    tessVol.push_back(vc->Volume());
  }

  intersection.Status();

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    vc->MomentFitGaussWeights(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_Tessellation);
    momFitVol.push_back(vc->Volume());
  }

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
           i!=other_cells.end();
           ++i )
   {
     GEO::CUT::VolumeCell * vc = &**i;
     vc->DirectDivergenceGaussRule(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_DirectDivergence);
     dirDivVol.push_back(vc->Volume());
   }

  std::cout<<"the volumes predicted by\n tessellation \t MomentFitting \t DirectDivergence\n";
  for(unsigned i=0;i<tessVol.size();i++)
  {
    std::cout<<tessVol[i]<<"\t"<<momFitVol[i]<<"\t"<<dirDivVol[i]<<"\n";
    if( fabs(tessVol[i]-momFitVol[i])>1e-9 || fabs(dirDivVol[i]-momFitVol[i])>1e-9 )
    {
      mesh.DumpGmsh("Cuttest_Debug_Output.pos");
      dserror("volume predicted by either one of the method is wrong");
      }
    }
}


void test_bacigenerated_oo()
{
  GEO::CUT::MeshIntersection intersection;
  std::vector<int> nids;

  int sidecount = 0;
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.945289;
    tri3_xyze(1,0) = 0.459246;
    tri3_xyze(2,0) = 0.224429;
    nids.push_back( 3 );
    tri3_xyze(0,1) = 0.945148;
    tri3_xyze(1,1) = 0.459175;
    tri3_xyze(2,1) = 0.192335;
    nids.push_back( 5 );
    tri3_xyze(0,2) = 0.943044;
    tri3_xyze(1,2) = 0.474878;
    tri3_xyze(2,2) = 0.208404;
    nids.push_back( -2 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.940922;
    tri3_xyze(1,0) = 0.490578;
    tri3_xyze(2,0) = 0.224478;
    nids.push_back( 7 );
    tri3_xyze(0,1) = 0.945289;
    tri3_xyze(1,1) = 0.459246;
    tri3_xyze(2,1) = 0.224429;
    nids.push_back( 3 );
    tri3_xyze(0,2) = 0.943044;
    tri3_xyze(1,2) = 0.474878;
    tri3_xyze(2,2) = 0.208404;
    nids.push_back( -2 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.945148;
    tri3_xyze(1,0) = 0.459175;
    tri3_xyze(2,0) = 0.192335;
    nids.push_back( 5 );
    tri3_xyze(0,1) = 0.945289;
    tri3_xyze(1,1) = 0.459246;
    tri3_xyze(2,1) = 0.224429;
    nids.push_back( 3 );
    tri3_xyze(0,2) = 0.947395;
    tri3_xyze(1,2) = 0.443531;
    tri3_xyze(2,2) = 0.20838;
    nids.push_back( -3 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = 0.945289;
    tri3_xyze(1,0) = 0.459246;
    tri3_xyze(2,0) = 0.224429;
    nids.push_back( 3 );
    tri3_xyze(0,1) = 0.949662;
    tri3_xyze(1,1) = 0.42789;
    tri3_xyze(2,1) = 0.224423;
    nids.push_back( 2 );
    tri3_xyze(0,2) = 0.947395;
    tri3_xyze(1,2) = 0.443531;
    tri3_xyze(2,2) = 0.20838;
    nids.push_back( -3 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
  Epetra_SerialDenseMatrix hex8_xyze( 3, 4 );

    nids.clear();
  hex8_xyze(0,0) = 0.945208;
  hex8_xyze(1,0) = 0.459205;
  hex8_xyze(2,0) = 0.205882;
  nids.push_back( 16 );
  hex8_xyze(0,1) = 0.940299;
  hex8_xyze(1,1) = 0.459259;
  hex8_xyze(2,1) = 0.205882;
  nids.push_back( 3 );
  hex8_xyze(0,2) = 0.947273;
  hex8_xyze(1,2) = 0.444444;
  hex8_xyze(2,2) = 0.209313;
  nids.push_back( 21 );
  hex8_xyze(0,3) = 0.945288;
  hex8_xyze(1,3) = 0.459259;
  hex8_xyze(2,3) = 0.224416;
  nids.push_back( 15 );

  intersection.AddElement( 1, nids, hex8_xyze, DRT::Element::tet4 );

  intersection.Status();

  intersection.Cut( true, INPAR::CUT::VCellGaussPts_DirectDivergence );
  }

  std::vector<double> tessVol,momFitVol,dirDivVol;

  GEO::CUT::Mesh mesh = intersection.NormalMesh();
  const std::list<Teuchos::RCP<GEO::CUT::VolumeCell> > & other_cells = mesh.VolumeCells();
  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    tessVol.push_back(vc->Volume());
  }

  intersection.Status();

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    vc->MomentFitGaussWeights(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_Tessellation);
    momFitVol.push_back(vc->Volume());
  }

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
           i!=other_cells.end();
           ++i )
   {
     GEO::CUT::VolumeCell * vc = &**i;
     vc->DirectDivergenceGaussRule(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_DirectDivergence);
     dirDivVol.push_back(vc->Volume());
   }

  std::cout<<"the volumes predicted by\n tessellation \t MomentFitting \t DirectDivergence\n";
  for(unsigned i=0;i<tessVol.size();i++)
  {
    std::cout<<tessVol[i]<<"\t"<<momFitVol[i]<<"\t"<<dirDivVol[i]<<"\n";
    mesh.DumpGmsh("Cuttest_Debug_Output.pos");
    if( fabs(tessVol[i]-momFitVol[i])>1e-9 || fabs(dirDivVol[i]-momFitVol[i])>1e-9 )
    {
      //intersection.CutMesh().GetElement(1)->DebugDump();
      dserror("volume predicted by either one of the method is wrong");
      }
    }
}

void test_bacigenerated_1_off()
{
  GEO::CUT::MeshIntersection intersection;
  std::vector<int> nids;

  int sidecount = 0;
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.55843;
    tri3_xyze(1,0) = 0.883971;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5992 );
    tri3_xyze(0,1) = -2.55843;
    tri3_xyze(1,1) = 0.883971;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5994 );
    tri3_xyze(0,2) = -2.55182;
    tri3_xyze(1,2) = 0.865503;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -30 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.54521;
    tri3_xyze(1,0) = 0.847035;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5988 );
    tri3_xyze(0,1) = -2.55843;
    tri3_xyze(1,1) = 0.883971;
    tri3_xyze(2,1) = 0.025;
    nids.push_back( 5992 );
    tri3_xyze(0,2) = -2.55182;
    tri3_xyze(1,2) = 0.865503;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -30 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.56796;
    tri3_xyze(1,0) = 0.922024;
    tri3_xyze(2,0) = 0;
    nids.push_back( 5998 );
    tri3_xyze(0,1) = -2.55843;
    tri3_xyze(1,1) = 0.883971;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5994 );
    tri3_xyze(0,2) = -2.5632;
    tri3_xyze(1,2) = 0.902997;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -31 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.55843;
    tri3_xyze(1,0) = 0.883971;
    tri3_xyze(2,0) = 0;
    nids.push_back( 5994 );
    tri3_xyze(0,1) = -2.54521;
    tri3_xyze(1,1) = 0.847035;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5990 );
    tri3_xyze(0,2) = -2.55182;
    tri3_xyze(1,2) = 0.865503;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -30 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.55843;
    tri3_xyze(1,0) = 0.883971;
    tri3_xyze(2,0) = 0;
    nids.push_back( 5994 );
    tri3_xyze(0,1) = -2.55843;
    tri3_xyze(1,1) = 0.883971;
    tri3_xyze(2,1) = 0.025;
    nids.push_back( 5992 );
    tri3_xyze(0,2) = -2.5632;
    tri3_xyze(1,2) = 0.902997;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -31 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.55843;
    tri3_xyze(1,0) = 0.883971;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5992 );
    tri3_xyze(0,1) = -2.56796;
    tri3_xyze(1,1) = 0.922024;
    tri3_xyze(2,1) = 0.025;
    nids.push_back( 5996 );
    tri3_xyze(0,2) = -2.5632;
    tri3_xyze(1,2) = 0.902997;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -31 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
  Epetra_SerialDenseMatrix hex8_xyze( 3, 8 );

    nids.clear();
  hex8_xyze(0,0) = -2.58164;
  hex8_xyze(1,0) = 0.881864;
  hex8_xyze(2,0) = 0;
  nids.push_back( 19832 );
  hex8_xyze(0,1) = -2.57434;
  hex8_xyze(1,1) = 0.857259;
  hex8_xyze(2,1) = 0;
  nids.push_back( 19834 );
  hex8_xyze(0,2) = -2.55729;
  hex8_xyze(1,2) = 0.86603;
  hex8_xyze(2,2) = 0;
  nids.push_back( 20106 );
  hex8_xyze(0,3) = -2.55586;
  hex8_xyze(1,3) = 0.884694;
  hex8_xyze(2,3) = 0;
  nids.push_back( 20104 );
  hex8_xyze(0,4) = -2.58164;
  hex8_xyze(1,4) = 0.881864;
  hex8_xyze(2,4) = 0.025;
  nids.push_back( 19833 );
  hex8_xyze(0,5) = -2.57434;
  hex8_xyze(1,5) = 0.857259;
  hex8_xyze(2,5) = 0.025;
  nids.push_back( 19835 );
  hex8_xyze(0,6) = -2.55729;
  hex8_xyze(1,6) = 0.86603;
  hex8_xyze(2,6) = 0.025;
  nids.push_back( 20107 );
  hex8_xyze(0,7) = -2.55586;
  hex8_xyze(1,7) = 0.884694;
  hex8_xyze(2,7) = 0.025;
  nids.push_back( 20105 );

  intersection.AddElement( 1, nids, hex8_xyze, DRT::Element::hex8 );

  intersection.Status();

  intersection.Cut( true, INPAR::CUT::VCellGaussPts_Tessellation );
  }

  std::vector<double> tessVol,momFitVol,dirDivVol;

  GEO::CUT::Mesh mesh = intersection.NormalMesh();
  const std::list<Teuchos::RCP<GEO::CUT::VolumeCell> > & other_cells = mesh.VolumeCells();
  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    tessVol.push_back(vc->Volume());
  }

  intersection.Status();

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    vc->MomentFitGaussWeights(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_Tessellation);
    momFitVol.push_back(vc->Volume());
  }

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
           i!=other_cells.end();
           ++i )
   {
     GEO::CUT::VolumeCell * vc = &**i;
     vc->DirectDivergenceGaussRule(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_DirectDivergence);
     dirDivVol.push_back(vc->Volume());
   }

  std::cout<<"the volumes predicted by\n tessellation \t MomentFitting \t DirectDivergence\n";
  for(unsigned i=0;i<tessVol.size();i++)
  {
    std::cout<<tessVol[i]<<"\t"<<momFitVol[i]<<"\t"<<dirDivVol[i]<<"\n";
    if( fabs(tessVol[i]-momFitVol[i])>1e-9 || fabs(dirDivVol[i]-momFitVol[i])>1e-9 )
    {
      mesh.DumpGmsh("Cuttest_Debug_Output.pos");
      dserror("volume predicted by either one of the method is wrong");
    }
  }
}

void test_bacigenerated_12()
{
  GEO::CUT::MeshIntersection intersection;
  std::vector<int> nids;

  int sidecount = 0;
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.28648;
    tri3_xyze(1,0) = 0.630841;
    tri3_xyze(2,0) = 0;
    nids.push_back( 5958 );
    tri3_xyze(0,1) = -2.24955;
    tri3_xyze(1,1) = 0.617663;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5954 );
    tri3_xyze(0,2) = -2.26802;
    tri3_xyze(1,2) = 0.624252;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -21 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.28648;
    tri3_xyze(1,0) = 0.630841;
    tri3_xyze(2,0) = 0;
    nids.push_back( 5958 );
    tri3_xyze(0,1) = -2.28648;
    tri3_xyze(1,1) = 0.630841;
    tri3_xyze(2,1) = 0.025;
    nids.push_back( 5956 );
    tri3_xyze(0,2) = -2.30421;
    tri3_xyze(1,2) = 0.639209;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -22 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.32194;
    tri3_xyze(1,0) = 0.647578;
    tri3_xyze(2,0) = 0;
    nids.push_back( 5962 );
    tri3_xyze(0,1) = -2.28648;
    tri3_xyze(1,1) = 0.630841;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5958 );
    tri3_xyze(0,2) = -2.30421;
    tri3_xyze(1,2) = 0.639209;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -22 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.32194;
    tri3_xyze(1,0) = 0.647578;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5960 );
    tri3_xyze(0,1) = -2.32194;
    tri3_xyze(1,1) = 0.647578;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5962 );
    tri3_xyze(0,2) = -2.30421;
    tri3_xyze(1,2) = 0.639209;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -22 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.24955;
    tri3_xyze(1,0) = 0.617663;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5952 );
    tri3_xyze(0,1) = -2.28648;
    tri3_xyze(1,1) = 0.630841;
    tri3_xyze(2,1) = 0.025;
    nids.push_back( 5956 );
    tri3_xyze(0,2) = -2.26802;
    tri3_xyze(1,2) = 0.624252;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -21 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.28648;
    tri3_xyze(1,0) = 0.630841;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5956 );
    tri3_xyze(0,1) = -2.32194;
    tri3_xyze(1,1) = 0.647578;
    tri3_xyze(2,1) = 0.025;
    nids.push_back( 5960 );
    tri3_xyze(0,2) = -2.30421;
    tri3_xyze(1,2) = 0.639209;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -22 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.28648;
    tri3_xyze(1,0) = 0.630841;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5956 );
    tri3_xyze(0,1) = -2.28648;
    tri3_xyze(1,1) = 0.630841;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5958 );
    tri3_xyze(0,2) = -2.26802;
    tri3_xyze(1,2) = 0.624252;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -21 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
  Epetra_SerialDenseMatrix hex8_xyze( 3, 8 );

    nids.clear();
  hex8_xyze(0,0) = -2.31075;
  hex8_xyze(1,0) = 0.616579;
  hex8_xyze(2,0) = 0;
  nids.push_back( 22144 );
  hex8_xyze(0,1) = -2.28143;
  hex8_xyze(1,1) = 0.616752;
  hex8_xyze(2,1) = 0;
  nids.push_back( 22146 );
  hex8_xyze(0,2) = -2.28544;
  hex8_xyze(1,2) = 0.646429;
  hex8_xyze(2,2) = 0;
  nids.push_back( 22370 );
  hex8_xyze(0,3) = -2.30706;
  hex8_xyze(1,3) = 0.638525;
  hex8_xyze(2,3) = 0;
  nids.push_back( 22372 );
  hex8_xyze(0,4) = -2.31075;
  hex8_xyze(1,4) = 0.616579;
  hex8_xyze(2,4) = 0.025;
  nids.push_back( 22145 );
  hex8_xyze(0,5) = -2.28143;
  hex8_xyze(1,5) = 0.616752;
  hex8_xyze(2,5) = 0.025;
  nids.push_back( 22147 );
  hex8_xyze(0,6) = -2.28544;
  hex8_xyze(1,6) = 0.646429;
  hex8_xyze(2,6) = 0.025;
  nids.push_back( 22371 );
  hex8_xyze(0,7) = -2.30706;
  hex8_xyze(1,7) = 0.638525;
  hex8_xyze(2,7) = 0.025;
  nids.push_back( 22373 );

  intersection.AddElement( 1, nids, hex8_xyze, DRT::Element::hex8 );

  intersection.Status();

  intersection.Cut( true, INPAR::CUT::VCellGaussPts_Tessellation );
  }

  std::vector<double> tessVol,momFitVol,dirDivVol;

  GEO::CUT::Mesh mesh = intersection.NormalMesh();
  const std::list<Teuchos::RCP<GEO::CUT::VolumeCell> > & other_cells = mesh.VolumeCells();
  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    tessVol.push_back(vc->Volume());
  }

  intersection.Status();

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    vc->MomentFitGaussWeights(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_Tessellation);
    momFitVol.push_back(vc->Volume());
  }

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
           i!=other_cells.end();
           ++i )
   {
     GEO::CUT::VolumeCell * vc = &**i;
     vc->DirectDivergenceGaussRule(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_DirectDivergence);
     dirDivVol.push_back(vc->Volume());
   }

  std::cout<<"the volumes predicted by\n tessellation \t MomentFitting \t DirectDivergence\n";
  for(unsigned i=0;i<tessVol.size();i++)
  {
    std::cout<<tessVol[i]<<"\t"<<momFitVol[i]<<"\t"<<dirDivVol[i]<<"\n";
    if( fabs(tessVol[i]-momFitVol[i])>1e-9 || fabs(dirDivVol[i]-momFitVol[i])>1e-9 )
      dserror("volume predicted by either one of the method is wrong");
  }
}

void test_bacigenerated_00()
{
  GEO::CUT::MeshIntersection intersection;
  std::vector<int> nids;

  int sidecount = 0;
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.55507;
    tri3_xyze(1,0) = 0.847035;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5988 );
    tri3_xyze(0,1) = -2.56828;
    tri3_xyze(1,1) = 0.883969;
    tri3_xyze(2,1) = 0.025;
    nids.push_back( 5992 );
    tri3_xyze(0,2) = -2.56167;
    tri3_xyze(1,2) = 0.865502;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -30 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.56828;
    tri3_xyze(1,0) = 0.883969;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5992 );
    tri3_xyze(0,1) = -2.56828;
    tri3_xyze(1,1) = 0.883969;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5994 );
    tri3_xyze(0,2) = -2.56167;
    tri3_xyze(1,2) = 0.865502;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -30 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.55507;
    tri3_xyze(1,0) = 0.847035;
    tri3_xyze(2,0) = 0;
    nids.push_back( 5990 );
    tri3_xyze(0,1) = -2.55507;
    tri3_xyze(1,1) = 0.847035;
    tri3_xyze(2,1) = 0.025;
    nids.push_back( 5988 );
    tri3_xyze(0,2) = -2.56167;
    tri3_xyze(1,2) = 0.865502;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -30 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.56828;
    tri3_xyze(1,0) = 0.883969;
    tri3_xyze(2,0) = 0;
    nids.push_back( 5994 );
    tri3_xyze(0,1) = -2.55507;
    tri3_xyze(1,1) = 0.847035;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5990 );
    tri3_xyze(0,2) = -2.56167;
    tri3_xyze(1,2) = 0.865502;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -30 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
  Epetra_SerialDenseMatrix hex8_xyze( 3, 8 );

    nids.clear();
  hex8_xyze(0,0) = -2.58256;
  hex8_xyze(1,0) = 0.881818;
  hex8_xyze(2,0) = 0;
  nids.push_back( 19832 );
  hex8_xyze(0,1) = -2.57528;
  hex8_xyze(1,1) = 0.857202;
  hex8_xyze(2,1) = 0;
  nids.push_back( 19834 );
  hex8_xyze(0,2) = -2.55827;
  hex8_xyze(1,2) = 0.865975;
  hex8_xyze(2,2) = 0;
  nids.push_back( 20106 );
  hex8_xyze(0,3) = -2.55684;
  hex8_xyze(1,3) = 0.884647;
  hex8_xyze(2,3) = 0;
  nids.push_back( 20104 );
  hex8_xyze(0,4) = -2.58256;
  hex8_xyze(1,4) = 0.881818;
  hex8_xyze(2,4) = 0.025;
  nids.push_back( 19833 );
  hex8_xyze(0,5) = -2.57528;
  hex8_xyze(1,5) = 0.857202;
  hex8_xyze(2,5) = 0.025;
  nids.push_back( 19835 );
  hex8_xyze(0,6) = -2.55827;
  hex8_xyze(1,6) = 0.865975;
  hex8_xyze(2,6) = 0.025;
  nids.push_back( 20107 );
  hex8_xyze(0,7) = -2.55684;
  hex8_xyze(1,7) = 0.884647;
  hex8_xyze(2,7) = 0.025;
  nids.push_back( 20105 );

  intersection.AddElement( 1, nids, hex8_xyze, DRT::Element::hex8 );

  intersection.Status();

  intersection.Cut( true, INPAR::CUT::VCellGaussPts_Tessellation );
  }

  std::vector<double> tessVol,momFitVol,dirDivVol;

  GEO::CUT::Mesh mesh = intersection.NormalMesh();
  const std::list<Teuchos::RCP<GEO::CUT::VolumeCell> > & other_cells = mesh.VolumeCells();
  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    tessVol.push_back(vc->Volume());
  }

  intersection.Status();

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    vc->MomentFitGaussWeights(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_Tessellation);
    momFitVol.push_back(vc->Volume());
  }

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
           i!=other_cells.end();
           ++i )
   {
     GEO::CUT::VolumeCell * vc = &**i;
     vc->DirectDivergenceGaussRule(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_DirectDivergence);
     dirDivVol.push_back(vc->Volume());
   }

  std::cout<<"the volumes predicted by\n tessellation \t MomentFitting \t DirectDivergence\n";
  for(unsigned i=0;i<tessVol.size();i++)
  {
    std::cout<<tessVol[i]<<"\t"<<momFitVol[i]<<"\t"<<dirDivVol[i]<<"\n";
    if( fabs(tessVol[i]-momFitVol[i])>1e-9 || fabs(dirDivVol[i]-momFitVol[i])>1e-9 )
      dserror("volume predicted by either one of the method is wrong");
  }
}

void test_bacigenerated_2()
{
  GEO::CUT::MeshIntersection intersection;
  std::vector<int> nids;

  int sidecount = 0;
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.53715;
    tri3_xyze(1,0) = 0.811578;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5984 );
    tri3_xyze(0,1) = -2.55392;
    tri3_xyze(1,1) = 0.847038;
    tri3_xyze(2,1) = 0.025;
    nids.push_back( 5988 );
    tri3_xyze(0,2) = -2.54554;
    tri3_xyze(1,2) = 0.829308;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -29 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.55392;
    tri3_xyze(1,0) = 0.847038;
    tri3_xyze(2,0) = 0;
    nids.push_back( 5990 );
    tri3_xyze(0,1) = -2.53715;
    tri3_xyze(1,1) = 0.811578;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5986 );
    tri3_xyze(0,2) = -2.54554;
    tri3_xyze(1,2) = 0.829308;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -29 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.55392;
    tri3_xyze(1,0) = 0.847038;
    tri3_xyze(2,0) = 0;
    nids.push_back( 5990 );
    tri3_xyze(0,1) = -2.55392;
    tri3_xyze(1,1) = 0.847038;
    tri3_xyze(2,1) = 0.025;
    nids.push_back( 5988 );
    tri3_xyze(0,2) = -2.56053;
    tri3_xyze(1,2) = 0.865504;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -30 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.56713;
    tri3_xyze(1,0) = 0.883971;
    tri3_xyze(2,0) = 0;
    nids.push_back( 5994 );
    tri3_xyze(0,1) = -2.55392;
    tri3_xyze(1,1) = 0.847038;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5990 );
    tri3_xyze(0,2) = -2.56053;
    tri3_xyze(1,2) = 0.865504;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -30 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.55392;
    tri3_xyze(1,0) = 0.847038;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5988 );
    tri3_xyze(0,1) = -2.56713;
    tri3_xyze(1,1) = 0.883971;
    tri3_xyze(2,1) = 0.025;
    nids.push_back( 5992 );
    tri3_xyze(0,2) = -2.56053;
    tri3_xyze(1,2) = 0.865504;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -30 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
    Epetra_SerialDenseMatrix tri3_xyze( 3, 3 );

    nids.clear();
    tri3_xyze(0,0) = -2.55392;
    tri3_xyze(1,0) = 0.847038;
    tri3_xyze(2,0) = 0.025;
    nids.push_back( 5988 );
    tri3_xyze(0,1) = -2.55392;
    tri3_xyze(1,1) = 0.847038;
    tri3_xyze(2,1) = 0;
    nids.push_back( 5990 );
    tri3_xyze(0,2) = -2.54554;
    tri3_xyze(1,2) = 0.829308;
    tri3_xyze(2,2) = 0.0125;
    nids.push_back( -29 );
    intersection.AddCutSide( ++sidecount, nids, tri3_xyze, DRT::Element::tri3 );
  }
  {
  Epetra_SerialDenseMatrix hex8_xyze( 3, 8 );

    nids.clear();
  hex8_xyze(0,0) = -2.57514;
  hex8_xyze(1,0) = 0.85721;
  hex8_xyze(2,0) = 0;
  nids.push_back( 19834 );
  hex8_xyze(0,1) = -2.55875;
  hex8_xyze(1,1) = 0.838023;
  hex8_xyze(2,1) = 0;
  nids.push_back( 19836 );
  hex8_xyze(0,2) = -2.54198;
  hex8_xyze(1,2) = 0.855666;
  hex8_xyze(2,2) = 0;
  nids.push_back( 20108 );
  hex8_xyze(0,3) = -2.55813;
  hex8_xyze(1,3) = 0.865983;
  hex8_xyze(2,3) = 0;
  nids.push_back( 20106 );
  hex8_xyze(0,4) = -2.57514;
  hex8_xyze(1,4) = 0.85721;
  hex8_xyze(2,4) = 0.025;
  nids.push_back( 19835 );
  hex8_xyze(0,5) = -2.55875;
  hex8_xyze(1,5) = 0.838023;
  hex8_xyze(2,5) = 0.025;
  nids.push_back( 19837 );
  hex8_xyze(0,6) = -2.54198;
  hex8_xyze(1,6) = 0.855666;
  hex8_xyze(2,6) = 0.025;
  nids.push_back( 20109 );
  hex8_xyze(0,7) = -2.55813;
  hex8_xyze(1,7) = 0.865983;
  hex8_xyze(2,7) = 0.025;
  nids.push_back( 20107 );

  intersection.AddElement( 1, nids, hex8_xyze, DRT::Element::hex8 );

  intersection.Status();

  intersection.Cut( true, INPAR::CUT::VCellGaussPts_Tessellation );
  }

  std::vector<double> tessVol,momFitVol,dirDivVol;

  GEO::CUT::Mesh mesh = intersection.NormalMesh();
  const std::list<Teuchos::RCP<GEO::CUT::VolumeCell> > & other_cells = mesh.VolumeCells();
  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    tessVol.push_back(vc->Volume());
  }

  intersection.Status();

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
        i!=other_cells.end();
        ++i )
  {
    GEO::CUT::VolumeCell * vc = &**i;
    vc->MomentFitGaussWeights(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_Tessellation);
    momFitVol.push_back(vc->Volume());
  }

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
           i!=other_cells.end();
           ++i )
   {
     GEO::CUT::VolumeCell * vc = &**i;
     vc->DirectDivergenceGaussRule(vc->ParentElement(),mesh,true,INPAR::CUT::BCellGaussPts_DirectDivergence);
     dirDivVol.push_back(vc->Volume());
   }

  std::cout<<"the volumes predicted by\n tessellation \t MomentFitting \t DirectDivergence\n";
  for(unsigned i=0;i<tessVol.size();i++)
  {
    std::cout<<tessVol[i]<<"\t"<<momFitVol[i]<<"\t"<<dirDivVol[i]<<"\n";
    if( fabs(tessVol[i]-momFitVol[i])>1e-9 || fabs(dirDivVol[i]-momFitVol[i])>1e-9 )
      dserror("volume predicted by either one of the method is wrong");
  }
}

void test_bacigenerated_1_mag()//test_ls_hex8_magnus1()
{
  //non-planar cut surface
  GEO::CUT::CombIntersection ci(-1);
  ci.AddLevelSetSide(1);

  // simple hex8 element
  std::vector<int> nids( 8 );
  std::vector<double> lsvs( 8 );
  Epetra_SerialDenseMatrix xyze( 3, 8 );

  for ( int i=0; i<8; ++i )
  {
    nids[i] = i;
  }

  //eleID=47018 (precision 16)
    xyze(  0,0 ) = 0.45;
    xyze(  1,0 ) = -0.2500000000000001;
    xyze(  2,0 ) = 0.09999999999999995;

    xyze(  0,1 ) = 0.45;
    xyze(  1,1 ) = -0.25;
    xyze(  2,1 ) = 0.04999999999999986;

    xyze(  0,2 ) = 0.4500000000000001;
    xyze(  1,2 ) = -0.2000000000000001;
    xyze(  2,2 ) = 0.04999999999999988;

    xyze(  0,3 ) = 0.45;
    xyze(  1,3 ) = -0.2000000000000001;
    xyze(  2,3 ) = 0.09999999999999992;

    xyze(  0,4 ) = 0.5;
    xyze(  1,4 ) = -0.25;
    xyze(  2,4 ) = 0.1;

    xyze(  0,5 ) = 0.5;
    xyze(  1,5 ) = -0.25;
    xyze(  2,5 ) = 0.04999999999999992;

    xyze(  0,6 ) = 0.5000000000000001;
    xyze(  1,6 ) = -0.2;
    xyze(  2,6 ) = 0.04999999999999993;

    xyze(  0,7 ) = 0.5;
    xyze(  1,7 ) = -0.2000000000000001;
    xyze(  2,7 ) = 0.09999999999999998;

    lsvs[0] =0.02440442408507582;
    lsvs[1] =0.01720402163943002;
    lsvs[2] =-0.005025253169416655;
    lsvs[3] =0.002493781056044475;
    lsvs[4] =0.06789083458002731;
    lsvs[5] =0.06124860801609122;
    lsvs[6] =0.04083269131959844;
    lsvs[7] =0.04772255750516619;


//  //eleID=47018 (precision 24)
//  xyze(  0,0 ) = 0.449999999999999955591079;
//  xyze(  1,0 ) = -0.250000000000000055511151;
//  xyze(  2,0 ) = 0.0999999999999999500399639;
//
//  xyze(  0,1 ) = 0.449999999999999955591079;
//  xyze(  1,1 ) = -0.25;
//  xyze(  2,1 ) = 0.0499999999999998639976795;
//
//  xyze(  0,2 ) = 0.450000000000000066613381;
//  xyze(  1,2 ) = -0.200000000000000066613381;
//  xyze(  2,2 ) = 0.0499999999999998778754673;
//
//  xyze(  0,3 ) = 0.449999999999999955591079;
//  xyze(  1,3 ) = -0.200000000000000066613381;
//  xyze(  2,3 ) = 0.0999999999999999222843883;
//
//  xyze(  0,4 ) = 0.5;
//  xyze(  1,4 ) = -0.25;
//  xyze(  2,4 ) = 0.100000000000000005551115;
//
//  xyze(  0,5 ) = 0.5;
//  xyze(  1,5 ) = -0.25;
//  xyze(  2,5 ) = 0.0499999999999999195088307;
//
//  xyze(  0,6 ) = 0.500000000000000111022302;
//  xyze(  1,6 ) = -0.199999999999999983346655;
//  xyze(  2,6 ) = 0.0499999999999999333866185;
//
//  xyze(  0,7 ) = 0.5;
//  xyze(  1,7 ) = -0.200000000000000066613381;
//  xyze(  2,7 ) = 0.0999999999999999777955395;
//
//  lsvs[0] =0.024404424085075815398227;
//  lsvs[1] =0.0172040216394300227165104;
//  lsvs[2] =-0.00502525316941665467496136;
//  lsvs[3] =0.00249378105604447508625299;
//  lsvs[4] =0.0678908345800273149706072;
//  lsvs[5] =0.0612486080160912216285851;
//  lsvs[6] =0.0408326913195984353421863;
//  lsvs[7] =0.0477225575051661854431018;


  ci.AddElement( 1, nids, xyze, DRT::Element::hex8, &lsvs[0], false );

  std::vector<double> tessVol,momFitVol,dirDivVol;


  ci.Cut(true);
  ci.PrintCellStats();
  //GEO::CUT::Mesh mesh = ci.NormalMesh();

  std::cout<<"BEFORE FIND NODEPOS!" << std::endl;
  std::cout<<"mesh.GetElement(1)->Points()[i]->Position(): " << std::endl;
  //int num_points = ci.NormalMesh().GetElement(1)->Points().size();
  int num_points = ci.NormalMesh().Points()->size();
  for(int i=0;i<num_points;i++)
  {
     std::cout << ci.NormalMesh().Points()->GetPoints()[i]->Position() << ", ";
  }
  std::cout << std::endl;

  ci.NormalMesh().FindLSNodePositions();
  ci.NormalMesh().FindNodalDOFSets( true );

  std::cout<<"AFTER FIND NODEPOS!" << std::endl;
  std::cout<<"mesh.GetElement(1)->Points()[i]->Position(): " << std::endl;
  num_points = ci.NormalMesh().Points()->size();
  for(int i=0;i<num_points;i++)
  {
     std::cout << ci.NormalMesh().Points()->GetPoints()[i]->Position() << ", ";
  }
  std::cout << std::endl;

  ci.Cut_Finalize( true, INPAR::CUT::VCellGaussPts_Tessellation, INPAR::CUT::BCellGaussPts_Tessellation, false, true );

  //ci.Cut_Finalize( true, INPAR::CUT::VCellGaussPts_DirectDivergence, INPAR::CUT::BCellGaussPts_DirectDivergence, false, true );

  ci.NormalMesh().TestElementVolume(true);

  std::cout<<"AFTER Cut_Finalize!" << std::endl;
  std::cout<<"mesh.GetElement(1)->Points()[i]->Position(): " << std::endl;
  num_points = ci.NormalMesh().Points()->size();
  for(int i=0;i<num_points;i++)
  {
     std::cout << ci.NormalMesh().Points()->GetPoints()[i]->Position() << ", ";
  }
  std::cout << std::endl;


   //Gmsh-output
  ci.NormalMesh().DumpGmsh("xxx_cut_test_ls_hex8_magnus1.CUT.pos");
  ci.NormalMesh().DumpGmshVolumeCells("xxx_cut_test_ls_hex8_magnus1.CUT_volumecells.pos",true);
  ci.DumpGmshIntegrationCells("xxx_cut_test_ls_hex8_magnus1.CUT_integrationcells.pos");


  const std::list<Teuchos::RCP<GEO::CUT::VolumeCell> > & other_cells = ci.NormalMesh().VolumeCells();
  std::cout << "# Volume Cells: " << other_cells.size() << std::endl;

  int iteration_VC = 0;

  for ( std::list<Teuchos::RCP<GEO::CUT::VolumeCell> >::const_iterator i=other_cells.begin();
      i!=other_cells.end();
      ++i )
  {
    iteration_VC++;
    std::cout << "VC(" << iteration_VC << "):" << std::endl;
    GEO::CUT::VolumeCell * vc = &**i;

    const GEO::CUT::plain_integrationcell_set & integrationcells = vc->IntegrationCells();
    std::cout << "Has #IC=" << integrationcells.size() << std::endl;

    for ( GEO::CUT::plain_integrationcell_set::const_iterator i=integrationcells.begin();
        i!=integrationcells.end();
        ++i )
    {
      //GEO::CUT::IntegrationCell * ic = *i;

//      ic->DumpGmsh( file, &count );
    }
    //vc->Print(std::cout);
    const GEO::CUT::plain_facet_set & facete = vc->Facets();
    // check whether all facets of this vc are oriented in a plane
    // if not then some sides are warped
    // we need to generate quadrature rules in global coordinates
    for(GEO::CUT::plain_facet_set::const_iterator i=facete.begin();i!=facete.end();i++)
    {
      GEO::CUT::Facet *fe = *i;
      std::vector<GEO::CUT::Point*> corn = fe->CornerPoints();

      fe->Print();

      bool isPlanar = fe->IsPlanar( ci.NormalMesh(), corn );
      if ( isPlanar == false )
      {
        std::cout << "WARNING: Facet is NOT planar!!!" << std::endl;
        //dserror("VolumeCell is not planar!!");
      }
    }

    std::cout<<std::endl;
//    tessVol.push_back(vc->Volume());
  }
}
