
%%
%%::::::::::::::::::::::::::::commands
\input{def}
\input{cmd-text}
\input{cmd-math}

%%
%%::::::::::::::::::::::::::::dynamics
\chapter{Structural dynamics}\label{struct_dynamics:chap}

%% This documents should be split to several files which describe the
%% individual time integration schemes. Right now, we do not have readily
%% available theoretical background information.

\section{Input parameters}

\subsection{Common parameters}
\begin{verbatim}
------------------------------------------------STRUCTURAL DYNAMIC
\end{verbatim}

\kw{DYNAMICTYP} $string$\\
type of time integration control with method $string$, i.e.\\
\begin{tabular}{lll}
   $string$ & meaning & valid with
\\ \kw{Gen_Alfa} & generalized-alpha & \ccarat{}, \baci{} \texttt{StruGenAlpha}
\\ \kw{Centr_Diff} & central differences & \ccarat{}
\\ \kw{Gen_EMM} & generalized energy-momentum method & \ccarat{}
\\ \kw{Static} & static analysis & \baci{} \texttt{StruGenAlpha}
\\ \kw{GenAlpha} & generalised energy-momentum method & \baci{} \texttt{STR::TimInt}
\\ \kw{OneStepTheta} & one-step-theta method & \baci{} \texttt{STR::TimInt}
\\ \kw{GEMM} & generalised energy-momentum method & \baci{} \texttt{STR::TimInt}
\\ \kw{Statics} & static analysis & \baci{} \texttt{STR::TimInt}
\\ \kw{AdamsBashforth2} & Adams-Bashforthn 2nd order & \baci{} \texttt{STR::TimInt}
\end{tabular}

\kw{EIGEN} (\kw{1}\kor\kw{0})\\
EIGEN make eigenanalysis of the initial dynamic system (not with every solver): (0,1)\\
\textbf{Remark:} Does not work anywhere.

\kw{RESEVRYDISP} $int$\\
save displacements and contact forces every $int$ steps

\kw{RESEVRYSTRS} $int$\\
save stresses every $int$ steps

\kw{RESTARTEVRY} $int$\\
write restart possibility to .pss every $int$ steps

\kw{TIMESTEP} $real$\\
time step size

\kw{NUMSTEP} $int$\\
maximum number of steps

\kw{MAXTIME} $real$\\
maximum time

\kw{DAMPING} $string$\\
\begin{tabular}{lll}
   $string$ & meaning & valid in
\\ \kw{No} & no global damping & \ccarat{}, \baci{}
\\ \kw{Yes} & Rayleigh-damping & \ccarat{}, \baci{}
\\ \kw{Rayleigh} & Rayleigh-damping & \baci{}
\\ \kw{Material} & material-based damping on element-level & \baci{}
\end{tabular}


\kw{M_DAMP} $real$\\
Rayleigh-coefficient for Rayleigh damping proportional to mass matrix $\text{M\_DAMP} \times M$

\kw{K_DAMP} $real$\\
Rayleigh-coefficient for Rayleigh damping proportional to initial/reference stiffness matrix $\text{K\_DAMP} \times K$

\kw{NLNSOL} $string$\\
type of non-linear solution technique chosen, i.e.\\
\begin{tabular}{lll}
   $string$ & meaning & valid with
\\ \kw{fullnewton} & full Newton-Raphson iteration  (tangential) & \ccarat{}, \baci{}
\\ \kw{modnewton} & modified Newton-Raphson iteration (secantial) & \ccarat{}, \baci{}
\\ \kw{matfreenewton} & matrix-free Newton-Raphson iteration & \ccarat{}, \baci{}
\\ \kw{nlncg} & non-linear conjugate-gradient method & \ccarat{}, \baci{}
\\ \kw{ptc} & ??? & \ccarat{}, \baci{} \texttt{StruGenAlpha}
\\ \kw{lsnewton} & line-search Newton & \baci{} \texttt{StruGenAlpha}
\\ \kw{newtonlinuzawa} & linearised Newton-Uzawa & \baci{}
\\ \kw{augmentedlagrange} & non-linear Newton-Uzawa & \baci{}
\end{tabular}

\kw{TOLDISP} $real$\\
tolerance in the displacement norm for the Newton iteration 

\kw{MAXITER} $int$\\
maximum number of iterations allowed for newton iteration before failure

\subsection{\ccarat{} parameters}

\kw{ITERATION} (\kw{mod}\kor\kw{full}\kor\kw{none})\\
make Newton Iteration (only full implemented, ignored by explicit
time int.)

\kw{BETA} $real$\\
\kw{GAMMA} $real$\\
\kw{ALPHA_M} $real$\\
\kw{ALPHA_F} $real$\\
\kw{BETA}, \kw{GAMMA}, \kw{ALPHA_M} and \kw{ALPHA_F} generalized-$\alpha$
factors, \kw{BETA} and \kw{GAMMA} also 
used by explicit time integration

\kw{XSI} $real$\\
disspipation parameter for GEMM time integration

\kw{CONTACT} (\kw{Yes}\kor\kw{No})\\
switch contact algorithms for shell8 and wall1 on/off;
Have to use \kw{SPOOLES_nonsym} in parallel as solver for contact problems

\kw{CET_flag} (\kw{Yes}\kor\kw{No})\\
switch enforcement for contact lagr. multipliers on/off;
\kw{Yes} $\to$ penalty method, \kw{No} $\to$ augmented Lagrangean

\kw{FR_flag} (\kw{Yes}\kor\kw{No})\\
switch friction in contact on/off: (0,1)

\kw{NPP} $real$\\
penaly parameter for normal contact

\kw{TPP} $real$\\
penaly parameter for tangential (frictional) contact

\kw{FR_COEF} $real$\\
frictional coefficient

\kw{TIMEADAPT} (\kw{Yes}\kor\kw{No})\\
switch time adaptivity dependend on number of newton iterations on/off (only shell8)

\kw{ITWANT} $int$\\
number of newton iterations wanted (adaptivity)

\kw{MAXDT} $real$\\
maximum time step size allowed to the time adaptivity

\kw{RESULTDT} $real$\\
offset when results shall be written to .flavia.res when time adaptivity is on

\subsection{\baci{} common parameters}

\kw{RESEVRYERGY} $int$\\
write system energies every requested $int$th step

\kw{TOLRES} $real$\\
tolerance in the residual forces norm for the Newton iteration (Generalised-$\alpha$)

\kw{TOLCONSTR} $real$\\
tolerance in the constraint error norm for the Newton iteration

\kw{CONV_CHECK} $string$\\
type of convergence check in non-linear solution technique, i.e. with respect to \kw{TOLDISP} and \kw{TOLRES} we have the following control possibilities\\
\begin{tabular}{lll}
   $string$ & meaning
\\ \kw{AbsRes_And_AbsDis} & absolute norm of residual forces AND absolute norm of iterative displacements increments \\
\\ \kw{AbsRes_Or_AbsDis} & absolute norm of residual forces OR absolute norm of iterative displacements increments
\\ \kw{RelRes_And_AbsDis} & relative norm of residual forces AND absolute norm of iterative displacements increments 
\\ \kw{RelRes_Or_AbsDis}  & relative norm of residual forces OR absolute norm of iterative displacements increments  
\\ \kw{RelRes_And_RelDis} & relative norm of residual forces AND relative norm of iterative displacements increments 
\\ \kw{RelRes_Or_RelDis} & relative norm of residual forces OR relative norm of iterative displacements increments  
\end{tabular}
The relative norms are calculated by dividing the absolute norm by the norm of the overall displacements and the maximum norm of internal, external, inertial (and possibly viscous) forces of the last time step, respectively.


\kw{ADAPTCONV} (\kw{No}\kor\kw{Yes})\\
Switch on adaptive control of linear solver tolerance for nonlinear solution

\kw{ADAPTCONV_BETTER} $float$\\
The linear solver shall be this much better than the current nonlinear residual in the nonlinear convergence limit

\kw{PREDICT} $string$\\
set predictor for non-linear solution technique
\begin{tabular}{ll}
   \kw{Vague} & undetermined
\\ \kw{ConstDis} & constant displacements, consistent velocities and accelerations
\\ \kw{ConstDisVelAcc} & consta displacements, velocties and accelerations
\end{tabular}

\kw{UZAWAPARAM} $float$\\
Parameter for Uzawa algorithm dealing with lagrange multipliers

\kw{UZAWATOL} $float$\\
Tolerance for iterative solve with Uzawa algorithm

\kw{UZAWAMAXITER} $int$\\
maximum number of iterations allowed for uzawa algorithm before failure going to next newton step

\kw{UZAWAALGO} (\kw{iterative}\kor\kw{direct})\\
Uzawa algorithm

\subsection{\baci{} \texttt{StruGenAlpha}  parameters}

\kw{BETA} $real$\\
$\beta$ factor of generalized-$\alpha$

\kw{GAMMA} $real$\\
$\gamma$ factor of generalized-$\alpha$

\kw{ALPHA_M} $real$\\
$\alpha_m$ factor of generalized-$\alpha$

\kw{ALPHA_F} $real$\\
$\alpha_f$ factor of generalized-$\alpha$

\subsection{\baci{} \texttt{STR::TimInt} parameters}

\begin{verbatim}
---------------------------------------STRUCTURAL DYNAMIC/GENALPHA
\end{verbatim}

\kw{GENAVG} (\kw{ImrLike}\kor\kw{TrLike})\\
mid-average type of internal forces

\kw{BETA} $real$\\
Generalised-alpha coefficient in $(0,1/2]$

\kw{GAMMA} $real$\\
Generalised-alpha factor in $(0,1]$

\kw{ALPHA_M} $real$\\
Generalised-alpha factor in $[0,1)$

\kw{ALPHA_F} $real$\\
Generalised-alpha factor in $[0,1)$

\begin{verbatim}
-----------------------------------STRUCTURAL DYNAMIC/ONESTEPTHETA
\end{verbatim}

\kw{THETA}
One-step-theta coefficient $\theta$ in $(0,1]$

\begin{verbatim}
-------------------------------------------STRUCTURAL DYNAMIC/GEMM
\end{verbatim}

\kw{ALPHA_M} $real$\\
Generalised-alpha coefficient $\alpha_m$ in $[0,1)$

\kw{ALPHA_F} $real$\\
Generalised-alpha coefficient $\alpha_f$ in $[0,1)$

\kw{XI} $real$\\
Generalisation damping coefficient $\xi$ in $[0,1)$

\subsection{\baci{} \texttt{STR::TimAda} parameters}

\begin{verbatim}
---------------------------------STRUCTURAL DYNAMIC/TIMEADAPTIVITY
\end{verbatim}

\kw{KIND} (\kw{None}\kor\kw{ZienkiewiczXie}\kor\kw{AdamsBashforth2})\\
Method for time step size adapivity; \kw{None} means no adapivity in time

\kw{OUTSYSPERIOD} $real$\\
Write system vectors (displacements, velocities, etc) every given period of time; if $0$ writing is off

\kw{OUTSTRPERIOD} $real$\\
Write stress/strain every given period of time; if $0$ writing is off

\kw{OUTENEPERIOD} $real$\\
Write energy every given period of time; if $0$ writing is off

\kw{OUTRESTPERIOD} $real$\\
Write restart data every given period of time; if $0$ writing is off

\kw{OUTSIZEEVERY} $int$\\
Write step size every given time step

\kw{STEPSIZEMAX} $real$\\
Limit maximally permitted time step size ($>0$)

\kw{STEPSIZEMIN} $real$\\
Limit minimally allowed time step size ($>0$)

\kw{SIZERATIOMAX} $real$\\
Limit maximally permitted change of time step size compared to previous size, important for multi-step schemes ($>0$)

\kw{SIZERATIOMIN} $real$\\
Limit minimally permitted change of time step size compared to previous size, important for multi-step schemes ($>0$)

\kw{SIZERATIOSCALE} $real$\\
This is a safety factor to scale theretical optimal step size, should be lower than 1 and must be larger than $0$

\kw{LOCERRNORM} (\kw{L1}\kor\kw{L2}\kor\kw{Rms}\kor\kw{Inf})\\
Vector norm to treat error vector with

\kw{LOCERRTOL} $real$\\
Target local error tolerance ($>0$)

\kw{ADAPTSTEPMAX} $int$\\
Limit maximally allowed step size reduction attempts ($>0$)

%%
%%............................generalised-alpha
\section{Generalised-$\alpha$}

Works generally.

\subsection{Shortcomings in \ccarat implementation}
Individual/No load curves. Currently, all external loads are scaled with
  the load curve \cod{CURVE1}, which \emph{must} be applied


%%
%%............................generalised energy-momentum-conserving
\section{Generalized energy-momentum method -- \ccarat{} Gen\_EMM}
Coded by Izzet \"{O}zdemir (Master thesis ``An approach to contact in
computational structural dynamics'', 2003)

The routine
\begin{enumerate}
\item is supposed for
  \begin{itemize}
  \item WALL1
  \item SHELL8 is malware $\to$ remove
  \end{itemize}
\item is based on Simo \& Tarnow energy-momemtum conserving scheme, giving
  an asymmetric stiffness matrix 
\item conserves total energy (yessssssssssssssssssssssssss) Tested with
  prescribed boundary displacement, loads were not applied.
\item conserves total energy, linear and angular momemtum. Tested with
  unsupported body, loads are switched off with 1st Load Curve after a while. 
\item does not extract external (potential) loads, bad to test for
  conservative loading 
\item Contact was not tested (node-to-segment)
\item possesses adaptive time-step fragments
\item src/Input \cod{w1\_gemm\_contact\_emconserv.dat}
\end{enumerate}

\subitempart{Suggestions}
\begin{enumerate}
\item Check thoroughly
\item Improve on WALL1 calculation; right now activation is controlled by
  pre-proccessor flag such that either generalised-$alpha$ or GEMM is
  available; maybe new ACTION, or flag in wall1(...)
\item Add SOLID3
\end{enumerate}

%%
%%............................central differences
\section{Central differences -- \ccarat Centr\_Diff}
Algorithm:
\begin{gather*}
  \left\{\begin{array}{l}
     \vct{D}_{n+1} = \vct{D}_n + \Dt \vct{V}_n + \frac{\Dt^2}{2} \vct{A}_n
  \\
     \vct{A}_{n+1} = \mat{M}^{-1} \big( 
                     \vct{F}_\Int(\vct{D}_{n+1}) 
                     - \vct{F}_\Ext(t_{n+1})
                     \big)
  \\
     \vct{V}_{n+1} 
               = \vct{V}_n + \frac{\Dt}{2} \big( 
               \vct{A}_n + \vct{A}_{n+1} \big)
  \end{array}\right.
\end{gather*}
\begin{enumerate}
\item Method works explicitly for a few elements. Un-/Supported elements
  \begin{itemize}
  \item[$+$] WALL1, SHELL8, SHELL9
  \item[$-$] BRICK1, BEAM3, WALLGE
  \end{itemize}
\item src/Input \cod{krag\_2ele\_expl.dat}
\end{enumerate}

\subitempart{Suggestions}
\begin{enumerate}
\item Add time step-size adapitvity
\item Store inverted mass matrix once and for all; or even dummy solver for
  lumped mass matrix
\end{enumerate}

%%
%%............................Inclined BCs for retro-discretisation
\section{Inclined boundary conditions (BCs) -- \ccarat{}}

\subsection{About}
Sometimes it is desirable to have boundary conditions
which are not oriented in the global Cartesian $XYZ$-axes,
but in other directions. This occurs for instance with
rotatory symmetric problems.

\subsection{Method}
The implementation is an adaptation of Steffen Genkinger's
local systems (locsys, for fluid) to structures.
The idea is to rotate the DOFs on an inclined boundary in the
direction of a local co-ordinate system. These locally oriented
DOFs are solved on the global level. The generalised-alpha holds
locally oriented DOFs for all DOFs at Dirichlet nodes
(prescribed/supported \& free DOFs there). Therefore, all assembled
quantities (stiffness, mass, internal force, velocity, etc) have
at certain nodes rotated DOFs. On the other hand, the `\texttt{sol}', 
`\texttt{sol\_increment}', etc arrays at the \texttt{NODE}s are always globally
oriented (except for intermediate operations at solution algo level)

\subsection{Gid input}
\begin{enumerate}
\item Define \& name (e.g. `\textit{mysys}') local axes\\
       Data $\to$ Local axes $\to$ Define
\item Assign local systems to design points, lines and surface to which
       inclinded BCs are wanted. E.g.\\
       \texttt{Data} $\to$ \texttt{Conditions} $\to$ \texttt{Single} $\to$ \texttt{Layer} $\to$ \texttt{Points} $\to$ \texttt{Locsys Point}\\
       choose \texttt{LocsysId} (e.g. \textit{1})\\
       You need to apply to the full hierarchy
       of design element. It avoids conflicts on lines which belong
       to different Dirichlet BCs coming from higher entities.
\item Bind to \texttt{locsysId} the named  (e.g. `\textit{mysys}') local axes\\
       Data $\to$ Problem Data $\to$ Locsys\\
       \texttt{Locsys\_1} : \texttt{on}\\
       \texttt{Locsys\_Typ\_1} : \texttt{BASEVEC}\\
       \texttt{Ls1\_Basevec\_Input\_Type} : \texttt{LocalAxes\_Name}\\
       \texttt{Ls1\_LocalAxes\_Name} : `\textit{mysys}'\\
\end{enumerate}

\subsection{Compilation}
\texttt{LOCALSYSTEMS\_ST} preprocessor definition required (\texttt{defines} file)

\subsection{Restrictions}
\begin{itemize}
\item Available in old discretisation
\item Implemented for 
   \begin{itemize}
   \item \texttt{WALL1} (untested)
   \item \texttt{BRICK1} (untested)
   \item \texttt{SOLID3} (verified)
   \end{itemize}
\item Prescribed deflection of DOFs available
\item Solution technique: Generalised-alpha (\texttt{stru\_dyn\_nln.c})
\item fsiloads in \texttt{WALL1}???
\item test file \texttt{so3\_dyn\_inclined\_bc.dat}
\end{itemize}