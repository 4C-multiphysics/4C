
\chapter{The code design of \baci{}}

You have read so many chapters of the \baci{} guide already, now here we come
to the stuff you really want to know. But please be careful. This is meant to
serve as an introduction to a very detail rich topic. There are a few simple
statements here so you can get a broad picture. You will have to dig deeper to
find the exceptions.

\section{Design goals}

\baci{} aims to be a multi-field, multi-purpose, multi-younameit parallel FE
package that supports all kinds of weird use cases. Possible types of
calculations \baci{} supports include

\begin{description}
\item [Single field] The obvious one. One mesh with nodes, elements, dofs. One
time loop. Examples are structural or fluid dynamics.
\item [Multi field] Several physical fields. FSI calculations for
example. Three different fields with one mesh each. Accordingly three
different kinds of elements, three distinct (but intervened) solution
algorithms. 
\item [Multi mesh] Calculations with several meshes in one physical
field. Examples include fluid calculations with background mesh and moving
(rotating) front mesh. (There is currently no implementation of this.)
\item [Multi dof set] Some calculation have to solve different equations on
the same mesh, like fluid projection algorithms. This can be done with one
mesh, you just have to exchange the dof numbers. (Projection method is
unimplemented right now.)
\item [Multi problem] And if you happen to suffer from multiple problems at
once, you might end up reading many input files at the same time. This happens
with micro-macro couplings for example.
\end{description}

All these use cases come with their specific algorithmic challenges, their
build in hassle and so on. The mechanical content is outside of this
discussion. But \baci{} provides the data structures to handle such
things. The design of \baci{} was meant to make such problem types (easily)
possible.

\section{Fundamental building blocks}

From the above list of anticipated use cases the most fundamental building
blocks can be derived.

\begin{enumerate}

\item Central to each FE package is the mesh with its elements and
nodes. These are available via the classes \texttt{DRT::Discretization},
\texttt{DRT::Element} and \texttt{DRT::Node} (and the respective subclasses.)
In \baci{} we have many \texttt{DRT::Element} subclasses. Each subclasses
provides a physically distinct element type.

\item For flexibility the dofs are not directly attached to nodes (or
elements), but are managed by an \texttt{DRT::DofSet} object. This is an
internal detail most users do not need to know. But this way multiple
global systems with different sizes are possible.

\item The calculation of a particular case involves a solution
algorithm, that is a time loop, a nonlinear Newton iteration, an embedded
linear solver and all the glorious details. This sounds pretty much like a
large function, but in \baci{} algorithms are actually objects. This helps to
combine different algorithms to obtain a larger one. For example the FSI
algorithm class uses the structural and the fluid algorithm classes for the
respective fields.

\item All meshes of the problem are stored by the global \texttt{DRT::Problem}
object. There exists one object of this class. The whole setup (that is dat
file input) is managed here. 

\item Actually there is one \texttt{DRT::Problem} object for each dat file you
read. So most of the time there is one such object. Only very special problems
require multiple dat file to be read at the same time.

\end{enumerate}

\section{Historical perspective}

As \baci{} envolved out of \ccarat{} some aspect of its current design might
seem odd or downright silly. There is, however, an ingenious design behind all
of this. To understand \baci{}'s design it helps a lot to know \ccarat{}.

%\baci{} is not ashamed of its ancestors. 

Of course some mistakes of \ccarat{} take a long time to overcome. \ccarat{}
made extensive use of global variables. \baci{} avoids global variables at all
costs. There are none --- except for a few we have inherited from \ccarat{}
and not yet abandoned.

\section{Parallel calculation building blocks}

\baci{} is a parallel code. Parallelization is gained by data splitting. That
is each processor performs the same steps, everyone calculates the same thing,
only the numbers are different. The whole picture is obtained by combining the
results from all processors.

This kind of parallelization is the simplest one possible. Most of the time
you do not have to think of different processors at all. 

At the heart of its parallelization there are a few classes from the trilinos
library Epetra. The most important ones are, in increasing complexity.

\begin{description}

\item [Epetra\_Comm] provides basic communication mechanisms. An object of
\texttt{Epetra\_Comm} is needed by every other Epetra class.

\item [Epetra\_Map] describes the parallel distribution of things. Things can
be anything as long as each one has an unique id. \texttt{Epetra\_Map}
describes the parallel distribution of these ids.

\item [Epetra\_Vector] is a parallel vector that is distributed based on a
\texttt{Epetra\_Map}. 

\item [Epetra\_CrsMatrix] is a parallel sparse matrix. Here one
\texttt{Epetra\_Map} object (non-overlapping) describes the distribution of
the matrix rows. Another \texttt{Epetra\_Map} object (overlapping) describes
the distribution of the columns inside each row.

\end{description}

Of course the base classes of those are just as important. It is a very good
idea to became familiar with Epetra. There is doxygen documentation on the
trilinos website.

So Epetra provides basic linear algebra objects. The overall FE algorithms in
\baci{} are constructed using these objects. At this level parallelization
comes (almost) by itself.

\section{Input machinery}

Before the calculation starts \baci{} performes a rather elaborated input
step. The goal of this is to construct and setup the \texttt{DRT::Problem}
object according to the dat file contents. The main content of the
\texttt{DRT::Problem} object are the \texttt{DRT::Discretization} objects, one
for each mesh. A \texttt{DRT::Discretization} object knows two states: filled
and non-filled. After the input phase all \texttt{DRT::Discretization} objects
are in filled state, that is all elements and nodes are in their final
parallel distribution, all dofs are assigned, all maps constructed and
everything is finished to launch into the calculation.

During the input phase the
\texttt{DRT::INPUT::DatFileReader} class and other helper classes from
\texttt{DRT::INPUT} are used. These objects are destroyed once the input step
is finished.

Different things need to be read from the input file.

\begin{itemize}

\item General parameters. (key, value) pairs. That is a large
\texttt{Teuchos::ParameterList} with lots of sublists.

\item Node ids and coordinates

\item Element connectivity and element flags

\item (boundary) conditions connected to sets of nodes

\item time curve definitions

\item spacial function definitions

\item material definitions

\item result test values (test runs only)

\end{itemize}

From these items element and nodal data are the voluminous ones. In a parallel
run we do not read all elements or nodes at once in one processor. Instead
processor 0 reads and constructs subsets of elements and distributs them to
another processor before the next subset is read. This is performed by the
\texttt{DRT::INPUT::DatFileReader} with the help of
\texttt{DRT::INPUT::ElementReader} and \texttt{DRT::INPUT::NodeReader}.

All other dat file sections are distributed to all processors inside
\texttt{DRT::INPUT::DatFileReader} and read on each processor. This way all
processors get to know all flags and conditions.

\section{Further documentation}

\baci{} itself comes with a very good doxygen documentation. The
\texttt{Doxyfile} is in the \texttt{doc} directory. Use it. It gives a nice
picture of namespaces and classes in \baci{}.

\section{Books}

These books are in general recommended if you want to read about C++ or
object oriented software design.

\begin{description}

\item[Gamma {\em et al.} 1996]
{\sc E.~Gamma}; {\sc R.~Helm}; {\sc R.~Johnson} and{}\ {\sc J.~Vlissides}\ (1996).
\newblock {\em Entwurfsmuster\/}.
\newblock {Ad\-di\-son-Wes\-ley}, Reading, Massachusetts.

\item[Meyers 1995]
{\sc Meyers, Scott}\ (1995).
\newblock {\em More Effective \textsf{C++}\/}.
\newblock {Ad\-di\-son-Wes\-ley}, Reading, Massachusetts.

\item[Meyers 1998]
{\sc Meyers, Scott}\ (1998).
\newblock {\em Effective \textsf{C++}\/}.
\newblock {Ad\-di\-son-Wes\-ley}, Reading, Massachusetts, 2.

\item[Meyers 2001]
{\sc Meyers, Scott}\ (2001).
\newblock {\em Effective STL\/}.
\newblock {Ad\-di\-son-Wes\-ley}, Reading, Massachusetts.

%\bibitem[{\sc Stevens} 1995]{Stevens}
%{\sc Stevens, W.~Richard}\ (1995).
%\newblock {\em Programmierung in der UNIX-Umgebung\/}.
%\newblock {Ad\-di\-son-Wes\-ley}, Reading, Massachusetts.

%\bibitem[{\sc Stroustrup} 1994]{TDEC}
%{\sc Stroustrup, Bjarne}\ (1994).
%\newblock {\em The Design and Evolution of \textsf{C++}\/}.
%\newblock {Ad\-di\-son-Wes\-ley}, Reading, Massachusetts.

\item[Stroustrup 1998]
{\sc Stroustrup, Bjarne}\ (1998).
\newblock {\em Die \textsf{C++} Programmiersprache\/}.
\newblock {Ad\-di\-son-Wes\-ley}, Reading, Massachusetts, 3.

\item[Fowler 1996]
{\sc Fowler, Martin}\ (1996).
\newblock {\em Analysis Patterns: Reusable Object Models\/}.
\newblock {Ad\-di\-son-Wes\-ley}, Reading, Massachusetts.

%\bibitem[{\sc Fowler} \btxandshort{}\ {\sc Scott} 1999]{UML}
%{\sc Fowler, Martin} \btxandshort{}\ {\sc K.~Scott}\ (1999).
%\newblock {\em UML Distilled: A Brief Guide to the Standard Object Modeling
%  Language\/}.
%\newblock {Ad\-di\-son-Wes\-ley}, Reading, Massachusetts, 2.~\btxeditionshort{.}

\item[Alexandrescu 2001]
{\sc Alexandrescu, Andrei}\ (2001).
\newblock {\em Modern \textsf{C++} Design\/}.
\newblock {Ad\-di\-son-Wes\-ley}, Reading, Massachusetts.

\item[Booch 1994]
{\sc Booch, Grady}\ (1994).
\newblock {\em Objektorientierte Analyse und Design\/}.
\newblock {Ad\-di\-son-Wes\-ley}, Reading, Massachusetts.

\end{description}

