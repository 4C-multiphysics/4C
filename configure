#!/bin/sh
#
# CCARAT Configuration
# 
# Create a Makefile with dependency information for a user supplied configuration file.
#

# some usability tests
if [ "x$1" = "x" -o "x$2" = "x" ]; then
  echo usage: $0: config-file-name defines-file-name
  exit 1
fi

if [ ! -s "$1" ]; then
  echo $0: file not found: $1
  exit 1
fi

if [ ! -r "$1" ]; then
  echo $0: file not readable: $1
  exit 1
fi

if [ ! -s "$2" ]; then
  echo $0: file not found: $2
  exit 1
fi

if [ ! -r "$2" ]; then
  echo $0: file not readable: $2
  exit 1
fi


# default values
SRC=.

CC=cc
F77=f77
LD=f77

# 64 bit exe?
if grep '^SIXTYFOUR' "$2" 2>&1 > /dev/null ; then
   BIT=64
else
   BIT=32   
fi


# source config file
# Here we get all the variables.
. "$1"


# get the define flags

DEFINES=`sed -e 's/#.*//' "$2" | awk 'BEGIN { defs = "" }
END { print defs }
  { if (length($1) > 0) { defs = defs" -D"$1 } }'`

#echo ">>>" $DEFINES "<<<"
#exit

# add special cflags from command line
if [ $# -eq 3 ] ; then
    echo "Found special cflags on the command line !!"
    CFLAGS="$CFLAGS $3"
    FFLAGS="$FFLAGS $3"
fi


# the debug version needs special treatment
if grep '^DEBUG' "$2" 2>&1 > /dev/null ; then
    DEBUGFLAG=-g
    PROGRAMNAME=$PROGRAMNAME.debg
else
    DEBUGFLAG=
    PROGRAMNAME=$PROGRAMNAME.fast

    CFLAGS="$CFLAGS $CFLAGS_OPT"
    FFLAGS="$FFLAGS $FFLAGS_OPT"
    LDFLAGS="$LDFLAGS $LDFLAGS_OPT"
fi

# a parallel version needs one more compile time flag
if [ x$PARALLEL = "xyes" ] ; then
    DEFINES=" -DPARALLEL $DEFINES"
fi

# check the different solvers

# aztec
if grep '^AZTEC_PACKAGE' "$2" 2>&1 > /dev/null ; then
    if [ "x$AZTEC_LIB" = "x" ] ; then
        echo $0: Warning: Variable AZTEC_LIB undefined but AZTEC_PACKAGE requested.        
    fi
    LIBS="$AZTEC_LIB $LIBS"
    INCLUDEDIRS="$INCLUDEDIRS $AZTEC_INC"
fi

# spooles
if grep '^SPOOLES_PACKAGE' "$2" 2>&1 > /dev/null ; then
    if [ "x$SPOOLES_LIB" = "x" ] ; then
        echo $0: Warning: Variable SPOOLES_LIB undefined but SPOOLES_PACKAGE requested.
    fi
    LIBS="$SPOOLES_LIB $LIBS"
    INCLUDEDIRS="$INCLUDEDIRS $SPOOLES_INC"
fi

# umfpack
if grep '^UMFPACK' "$2" 2>&1 > /dev/null ; then
    if [ "x$UMFPACK_LIB" = "x" ] ; then
        echo $0: Warning: Variable UMFPACK_LIB undefined but UMFPACK_PACKAGE requested.
    fi
    LIBS="$UMFPACK_LIB $LIBS"
    INCLUDEDIRS="$INCLUDEDIRS $UMFPACK_INC"
fi

# visual2
if grep '^VISUAL2_PACKAGE' "$2" 2>&1 > /dev/null ; then
    if [ "x$VISUAL2_LIB" = "x" ] ; then
        echo $0: Error: Variable VISUAL2_LIB undefined but VISUAL2_PACKAGE requested.
        exit 1
    fi
    if [ x$BIT = "x64" ] ; then
        echo $0: Error: VISUAL2 not possible in 64 bit executable.
        exit 1
    fi
    LIBS="$VISUAL2_LIB $LIBS"
    INCLUDEDIRS="$INCLUDEDIRS $VISUAL2_INC"
fi

# visual3
if grep '^VISUAL3_PACKAGE' "$2" 2>&1 > /dev/null ; then
    if grep '^VISUAL2_PACKAGE' "$2" 2>&1 > /dev/null ; then
       echo $0: Error: VISUAL2 & VISUAL3 cannot linked into the same executable. 
       exit 1
    fi
    if [ "x$VISUAL3_LIB" = "x" ] ; then
        echo $0: Error: Variable VISUAL3_LIB undefined but VISUAL3_PACKAGE requested.
        exit 1
    fi
    if [ x$BIT = "x64" ] ; then
        echo $0: Error: VISUAL3 not possible in 64 bit executable.
        exit 1
    fi
    LIBS="$VISUAL3_LIB $LIBS"
    INCLUDEDIRS="$INCLUDEDIRS $VISUAL2_INC"
fi

# fluid objects:
OBJ_FLUID=0


# objects:
OBJECTS="\$(OBJS_MAIN) \$(OBJS_GLOBAL) \$(OBJS_PSS) \$(OBJS_INPUT) \
\$(OBJS_PAR) \$(OBJS_MATH) \$(OBJS_OUTPUT) \$(OBJS_FORTRAN)"

# ALE
if grep '^D_ALE' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_ALE)"
fi

# AXISHELL
if grep '^D_AXISHELL' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_AXISHELL)"
fi

# BEAM3
if grep '^D_BEAM3' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_BEAM3)"
fi

# BRICK1
if grep '^D_BRICK1' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_BRICK1)"
fi

# FLUID2 
if grep '^D_FLUID2' "$2" 2>&1 > /dev/null ; then
    if [ "x$OBJ_FLUID" = "x0" ] ; then
        OBJECTS="$OBJECTS \$(OBJS_FLUID2) \$(OBJS_FLUID)"
        OBJ_FLUID=1
    else
        OBJECTS="$OBJECTS \$(OBJS_FLUID2)"
    fi
fi

# FLUID2_ML
if grep '^FLUID2_ML' "$2" 2>&1 > /dev/null ; then
    if [ "x$OBJ_FLUID" = "x0" ] ; then
        OBJECTS="$OBJECTS \$(OBJS_F2ML) \$(OBJS_FLUID)"
        OBJ_FLUID=1
    else
        OBJECTS="$OBJECTS \$(OBJS_F2ML)"
    fi
fi

# FLUID3
if grep '^D_FLUID3' "$2" 2>&1 > /dev/null ; then
    if [ "x$OBJ_FLUID" = "x0" ] ; then
        OBJECTS="$OBJECTS \$(OBJS_FLUID3) \$(OBJS_FLUID)"
        OBJ_FLUID=1
    else
        OBJECTS="$OBJECTS \$(OBJS_FLUID3)"
    fi
fi

# FLUID3_ML
if grep '^FLUID3_ML' "$2" 2>&1 > /dev/null ; then
    if [ "x$OBJ_FLUID" = "x0" ] ; then
        OBJECTS="$OBJECTS \$(OBJS_F3ML) \$(OBJS_FLUID)"
        OBJ_FLUID=1
    else
        OBJECTS="$OBJECTS \$(OBJS_F3ML)"
    fi
fi

# FLUID2_PR
if grep '^D_FLUID2_PR' "$2" 2>&1 > /dev/null ; then
    if [ "x$OBJ_FLUID" = "x0" ] ; then
        OBJECTS="$OBJECTS \$(OBJS_F2PRO) \$(OBJS_FLUID)"
        OBJ_FLUID=1
    else
        OBJECTS="$OBJECTS \$(OBJS_F2PRO)"
    fi
fi

# SHELL8
if grep '^D_SHELL8' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_SHELL8)"
fi

# SHELL9
if grep '^D_SHELL9' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_SHELL9)"
fi

# WALL1
if grep '^D_WALL1' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_WALL1)"
fi

# INTERF
if grep '^D_INTERF' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_IF)"
fi

# WALLGE
if grep '^D_WALLGE' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_WALLGE)"
fi

# FSI
if grep '^D_FSI' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_FSI)"
fi

# OPTIM 
if grep '^D_OPTIM' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_OPT)"
fi

# MAT
if grep '^D_MAT' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_MAT)"
fi

# LS
if grep '^D_LS' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_LS)"
fi

# XFEM
if grep '^D_XFEM' "$2" 2>&1 > /dev/null ; then
    OBJECTS="$OBJECTS \$(OBJS_XFEM)"
fi



# build the Makefile
# This is done in three steps

# step 1: store all user supplied variables
#
cat > Makefile <<EOF
#
# Variables
#
SRC=$SRC

CC=$CC
F77=$F77
LD=$LD

PROGRAM=$PROGRAMNAME

CFLAGS=$CFLAGS $DEBUGFLAG -D$PLATFORM $DEFINES
FFLAGS=$FFLAGS $DEBUGFLAG -D$PLATFORM $DEFINES

LDFLAGS=$LDFLAGS
INCLUDES=$INCLUDEDIRS
LIBS=$LIBDIRS $LIBS

#----------------------- binaries -----------------------------------
include ./Makefile.objects
#--------------------------------------------------------------------
#
\$(PROGRAM): \\
		$OBJECTS
		@echo "Linking \$(LD) \$(LDFLAGS) \$(LIBS) \$(INCLUDES) -o \$(PROGRAM)"
		@\$(LD) \$(LDFLAGS) \\
		$OBJECTS \\
		\$(LIBS)  -o \$(PROGRAM)

EOF


# step 2: copy Makefile.in
cat Makefile.in >> Makefile
#awk '$1 !~ /include/ { print $0 } $1 ~ /include/ { system("cat " $2)}' Makefile.in >> Makefile

# step 3: build dependencies if gcc can be found
# 
# you can skip this step by saying
# $ NODEPS=yes ./configure ...
#
if [ x$NODEPS != "xyes" ] ; then
  # hopefully nobody translates which's messages...
  if which gcc | grep '^no ' 2>&1 > /dev/null ; then
     echo $0: gcc not found. No dependencies generated. Use Makefile with care.
  else
    for file in `find src -name "*.c"` ; do
      echo "build deps for" $file
      gcc -D$PLATFORM $DEFINES -MM -MT `echo $file|sed -e 's/c$/o/'` $INCLUDEDIRS $file >> Makefile
    done
  fi
fi
