Index: ccarat_strategies/src/drt_contact/contact_abstract_strategy.H
===================================================================
--- ccarat_strategies/src/drt_contact/contact_abstract_strategy.H	(revision 21910)
+++ ccarat_strategies/src/drt_contact/contact_abstract_strategy.H	(working copy)
@@ -442,17 +442,6 @@
       Teuchos::RCP<Epetra_Vector>& weightedwear,
       Teuchos::RCP<Epetra_Vector>& realwear, bool forcedrestart = false);
 
-  /*!
-   \brief Perform a write restart
-
-   A write restart is initiated by the contact manager. However, the manager has no
-   direct access to the nodal quantities. Hence, all the restart action has to be
-   performed on the level of the contact algorithm, for short: here's the right place.
-
-   */
-  void DoReadRestart(IO::DiscretizationReader& reader,
-      Teuchos::RCP<Epetra_Vector> dis);
-
     //@}
 
     //! @name Empty functions if no augmented Lagrange formulation is used
@@ -492,14 +481,35 @@
   virtual void PrintActiveSet();
 
   /*!
-   \brief Visualize contact stuff with gmsh
+   \brief Evaluate relative movement of contact bodies
 
-   \param step (in): current time step index
-   \param iter (in): current iteration index
+   This is for evaluating the relative movement of contact bodies. This
+   can either be done with regarding the different movement of material points
+   or regarding the change of mortar projection. The second possibility
+   is definitely objective wheras the first possibility is objective
+   only when the gap is zero.
 
    */
-  void VisualizeGmsh(const int step, const int iter);
 
+  void EvaluateRelMov();
+
+  /*!
+   \brief Initialize and evaluate interface for the next Newton step
+
+   This method calls Initialize() on all contact interfaces, which
+   resets all kind of nodal quantities like normal vector, weighted
+   gap or Mortar and linearization maps. It then calls Evaluate() on
+   all contact interfaces, which does all the geometric contact stuff.
+   Concretely, this is an evaluation of all involved quantites at nodal
+   level plus the setup of all corresponding linearizations.
+   It includes the nodal normal calculations, contact search, projection
+   and overlap detection, integration of the  Mortar terms D, M and of the
+   weighted gap. Additionally, the linearizations of geometrical quantities
+   (delta_n, delta_t, delta_D, delta_M) are calculated.
+
+   */
+  void InitEvalInterface();
+
   //@}
 
   //! @name Purely virtual functions
@@ -567,19 +577,6 @@
       Teuchos::RCP<Epetra_Vector>& feff, Teuchos::RCP<Epetra_Vector> dis);
 
   /*!
-   \brief Evaluate relative movement of contact bodies
-
-   This is for evaluating the relative movement of contact bodies. This
-   can either be done with regarding the different movement of material points
-   or regarding the change of mortar projection. The second possibility
-   is definitely objective wheras the first possibility is objective
-   only when the gap is zero.
-
-   */
-
-  void EvaluateRelMov();
-
-  /*!
    \brief Initialize and evaluate Mortar stuff for the next Newton step
 
    This method first checks if we are dealing with self contact and updates
@@ -596,23 +593,6 @@
   void AssembleMortar();
 
   /*!
-   \brief Initialize and evaluate interface for the next Newton step
-
-   This method calls Initialize() on all contact interfaces, which
-   resets all kind of nodal quantities like normal vector, weighted
-   gap or Mortar and linearization maps. It then calls Evaluate() on
-   all contact interfaces, which does all the geometric contact stuff.
-   Concretely, this is an evaluation of all involved quantites at nodal
-   level plus the setup of all corresponding linearizations.
-   It includes the nodal normal calculations, contact search, projection
-   and overlap detection, integration of the  Mortar terms D, M and of the
-   weighted gap. Additionally, the linearizations of geometrical quantities
-   (delta_n, delta_t, delta_D, delta_M) are calculated.
-
-   */
-  void InitEvalInterface();
-
-  /*!
    \brief Setup this strategy object (maps, vectors, etc.)
 
    All global maps and vectors are initialized by collecting
Index: ccarat_strategies/src/drt_contact/contact_abstract_strategy.cpp
===================================================================
--- ccarat_strategies/src/drt_contact/contact_abstract_strategy.cpp	(revision 21910)
+++ ccarat_strategies/src/drt_contact/contact_abstract_strategy.cpp	(working copy)
@@ -24,9 +24,6 @@
 #include "../drt_lib/drt_discret.H"
 #include "../drt_lib/drt_colors.H"
 
-#include "../drt_io/io.H"
-#include "../drt_io/io_control.H"
-
 #include "../linalg/linalg_utils.H"
 #include "../linalg/linalg_multiply.H"
 #include "../linalg/linalg_sparsematrix.H"
@@ -1813,179 +1810,6 @@
 }
 
 /*----------------------------------------------------------------------*
- |  read restart information for contact                      popp 03/08|
- *----------------------------------------------------------------------*/
-void CONTACT::CoAbstractStrategy::DoReadRestart(
-    IO::DiscretizationReader& reader, Teuchos::RCP<Epetra_Vector> dis)
-{
-  // check whether this is a restart with contact of a previously
-  // non-contact simulation run (if yes, we have to be careful not
-  // to try to read certain, in this case non-existing, vectors
-  // such as the activetoggle or sliptoggle vectors, but rather
-  // initialize the restart active and slip sets as being empty)
-  bool restartwithcontact = DRT::INPUT::IntegralValue<int>(Params(),
-      "RESTART_WITH_CONTACT");
-
-  // set restart displacement state
-  SetState("displacement", dis);
-  SetState("olddisplacement", dis);
-
-  // evaluate interface and restart mortar quantities
-  // in the case of SELF CONTACT, also re-setup master/slave maps
-  InitMortar();
-  InitEvalInterface();
-  AssembleMortar();
-
-  //----------------------------------------------------------------------
-  // CHECK IF WE NEED TRANSFORMATION MATRICES FOR SLAVE DISPLACEMENT DOFS
-  //----------------------------------------------------------------------
-  // Concretely, we apply the following transformations:
-  // D         ---->   D * T^(-1)
-  //----------------------------------------------------------------------
-  if (Dualquadslave3d())
-  {
-    // modify dmatrix_
-    Teuchos::RCP<LINALG::SparseMatrix> temp = LINALG::MLMultiply(*dmatrix_,
-        false, *invtrafo_, false, false, false, true);
-    dmatrix_ = temp;
-  }
-
-  // read restart information on actice set and slip set (leave sets empty
-  // if this is a restart with contact of a non-contact simulation run)
-  Teuchos::RCP<Epetra_Vector> activetoggle = Teuchos::rcp(
-      new Epetra_Vector(*gsnoderowmap_));
-  if (!restartwithcontact)
-    reader.ReadVector(activetoggle, "activetoggle");
-
-  // friction
-  Teuchos::RCP<Epetra_Vector> sliptoggle;
-  Teuchos::RCP<Epetra_Vector> weightedwear;
-
-  if (friction_)
-  {
-    sliptoggle = Teuchos::rcp(new Epetra_Vector(*gsnoderowmap_));
-    if (!restartwithcontact)
-      reader.ReadVector(sliptoggle, "sliptoggle");
-  }
-
-  // store restart information on active set and slip set
-  // into nodes, therefore first loop over all interfaces
-  for (int i = 0; i < (int) interface_.size(); ++i)
-  {
-    // loop over all slave nodes on the current interface
-    for (int j = 0; j < (interface_[i]->SlaveRowNodes())->NumMyElements(); ++j)
-    {
-      int gid = (interface_[i]->SlaveRowNodes())->GID(j);
-      int dof = (activetoggle->Map()).LID(gid);
-
-      if ((*activetoggle)[dof] == 1)
-      {
-        DRT::Node* node = interface_[i]->Discret().gNode(gid);
-        if (!node)
-          dserror("ERROR: Cannot find node with gid %", gid);
-        CoNode* cnode = dynamic_cast<CoNode*>(node);
-
-        // set value active / inactive in cnode
-        cnode->Active() = true;
-
-        if (friction_)
-        {
-          // set value stick / slip in cnode
-          if ((*sliptoggle)[dof] == 1)
-            dynamic_cast<CONTACT::FriNode*>(cnode)->FriData().Slip() = true;
-        }
-      }
-    }
-  }
-
-  // read restart information on Lagrange multipliers
-  z_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  zold_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  if (!restartwithcontact)
-    reader.ReadVector(LagrMult(), "lagrmultold");
-  if (!restartwithcontact)
-    reader.ReadVector(LagrMultOld(), "lagrmultold");
-
-  // Lagrange multiplier increment is always zero (no restart value to be read)
-  zincr_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-
-  // store restart information on Lagrange multipliers into nodes
-  StoreNodalQuantities(MORTAR::StrategyBase::lmcurrent);
-  StoreNodalQuantities(MORTAR::StrategyBase::lmold);
-
-  // only for Uzawa augmented strategy
-  // TODO: this should be moved to contact_penalty_strategy
-  if (stype_ == INPAR::CONTACT::solution_uzawa)
-  {
-    zuzawa_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-    if (!restartwithcontact)
-      reader.ReadVector(LagrMultUzawa(), "lagrmultold");
-    StoreNodalQuantities(MORTAR::StrategyBase::lmuzawa);
-  }
-
-  // store restart Mortar quantities
-  StoreDM("old");
-
-  if (friction_)
-  {
-    StoreNodalQuantities(MORTAR::StrategyBase::activeold);
-    StoreToOld(MORTAR::StrategyBase::dm);
-  }
-
-  // (re)setup active global Epetra_Maps
-  gactivenodes_ = Teuchos::null;
-  gactivedofs_ = Teuchos::null;
-  gactiven_ = Teuchos::null;
-  gactivet_ = Teuchos::null;
-  gslipnodes_ = Teuchos::null;
-  gslipdofs_ = Teuchos::null;
-  gslipt_ = Teuchos::null;
-
-  // update active sets of all interfaces
-  // (these maps are NOT allowed to be overlapping !!!)
-  for (int i = 0; i < (int) interface_.size(); ++i)
-  {
-    interface_[i]->BuildActiveSet();
-    gactivenodes_ = LINALG::MergeMap(gactivenodes_,
-        interface_[i]->ActiveNodes(), false);
-    gactivedofs_ = LINALG::MergeMap(gactivedofs_, interface_[i]->ActiveDofs(),
-        false);
-    gactiven_ = LINALG::MergeMap(gactiven_, interface_[i]->ActiveNDofs(),
-        false);
-    gactivet_ = LINALG::MergeMap(gactivet_, interface_[i]->ActiveTDofs(),
-        false);
-    if (friction_)
-    {
-      gslipnodes_ = LINALG::MergeMap(gslipnodes_, interface_[i]->SlipNodes(),
-          false);
-      gslipdofs_ = LINALG::MergeMap(gslipdofs_, interface_[i]->SlipDofs(),
-          false);
-      gslipt_ = LINALG::MergeMap(gslipt_, interface_[i]->SlipTDofs(), false);
-    }
-  }
-
-  // update flags for global contact status
-  if (gactivenodes_->NumGlobalElements())
-  {
-    isincontact_ = true;
-    wasincontact_ = true;
-    wasincontactlts_ = true;
-  }
-
-  // evaluate relative movement (jump)
-  // needed because it is not called in the predictor of the
-  // lagrange multiplier strategy
-  EvaluateRelMov();
-
-  // reset unbalance factors for redistribution
-  // (during restart the interface has been evaluated once)
-  tunbalance_.resize(0);
-  eunbalance_.resize(0);
-
-  return;
-}
-
-/*----------------------------------------------------------------------*
  |  Compute interface forces (for debugging only)             popp 02/08|
  *----------------------------------------------------------------------*/
 void CONTACT::CoAbstractStrategy::InterfaceForces(bool output)
@@ -2679,15 +2503,6 @@
   return;
 }
 
-/*----------------------------------------------------------------------*
- | Visualization of contact segments with gmsh                popp 08/08|
- *----------------------------------------------------------------------*/
-void CONTACT::CoAbstractStrategy::VisualizeGmsh(const int step, const int iter)
-{
-  // visualization with gmsh
-  for (int i = 0; i < (int) interface_.size(); ++i)
-    interface_[i]->VisualizeGmsh(step, iter);
-}
 
 /*----------------------------------------------------------------------*
  | collect maps for preconditioner (AMG)                   wiesner 01/12|
Index: ccarat_strategies/src/drt_contact/contact_lagrange_strategy.cpp
===================================================================
--- ccarat_strategies/src/drt_contact/contact_lagrange_strategy.cpp	(revision 21910)
+++ ccarat_strategies/src/drt_contact/contact_lagrange_strategy.cpp	(working copy)
@@ -17,7 +17,6 @@
 #include "friction_node.H"
 #include "../drt_mortar/mortar_utils.H"
 #include "../drt_inpar/inpar_contact.H"
-#include "../drt_io/io.H"
 #include "../linalg/linalg_multiply.H"
 #include "../linalg/linalg_utils.H"
 
Index: ccarat_strategies/src/drt_contact/contact_wear_lagrange_strategy.H
===================================================================
--- ccarat_strategies/src/drt_contact/contact_wear_lagrange_strategy.H	(revision 21910)
+++ ccarat_strategies/src/drt_contact/contact_wear_lagrange_strategy.H	(working copy)
@@ -146,17 +146,7 @@
                       Teuchos::RCP<Epetra_Vector>& realwear,
                       bool forcedrestart = false);
 
-  /*!
-  \brief Perform a write restart
 
-  A write restart is initiated by the contact manager. However, the manager has no
-  direct access to the nodal quantities. Hence, all the restart action has to be
-  performed on the level of the contact algorithm, for short: here's the right place.
-
-  */
-  void DoReadRestart(IO::DiscretizationReader& reader, Teuchos::RCP<Epetra_Vector> dis);
-
-
   /*!
   \brief Update active set and check for convergence
 
Index: ccarat_strategies/src/drt_contact/contact_wear_lagrange_strategy.cpp
===================================================================
--- ccarat_strategies/src/drt_contact/contact_wear_lagrange_strategy.cpp	(revision 21910)
+++ ccarat_strategies/src/drt_contact/contact_wear_lagrange_strategy.cpp	(working copy)
@@ -30,10 +30,9 @@
 #include "../drt_mortar/mortar_utils.H"
 #include "../drt_inpar/inpar_contact.H"
 #include "../drt_inpar/inpar_wear.H"
-#include "../drt_io/io.H"
 
+#include "../linalg/linalg_multiply.H"
 #include "../linalg/linalg_utils.H"
-#include "../linalg/linalg_solver.H"
 #include <Epetra_FEVector.h>
 
 /*----------------------------------------------------------------------*
@@ -2753,187 +2752,6 @@
   {
     PrepareSaddlePointSystem(kteff,feff);
   }
-  // FD checks...
-#ifdef WEARIMPLICITFDLM
-  for (int i=0; i<(int)interface_.size(); ++i)
-  {
-    if (!wearimpl_)
-      dserror("Explicit wear algorithm: no FD check necessary!");
-
-    interface_[i]->FDCheckWearDerivLm();
-  }
-#endif
-
-#ifdef WEARIMPLICITFD
-  for (int i=0; i<(int)interface_.size(); ++i)
-  {
-    if (!wearimpl_)
-      dserror("Explicit wear algorithm: no FD check necessary!");
-
-    interface_[i]->FDCheckWearDeriv();
-  }
-#endif
-
-#ifdef CONTACTFDGAP
-  // FD check of weighted gap g derivatives (non-penetr. condition)
-  for (int i=0; i<(int)interface_.size(); ++i)
-  {
-    interface_[i]->FDCheckGapDeriv();
-    interface_[i]->FDCheckGapDeriv_W();
-  }
-#endif // #ifdef CONTACTFDGAP
-
-#ifdef CONTACTFDSLIPINCR
-  // FD check of weighted gap g derivatives (non-penetr. condition)
-  for (int i=0; i<(int)interface_.size(); ++i)
-  {
-    interface_[i]->FDCheckSlipIncrDerivTXI();
-    if (Dim()==3)
-      interface_[i]->FDCheckSlipIncrDerivTETA();
-
-  }
-#endif // #ifdef CONTACTFDGAP
-
-#ifdef CONTACTFDSTICK
-
-  if (gstickt->NumGlobalElements())
-  {
-    // FD check of stick condition
-    for (int i=0; i<(int)interface_.size(); ++i)
-    {
-      interface_[i]->FDCheckStickDeriv(*linstickLM_,*linstickDIS_);
-    }
-  }
-#endif // #ifdef CONTACTFDSTICK
-
-#ifdef CONTACTFDT_D
-
-  if (!wearprimvar_)
-    dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-  // FD check of stick condition
-  for (int i=0; i<(int)interface_.size(); ++i)
-    interface_[i]->FDCheckDerivT_D(*lintdis_);
-
-#endif
-
-#ifdef CONTACTFDT_D_MASTER
-
-  if (!wearprimvar_)
-    dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-  if (!wearbothpv_)
-    dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-  // FD check of stick condition
-  for (int i=0; i<(int)interface_.size(); ++i)
-    interface_[i]->FDCheckDerivT_D_Master(*lintdisM_);
-
-#endif
-
-#ifdef CONTACTFDE_D
-
-  if (!wearprimvar_)
-    dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-  // FD check of stick condition
-  for (int i=0; i<(int)interface_.size(); ++i)
-    interface_[i]->FDCheckDerivE_D(*linedis_);
-
-#endif
-
-#ifdef CONTACTFDE_D_MASTER
-
-  if (!wearprimvar_)
-    dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-  if (!wearbothpv_)
-    dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-  // FD check of stick condition
-  for (int i=0; i<(int)interface_.size(); ++i)
-    interface_[i]->FDCheckDerivE_D_Master(*linedisM_);
-
-#endif
-
-#ifdef CONTACTFDSLIP
-
-  if (gslipnodes_->NumGlobalElements())
-  {
-    // FD check of slip condition
-    for (int i=0; i<(int)interface_.size(); ++i)
-    {
-      interface_[i]->FDCheckSlipDeriv(*linslipLM_,*linslipDIS_,*linslipW_);
-    }
-  }
-#endif // #ifdef CONTACTFDSLIP
-
-#ifdef CONTACTFDMORTART
-
-  if (!wearprimvar_)
-    dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-    // FD check of Mortar matrix D derivatives
-    std::cout << " -- CONTACTFDMORTART -----------------------------------" << std::endl;
-    twmatrix_->Complete();
-    if( twmatrix_->NormOne() )
-      for (int i=0; i<(int)interface_.size(); ++i)
-        interface_[i]->FDCheckMortarTDeriv();
-    //twmatrix_->UnComplete();
-    std::cout << " -- CONTACTFDMORTART -----------------------------------" << std::endl;
-#endif // #ifdef CONTACTFDMORTARD
-
-#ifdef CONTACTFDMORTARE
-
-    if (!wearprimvar_)
-      dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-    // FD check of Mortar matrix D derivatives
-    std::cout << " -- CONTACTFDMORTARE -----------------------------------" << std::endl;
-    ematrix_->Complete();
-    if( ematrix_->NormOne() )
-      for (int i=0; i<(int)interface_.size(); ++i)
-        interface_[i]->FDCheckMortarEDeriv();
-    //ematrix_->UnComplete();
-    std::cout << " -- CONTACTFDMORTARE -----------------------------------" << std::endl;
-#endif // #ifdef CONTACTFDMORTARD
-
-#ifdef CONTACTFDMORTARE_MASTER
-
-    if (!wearprimvar_)
-      dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-    if (!wearbothpv_)
-      dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-    // FD check of Mortar matrix D derivatives
-    std::cout << " -- CONTACTFDMORTARE_MASTER -----------------------------------" << std::endl;
-    ematrixM_->Complete();
-    if( ematrixM_->NormOne() )
-      for (int i=0; i<(int)interface_.size(); ++i)
-        interface_[i]->FDCheckMortarE_Master_Deriv();
-    //ematrix_->UnComplete();
-    std::cout << " -- CONTACTFDMORTARE_MASTER -----------------------------------" << std::endl;
-#endif // #ifdef CONTACTFDMORTARD
-
-#ifdef CONTACTFDMORTART_MASTER
-
-    if (!wearprimvar_)
-      dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-    if (!wearbothpv_)
-      dserror("FD CHECK ONLY FOR DISCRETE WEAR!");
-
-    // FD check of Mortar matrix D derivatives
-    std::cout << " -- CONTACTFDMORTART_MASTER -----------------------------------" << std::endl;
-    twmatrixM_->Complete();
-    if( twmatrixM_->NormOne() )
-      for (int i=0; i<(int)interface_.size(); ++i)
-        interface_[i]->FDCheckMortarT_Master_Deriv();
-    //ematrix_->UnComplete();
-    std::cout << " -- CONTACTFDMORTART_MASTER -----------------------------------" << std::endl;
-#endif // #ifdef CONTACTFDMORTARD
-
   return;
 }
 
@@ -3899,6 +3717,9 @@
 *-----------------------------------------------------------------------*/
 void WEAR::WearLagrangeStrategy::OutputWear()
 {
+#if 1
+  dserror("Linear solvers not included in contact module. Please contact AdCo Engineering GW GmbH for more details");
+#else
   //***********************************************
   //                 primvar wear
   //***********************************************
@@ -4069,6 +3890,7 @@
       }
     }
   }
+#endif
   return;
 }
 
@@ -4537,187 +4359,6 @@
 }
 
 /*----------------------------------------------------------------------*
- |  read restart information for contact                      popp 03/08|
- *----------------------------------------------------------------------*/
-void WEAR::WearLagrangeStrategy::DoReadRestart(IO::DiscretizationReader& reader,
-                                                Teuchos::RCP<Epetra_Vector> dis)
-{
-  // check whether this is a restart with contact of a previously
-  // non-contact simulation run (if yes, we have to be careful not
-  // to try to read certain, in this case non-existing, vectors
-  // such as the activetoggle or sliptoggle vectors, but rather
-  // initialize the restart active and slip sets as being empty)
-  bool restartwithcontact = DRT::INPUT::IntegralValue<int>(Params(),"RESTART_WITH_CONTACT");
-
-  // set restart displacement state
-  SetState("displacement", dis);
-  SetState("olddisplacement", dis);
-
-  // evaluate interface and restart mortar quantities
-  // in the case of SELF CONTACT, also re-setup master/slave maps
-  InitMortar();
-  InitEvalInterface();
-  AssembleMortar();
-
-  //----------------------------------------------------------------------
-  // CHECK IF WE NEED TRANSFORMATION MATRICES FOR SLAVE DISPLACEMENT DOFS
-  //----------------------------------------------------------------------
-  // Concretely, we apply the following transformations:
-  // D         ---->   D * T^(-1)
-  //----------------------------------------------------------------------
-  if (Dualquadslave3d())
-  {
-    // modify dmatrix_
-    Teuchos::RCP<LINALG::SparseMatrix> temp = LINALG::MLMultiply(*dmatrix_,false,*invtrafo_,false,false,false,true);
-    dmatrix_ = temp;
-  }
-
-  // read restart information on actice set and slip set (leave sets empty
-  // if this is a restart with contact of a non-contact simulation run)
-  Teuchos::RCP<Epetra_Vector> activetoggle =Teuchos::rcp(new Epetra_Vector(*gsnoderowmap_));
-  if (!restartwithcontact) reader.ReadVector(activetoggle,"activetoggle");
-
-  // friction
-  Teuchos::RCP<Epetra_Vector> sliptoggle;
-  Teuchos::RCP<Epetra_Vector> weightedwear;
-  Teuchos::RCP<Epetra_Vector> realwear;
-
-  if (friction_)
-  {
-    sliptoggle =Teuchos::rcp(new Epetra_Vector(*gsnoderowmap_));
-    if (!restartwithcontact) reader.ReadVector(sliptoggle,"sliptoggle");
-  }
-
-  // wear
-  if (weightedwear_)
-  {
-    weightedwear = Teuchos::rcp(new Epetra_Vector(*gsnoderowmap_));
-    reader.ReadVector(weightedwear, "weightedwear");
-
-    realwear = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-    reader.ReadVector(realwear, "realwear");
-  }
-
-  // store restart information on active set and slip set
-  // into nodes, therefore first loop over all interfaces
-  for (int i=0; i<(int)interface_.size(); ++i)
-  {
-    // currently this only works safely for 1 interface
-    //if (i>0) dserror("ERROR: DoReadRestart: Double active node check needed for n interfaces!");
-
-    // loop over all slave nodes on the current interface
-    for (int j=0; j<(interface_[i]->SlaveRowNodes())->NumMyElements(); ++j)
-    {
-      int gid = (interface_[i]->SlaveRowNodes())->GID(j);
-      int dof = (activetoggle->Map()).LID(gid);
-
-      if ((*activetoggle)[dof]==1)
-      {
-        DRT::Node* node = interface_[i]->Discret().gNode(gid);
-        if (!node) dserror("ERROR: Cannot find node with gid %", gid);
-        CONTACT::CoNode* cnode = dynamic_cast<CONTACT::CoNode*>(node);
-
-        // set value active / inactive in cnode
-        cnode->Active()=true;
-
-        if (friction_)
-        {
-          // set value stick / slip in cnode
-          // set wear value
-          if ((*sliptoggle)[dof]==1) dynamic_cast<CONTACT::FriNode*>(cnode)->FriData().Slip()=true;
-          if (weightedwear_)
-            dynamic_cast<CONTACT::FriNode*>(cnode)->WearData().WeightedWear() = (*weightedwear)[dof];
-        }
-      }
-    }
-  }
-
-  if (friction_ and weightedwear_)
-    wearoutput_=realwear;
-
-
-  // read restart information on Lagrange multipliers
-  z_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  zold_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  if (!restartwithcontact) reader.ReadVector(LagrMult(),"lagrmultold");
-  if (!restartwithcontact) reader.ReadVector(LagrMultOld(),"lagrmultold");
-
-  // Lagrange multiplier increment is always zero (no restart value to be read)
-  zincr_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-
-  // store restart information on Lagrange multipliers into nodes
-  StoreNodalQuantities(MORTAR::StrategyBase::lmcurrent);
-  StoreNodalQuantities(MORTAR::StrategyBase::lmold);
-
-  // TODO: same procedure for discrete wear...
-
-  // only for Uzawa Augmented strategy
-  // TODO: this should be moved to contact_penalty_strategy
-  INPAR::CONTACT::SolvingStrategy st = DRT::INPUT::IntegralValue<INPAR::CONTACT::SolvingStrategy>(Params(),"STRATEGY");
-  if (st == INPAR::CONTACT::solution_uzawa)
-  {
-    zuzawa_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-    if (!restartwithcontact) reader.ReadVector(LagrMultUzawa(),"lagrmultold");
-    StoreNodalQuantities(MORTAR::StrategyBase::lmuzawa);
-  }
-
-  // store restart Mortar quantities
-  StoreDM("old");
-
-  if (friction_)
-  {
-    StoreNodalQuantities(MORTAR::StrategyBase::activeold);
-    StoreToOld(MORTAR::StrategyBase::dm);
-  }
-
-  // (re)setup active global Epetra_Maps
-  gactivenodes_ = Teuchos::null;
-  gactivedofs_ = Teuchos::null;
-  gactiven_ = Teuchos::null;
-  gactivet_ = Teuchos::null;
-  gslipnodes_ = Teuchos::null;
-  gslipdofs_ = Teuchos::null;
-  gslipt_ = Teuchos::null;
-
-  // update active sets of all interfaces
-  // (these maps are NOT allowed to be overlapping !!!)
-  for (int i=0; i<(int)interface_.size(); ++i)
-  {
-    interface_[i]->BuildActiveSet();
-    gactivenodes_ = LINALG::MergeMap(gactivenodes_, interface_[i]->ActiveNodes(), false);
-    gactivedofs_ = LINALG::MergeMap(gactivedofs_, interface_[i]->ActiveDofs(), false);
-    gactiven_ = LINALG::MergeMap(gactiven_, interface_[i]->ActiveNDofs(), false);
-    gactivet_ = LINALG::MergeMap(gactivet_, interface_[i]->ActiveTDofs(), false);
-    if (friction_)
-    {
-      gslipnodes_ = LINALG::MergeMap(gslipnodes_, interface_[i]->SlipNodes(), false);
-      gslipdofs_ = LINALG::MergeMap(gslipdofs_, interface_[i]->SlipDofs(), false);
-      gslipt_ = LINALG::MergeMap(gslipt_, interface_[i]->SlipTDofs(), false);
-    }
-  }
-
-  // update flags for global contact status
-  if (gactivenodes_->NumGlobalElements())
-  {
-    isincontact_=true;
-    wasincontact_=true;
-    wasincontactlts_=true;
-  }
-
-  // evaluate relative movement (jump)
-  // needed because it is not called in the predictor of the
-  // lagrange multiplier strategy
-  EvaluateRelMov();
-
-  // reset unbalance factors for redistribution
-  // (during restart the interface has been evaluated once)
-  tunbalance_.resize(0);
-  eunbalance_.resize(0);
-
-  return;
-}
-
-/*----------------------------------------------------------------------*
  |  Update active set and check for convergence (public)     farah 02/16|
  *----------------------------------------------------------------------*/
 void WEAR::WearLagrangeStrategy::UpdateActiveSetSemiSmooth()
Index: ccarat_strategies/src/drt_contact/meshtying_abstract_strategy.H
===================================================================
--- ccarat_strategies/src/drt_contact/meshtying_abstract_strategy.H	(revision 21910)
+++ ccarat_strategies/src/drt_contact/meshtying_abstract_strategy.H	(working copy)
@@ -246,17 +246,6 @@
     */
     void Update(Teuchos::RCP<Epetra_Vector> dis);
 
-    /*!
-    \brief Perform a write restart
-
-    A write restart is initiated by the contact manager. However, the manager has no
-    direct access to the nodal quantities. Different from writing a restart step, now
-    all the restart action has to be performed on the level of the meshtying algorithm,
-    for short: here's the right place.
-
-    */
-    void DoReadRestart(IO::DiscretizationReader& reader, Teuchos::RCP<Epetra_Vector> dis);
-
     //@}
 
     //! @name Debugging methods
@@ -287,15 +276,6 @@
     */
     void PrintActiveSet();
 
-    /*!
-    \brief Visualize contact stuff with gmsh
-
-    \param step (in): current time step index
-    \param iter (in): current iteration index
-
-    */
-    void VisualizeGmsh(const int step, const int iter);
-
     //@}
 
     //! @name Purely virtual functions
Index: ccarat_strategies/src/drt_contact/meshtying_abstract_strategy.cpp
===================================================================
--- ccarat_strategies/src/drt_contact/meshtying_abstract_strategy.cpp	(revision 21910)
+++ ccarat_strategies/src/drt_contact/meshtying_abstract_strategy.cpp	(working copy)
@@ -21,8 +21,6 @@
 #include "../drt_inpar/inpar_contact.H"
 #include "../drt_lib/drt_discret.H"
 #include "../drt_lib/drt_parobjectfactory.H"
-#include "../drt_io/io.H"
-#include "../drt_io/io_control.H"
 #include "../linalg/linalg_utils.H"
 #include "../linalg/linalg_sparsematrix.H"
 
@@ -790,36 +788,7 @@
   return;
 }
 
-/*----------------------------------------------------------------------*
- |  read restart information for meshtying                    popp 03/08|
- *----------------------------------------------------------------------*/
-void CONTACT::MtAbstractStrategy::DoReadRestart(IO::DiscretizationReader& reader,
-                                                Teuchos::RCP<Epetra_Vector> dis)
-{
-  // set displacement state
-  SetState("displacement",dis);
 
-  // read restart information on Lagrange multipliers
-  z_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  zincr_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  reader.ReadVector(LagrMult(),"mt_lagrmultold");
-  StoreNodalQuantities(MORTAR::StrategyBase::lmcurrent);
-  zold_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  reader.ReadVector(LagrMultOld(),"mt_lagrmultold");
-  StoreNodalQuantities(MORTAR::StrategyBase::lmold);
-
-  // only for Uzawa strategy
-  INPAR::CONTACT::SolvingStrategy st = DRT::INPUT::IntegralValue<INPAR::CONTACT::SolvingStrategy>(Params(),"STRATEGY");
-  if (st == INPAR::CONTACT::solution_uzawa)
-  {
-    zuzawa_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-    reader.ReadVector(LagrMultUzawa(),"mt_lagrmultold");
-    StoreNodalQuantities(MORTAR::StrategyBase::lmuzawa);
-  }
-
-  return;
-}
-
 /*----------------------------------------------------------------------*
  |  Compute interface forces (for debugging only)             popp 02/08|
  *----------------------------------------------------------------------*/
@@ -1224,16 +1193,6 @@
 /*----------------------------------------------------------------------*
  | Visualization of meshtying segments with gmsh              popp 08/08|
  *----------------------------------------------------------------------*/
-void CONTACT::MtAbstractStrategy::VisualizeGmsh(const int step, const int iter)
-{
-  // visualization with gmsh
-  for (int i=0; i<(int)interface_.size(); ++i)
-    interface_[i]->VisualizeGmsh(step, iter);
-}
-
-/*----------------------------------------------------------------------*
- | Visualization of meshtying segments with gmsh              popp 08/08|
- *----------------------------------------------------------------------*/
 void CONTACT::MtAbstractStrategy::AssembleCoords(const std::string& sidename, bool ref,
                                                  Teuchos::RCP<Epetra_Vector> vec)
 {
Index: ccarat_strategies/src/drt_contact/meshtying_lagrange_strategy.cpp
===================================================================
--- ccarat_strategies/src/drt_contact/meshtying_lagrange_strategy.cpp	(revision 21910)
+++ ccarat_strategies/src/drt_contact/meshtying_lagrange_strategy.cpp	(working copy)
@@ -20,9 +20,7 @@
 #include "../drt_mortar/mortar_utils.H"
 #include "../drt_inpar/inpar_mortar.H"
 #include "../drt_inpar/inpar_contact.H"
-#include "../drt_lib/drt_globalproblem.H"
 #include "../linalg/linalg_multiply.H"
-#include "../linalg/linalg_solver.H"  // mesh initialization :-(
 #include "../linalg/linalg_utils.H"
 /*----------------------------------------------------------------------*
  | ctor (public)                                              popp 05/09|
@@ -285,8 +283,9 @@
     mmatrix_->Multiply(false,*xm,*rhs);
 
     // solve with default solver
-    LINALG::Solver solver(Comm());
-    solver.Solve(lhs->EpetraOperator(),Xslavemod,rhs,true);
+//    LINALG::Solver solver(Comm());
+//    solver.Solve(lhs->EpetraOperator(),Xslavemod,rhs,true);
+    dserror("Linear solvers not included in contact module. Please contact AdCo Engineering GW GmbH for more details");
 #else
     // this is trivial for dual Lagrange multipliers
     mhatmatrix_->Multiply(false, *Xmaster, *Xslavemod);
@@ -311,8 +310,10 @@
       mmatrix_->Multiply(false, *Xmaster, *rhs);
 
       // solve with default solver
-      LINALG::Solver solver(Comm());
-      solver.Solve(dmatrix_->EpetraOperator(), Xslavemod, rhs, true);
+//      LINALG::Solver solver(Comm());
+//      solver.Solve(dmatrix_->EpetraOperator(), Xslavemod, rhs, true);
+
+      dserror("Linear solvers not included in contact module. Please contact AdCo Engineering GW GmbH for more details");
     }
   }
 
Index: ccarat_strategies/src/drt_contact/meshtying_penalty_strategy.cpp
===================================================================
--- ccarat_strategies/src/drt_contact/meshtying_penalty_strategy.cpp	(revision 21910)
+++ ccarat_strategies/src/drt_contact/meshtying_penalty_strategy.cpp	(working copy)
@@ -19,7 +19,6 @@
 #include "../drt_mortar/mortar_utils.H"
 #include "../drt_inpar/inpar_contact.H"
 #include "../linalg/linalg_multiply.H"
-#include "../linalg/linalg_solver.H"  // mesh initialization :-(
 #include "../linalg/linalg_utils.H"
 
 
@@ -141,8 +140,9 @@
   mmatrix_->Multiply(false,*Xmaster,*rhs);
 
   // solve with default solver
-  LINALG::Solver solver(Comm());
-  solver.Solve(dmatrix_->EpetraOperator(),Xslavemod,rhs,true);
+//  LINALG::Solver solver(Comm());
+//  solver.Solve(dmatrix_->EpetraOperator(),Xslavemod,rhs,true);
+  dserror("Linear solvers not included in contact module. Please contact AdCo Engineering GW GmbH for more details");
 
   //**********************************************************************
   // (3) perform mesh initialization node by node
Index: ccarat_strategies/src/drt_mortar/mortar_strategy_base.H
===================================================================
--- ccarat_strategies/src/drt_mortar/mortar_strategy_base.H	(revision 21910)
+++ ccarat_strategies/src/drt_mortar/mortar_strategy_base.H	(working copy)
@@ -162,7 +162,6 @@
     virtual Teuchos::RCP<Epetra_Vector> ContactNorStress() = 0;
     virtual Teuchos::RCP<Epetra_Vector> ContactTanStress() = 0;
     virtual Teuchos::RCP<LINALG::SparseMatrix> DMatrix() = 0;
-    virtual void DoReadRestart(IO::DiscretizationReader& reader, Teuchos::RCP<Epetra_Vector> dis) = 0;
     virtual void DoWriteRestart(std::map<std::string,Teuchos::RCP<Epetra_Vector> >& restart_vectors, bool forcedrestart = false) = 0;
     virtual void Evaluate(Teuchos::RCP<LINALG::SparseOperator>& kteff, Teuchos::RCP<Epetra_Vector>& feff, Teuchos::RCP<Epetra_Vector> dis) = 0;
     virtual void EvaluateMeshtying(Teuchos::RCP<LINALG::SparseOperator>& kteff, Teuchos::RCP<Epetra_Vector>& feff, Teuchos::RCP<Epetra_Vector> dis) = 0;
@@ -212,7 +211,6 @@
     virtual void UpdateActiveSetSemiSmooth() = 0;
     virtual void UpdateUzawaAugmentedLagrange() = 0;
     virtual void UpdateConstraintNorm(int uzawaiter = 0) = 0;
-    virtual void VisualizeGmsh(const int step, const int iter) = 0;
     virtual bool WasInContact() = 0;
     virtual bool WasInContactLastTimeStep() = 0;
 
