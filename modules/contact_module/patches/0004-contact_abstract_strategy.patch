Index: src/drt_contact/contact_wear_lagrange_strategy.cpp
===================================================================
--- src/drt_contact/contact_wear_lagrange_strategy.cpp	(revision 21208)
+++ src/drt_contact/contact_wear_lagrange_strategy.cpp	(working copy)
@@ -30,7 +30,6 @@
 #include "../drt_mortar/mortar_utils.H"
 #include "../drt_inpar/inpar_contact.H"
 #include "../drt_inpar/inpar_wear.H"
-#include "../drt_io/io.H"
 
 #include "../linalg/linalg_utils.H"
 #include "../linalg/linalg_solver.H"
@@ -4566,187 +4565,7 @@
   return;
 }
 
-/*----------------------------------------------------------------------*
- |  read restart information for contact                      popp 03/08|
- *----------------------------------------------------------------------*/
-void CONTACT::WearLagrangeStrategy::DoReadRestart(IO::DiscretizationReader& reader,
-                                                Teuchos::RCP<Epetra_Vector> dis)
-{
-  // check whether this is a restart with contact of a previously
-  // non-contact simulation run (if yes, we have to be careful not
-  // to try to read certain, in this case non-existing, vectors
-  // such as the activetoggle or sliptoggle vectors, but rather
-  // initialize the restart active and slip sets as being empty)
-  bool restartwithcontact = DRT::INPUT::IntegralValue<int>(Params(),"RESTART_WITH_CONTACT");
 
-  // set restart displacement state
-  SetState("displacement", dis);
-  SetState("olddisplacement", dis);
-
-  // evaluate interface and restart mortar quantities
-  // in the case of SELF CONTACT, also re-setup master/slave maps
-  InitMortar();
-  InitEvalInterface();
-  AssembleMortar();
-
-  //----------------------------------------------------------------------
-  // CHECK IF WE NEED TRANSFORMATION MATRICES FOR SLAVE DISPLACEMENT DOFS
-  //----------------------------------------------------------------------
-  // Concretely, we apply the following transformations:
-  // D         ---->   D * T^(-1)
-  //----------------------------------------------------------------------
-  if (Dualquadslave3d())
-  {
-    // modify dmatrix_
-    Teuchos::RCP<LINALG::SparseMatrix> temp = LINALG::MLMultiply(*dmatrix_,false,*invtrafo_,false,false,false,true);
-    dmatrix_ = temp;
-  }
-
-  // read restart information on actice set and slip set (leave sets empty
-  // if this is a restart with contact of a non-contact simulation run)
-  Teuchos::RCP<Epetra_Vector> activetoggle =Teuchos::rcp(new Epetra_Vector(*gsnoderowmap_));
-  if (!restartwithcontact) reader.ReadVector(activetoggle,"activetoggle");
-
-  // friction
-  Teuchos::RCP<Epetra_Vector> sliptoggle;
-  Teuchos::RCP<Epetra_Vector> weightedwear;
-  Teuchos::RCP<Epetra_Vector> realwear;
-
-  if (friction_)
-  {
-    sliptoggle =Teuchos::rcp(new Epetra_Vector(*gsnoderowmap_));
-    if (!restartwithcontact) reader.ReadVector(sliptoggle,"sliptoggle");
-  }
-
-  // wear
-  if (weightedwear_)
-  {
-    weightedwear = Teuchos::rcp(new Epetra_Vector(*gsnoderowmap_));
-    reader.ReadVector(weightedwear, "weightedwear");
-
-    realwear = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-    reader.ReadVector(realwear, "realwear");
-  }
-
-  // store restart information on active set and slip set
-  // into nodes, therefore first loop over all interfaces
-  for (int i=0; i<(int)interface_.size(); ++i)
-  {
-    // currently this only works safely for 1 interface
-    //if (i>0) dserror("ERROR: DoReadRestart: Double active node check needed for n interfaces!");
-
-    // loop over all slave nodes on the current interface
-    for (int j=0; j<(interface_[i]->SlaveRowNodes())->NumMyElements(); ++j)
-    {
-      int gid = (interface_[i]->SlaveRowNodes())->GID(j);
-      int dof = (activetoggle->Map()).LID(gid);
-
-      if ((*activetoggle)[dof]==1)
-      {
-        DRT::Node* node = interface_[i]->Discret().gNode(gid);
-        if (!node) dserror("ERROR: Cannot find node with gid %", gid);
-        CoNode* cnode = dynamic_cast<CoNode*>(node);
-
-        // set value active / inactive in cnode
-        cnode->Active()=true;
-
-        if (friction_)
-        {
-          // set value stick / slip in cnode
-          // set wear value
-          if ((*sliptoggle)[dof]==1) dynamic_cast<CONTACT::FriNode*>(cnode)->FriData().Slip()=true;
-          if (weightedwear_)
-            dynamic_cast<CONTACT::FriNode*>(cnode)->FriDataPlus().WeightedWear() = (*weightedwear)[dof];
-        }
-      }
-    }
-  }
-
-  if (friction_ and weightedwear_)
-    wearoutput_=realwear;
-
-
-  // read restart information on Lagrange multipliers
-  z_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  zold_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  if (!restartwithcontact) reader.ReadVector(LagrMult(),"lagrmultold");
-  if (!restartwithcontact) reader.ReadVector(LagrMultOld(),"lagrmultold");
-
-  // Lagrange multiplier increment is always zero (no restart value to be read)
-  zincr_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-
-  // store restart information on Lagrange multipliers into nodes
-  StoreNodalQuantities(MORTAR::StrategyBase::lmcurrent);
-  StoreNodalQuantities(MORTAR::StrategyBase::lmold);
-
-  // TODO: same procedure for discrete wear...
-
-  // only for Uzawa Augmented strategy
-  // TODO: this should be moved to contact_penalty_strategy
-  INPAR::CONTACT::SolvingStrategy st = DRT::INPUT::IntegralValue<INPAR::CONTACT::SolvingStrategy>(Params(),"STRATEGY");
-  if (st == INPAR::CONTACT::solution_uzawa)
-  {
-    zuzawa_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-    if (!restartwithcontact) reader.ReadVector(LagrMultUzawa(),"lagrmultold");
-    StoreNodalQuantities(MORTAR::StrategyBase::lmuzawa);
-  }
-
-  // store restart Mortar quantities
-  StoreDM("old");
-
-  if (friction_)
-  {
-    StoreNodalQuantities(MORTAR::StrategyBase::activeold);
-    StoreToOld(MORTAR::StrategyBase::dm);
-  }
-
-  // (re)setup active global Epetra_Maps
-  gactivenodes_ = Teuchos::null;
-  gactivedofs_ = Teuchos::null;
-  gactiven_ = Teuchos::null;
-  gactivet_ = Teuchos::null;
-  gslipnodes_ = Teuchos::null;
-  gslipdofs_ = Teuchos::null;
-  gslipt_ = Teuchos::null;
-
-  // update active sets of all interfaces
-  // (these maps are NOT allowed to be overlapping !!!)
-  for (int i=0; i<(int)interface_.size(); ++i)
-  {
-    interface_[i]->BuildActiveSet();
-    gactivenodes_ = LINALG::MergeMap(gactivenodes_, interface_[i]->ActiveNodes(), false);
-    gactivedofs_ = LINALG::MergeMap(gactivedofs_, interface_[i]->ActiveDofs(), false);
-    gactiven_ = LINALG::MergeMap(gactiven_, interface_[i]->ActiveNDofs(), false);
-    gactivet_ = LINALG::MergeMap(gactivet_, interface_[i]->ActiveTDofs(), false);
-    if (friction_)
-    {
-      gslipnodes_ = LINALG::MergeMap(gslipnodes_, interface_[i]->SlipNodes(), false);
-      gslipdofs_ = LINALG::MergeMap(gslipdofs_, interface_[i]->SlipDofs(), false);
-      gslipt_ = LINALG::MergeMap(gslipt_, interface_[i]->SlipTDofs(), false);
-    }
-  }
-
-  // update flags for global contact status
-  if (gactivenodes_->NumGlobalElements())
-  {
-    isincontact_=true;
-    wasincontact_=true;
-    wasincontactlts_=true;
-  }
-
-  // evaluate relative movement (jump)
-  // needed because it is not called in the predictor of the
-  // lagrange multiplier strategy
-  EvaluateRelMov();
-
-  // reset unbalance factors for redistribution
-  // (during restart the interface has been evaluated once)
-  tunbalance_.resize(0);
-  eunbalance_.resize(0);
-
-  return;
-}
-
 /*----------------------------------------------------------------------*
  |  Update active set and check for convergence (public)      popp 06/08|
  *----------------------------------------------------------------------*/
Index: src/drt_contact/contact_wear_lagrange_strategy.H
===================================================================
--- src/drt_contact/contact_wear_lagrange_strategy.H	(revision 21208)
+++ src/drt_contact/contact_wear_lagrange_strategy.H	(working copy)
@@ -193,17 +193,7 @@
                       Teuchos::RCP<Epetra_Vector>& realwear,
                       bool forcedrestart = false);
 
-  /*!
-  \brief Perform a write restart
 
-  A write restart is initiated by the contact manager. However, the manager has no
-  direct access to the nodal quantities. Hence, all the restart action has to be
-  performed on the level of the contact algorithm, for short: here's the right place.
-
-  */
-  void DoReadRestart(IO::DiscretizationReader& reader, Teuchos::RCP<Epetra_Vector> dis);
-
-
   /*!
   \brief Update active set and check for convergence
 
Index: src/drt_contact/meshtying_abstract_strategy.cpp
===================================================================
--- src/drt_contact/meshtying_abstract_strategy.cpp	(revision 21208)
+++ src/drt_contact/meshtying_abstract_strategy.cpp	(working copy)
@@ -21,8 +21,6 @@
 #include "../drt_inpar/inpar_contact.H"
 #include "../drt_lib/drt_discret.H"
 #include "../drt_lib/drt_parobjectfactory.H"
-#include "../drt_io/io.H"
-#include "../drt_io/io_control.H"
 #include "../linalg/linalg_utils.H"
 #include "../linalg/linalg_sparsematrix.H"
 
@@ -783,36 +781,7 @@
   return;
 }
 
-/*----------------------------------------------------------------------*
- |  read restart information for meshtying                    popp 03/08|
- *----------------------------------------------------------------------*/
-void CONTACT::MtAbstractStrategy::DoReadRestart(IO::DiscretizationReader& reader,
-                                                Teuchos::RCP<Epetra_Vector> dis)
-{
-  // set displacement state
-  SetState("displacement",dis);
 
-  // read restart information on Lagrange multipliers
-  z_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  zincr_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  reader.ReadVector(LagrMult(),"mt_lagrmultold");
-  StoreNodalQuantities(MORTAR::StrategyBase::lmcurrent);
-  zold_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  reader.ReadVector(LagrMultOld(),"mt_lagrmultold");
-  StoreNodalQuantities(MORTAR::StrategyBase::lmold);
-
-  // only for Uzawa strategy
-  INPAR::CONTACT::SolvingStrategy st = DRT::INPUT::IntegralValue<INPAR::CONTACT::SolvingStrategy>(Params(),"STRATEGY");
-  if (st == INPAR::CONTACT::solution_uzawa)
-  {
-    zuzawa_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-    reader.ReadVector(LagrMultUzawa(),"mt_lagrmultold");
-    StoreNodalQuantities(MORTAR::StrategyBase::lmuzawa);
-  }
-
-  return;
-}
-
 /*----------------------------------------------------------------------*
  |  Compute interface forces (for debugging only)             popp 02/08|
  *----------------------------------------------------------------------*/
Index: src/drt_contact/meshtying_abstract_strategy.H
===================================================================
--- src/drt_contact/meshtying_abstract_strategy.H	(revision 21208)
+++ src/drt_contact/meshtying_abstract_strategy.H	(working copy)
@@ -323,17 +323,7 @@
     */
     void Update(Teuchos::RCP<Epetra_Vector> dis);
 
-    /*!
-    \brief Perform a write restart
 
-    A write restart is initiated by the contact manager. However, the manager has no
-    direct access to the nodal quantities. Different from writing a restart step, now
-    all the restart action has to be performed on the level of the meshtying algorithm,
-    for short: here's the right place.
-
-    */
-    void DoReadRestart(IO::DiscretizationReader& reader, Teuchos::RCP<Epetra_Vector> dis);
-
     //@}
 
     //! @name Debugging methods
Index: src/drt_contact/contact_abstract_strategy.cpp
===================================================================
--- src/drt_contact/contact_abstract_strategy.cpp	(revision 21208)
+++ src/drt_contact/contact_abstract_strategy.cpp	(working copy)
@@ -21,8 +21,6 @@
 #include "../drt_inpar/inpar_wear.H"
 #include "../drt_lib/drt_discret.H"
 #include "../drt_lib/drt_colors.H"
-#include "../drt_io/io.H"
-#include "../drt_io/io_control.H"
 #include "../linalg/linalg_utils.H"
 #include "../linalg/linalg_multiply.H"
 #include "../linalg/linalg_sparsematrix.H"
@@ -1992,179 +1990,7 @@
   return;
 }
 
-/*----------------------------------------------------------------------*
- |  read restart information for contact                      popp 03/08|
- *----------------------------------------------------------------------*/
-void CONTACT::CoAbstractStrategy::DoReadRestart(
-    IO::DiscretizationReader& reader, Teuchos::RCP<Epetra_Vector> dis)
-{
-  // check whether this is a restart with contact of a previously
-  // non-contact simulation run (if yes, we have to be careful not
-  // to try to read certain, in this case non-existing, vectors
-  // such as the activetoggle or sliptoggle vectors, but rather
-  // initialize the restart active and slip sets as being empty)
-  bool restartwithcontact = DRT::INPUT::IntegralValue<int>(Params(),
-      "RESTART_WITH_CONTACT");
 
-  // set restart displacement state
-  SetState("displacement", dis);
-  SetState("olddisplacement", dis);
-
-  // evaluate interface and restart mortar quantities
-  // in the case of SELF CONTACT, also re-setup master/slave maps
-  InitMortar();
-  InitEvalInterface();
-  AssembleMortar();
-
-  //----------------------------------------------------------------------
-  // CHECK IF WE NEED TRANSFORMATION MATRICES FOR SLAVE DISPLACEMENT DOFS
-  //----------------------------------------------------------------------
-  // Concretely, we apply the following transformations:
-  // D         ---->   D * T^(-1)
-  //----------------------------------------------------------------------
-  if (Dualquadslave3d())
-  {
-    // modify dmatrix_
-    Teuchos::RCP<LINALG::SparseMatrix> temp = LINALG::MLMultiply(*dmatrix_,
-        false, *invtrafo_, false, false, false, true);
-    dmatrix_ = temp;
-  }
-
-  // read restart information on actice set and slip set (leave sets empty
-  // if this is a restart with contact of a non-contact simulation run)
-  Teuchos::RCP<Epetra_Vector> activetoggle = Teuchos::rcp(
-      new Epetra_Vector(*gsnoderowmap_));
-  if (!restartwithcontact)
-    reader.ReadVector(activetoggle, "activetoggle");
-
-  // friction
-  Teuchos::RCP<Epetra_Vector> sliptoggle;
-  Teuchos::RCP<Epetra_Vector> weightedwear;
-
-  if (friction_)
-  {
-    sliptoggle = Teuchos::rcp(new Epetra_Vector(*gsnoderowmap_));
-    if (!restartwithcontact)
-      reader.ReadVector(sliptoggle, "sliptoggle");
-  }
-
-  // store restart information on active set and slip set
-  // into nodes, therefore first loop over all interfaces
-  for (int i = 0; i < (int) interface_.size(); ++i)
-  {
-    // loop over all slave nodes on the current interface
-    for (int j = 0; j < (interface_[i]->SlaveRowNodes())->NumMyElements(); ++j)
-    {
-      int gid = (interface_[i]->SlaveRowNodes())->GID(j);
-      int dof = (activetoggle->Map()).LID(gid);
-
-      if ((*activetoggle)[dof] == 1)
-      {
-        DRT::Node* node = interface_[i]->Discret().gNode(gid);
-        if (!node)
-          dserror("ERROR: Cannot find node with gid %", gid);
-        CoNode* cnode = dynamic_cast<CoNode*>(node);
-
-        // set value active / inactive in cnode
-        cnode->Active() = true;
-
-        if (friction_)
-        {
-          // set value stick / slip in cnode
-          if ((*sliptoggle)[dof] == 1)
-            dynamic_cast<CONTACT::FriNode*>(cnode)->FriData().Slip() = true;
-        }
-      }
-    }
-  }
-
-  // read restart information on Lagrange multipliers
-  z_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  zold_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-  if (!restartwithcontact)
-    reader.ReadVector(LagrMult(), "lagrmultold");
-  if (!restartwithcontact)
-    reader.ReadVector(LagrMultOld(), "lagrmultold");
-
-  // Lagrange multiplier increment is always zero (no restart value to be read)
-  zincr_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-
-  // store restart information on Lagrange multipliers into nodes
-  StoreNodalQuantities(MORTAR::StrategyBase::lmcurrent);
-  StoreNodalQuantities(MORTAR::StrategyBase::lmold);
-
-  // only for Uzawa augmented strategy
-  // TODO: this should be moved to contact_penalty_strategy
-  if (stype_ == INPAR::CONTACT::solution_uzawa)
-  {
-    zuzawa_ = Teuchos::rcp(new Epetra_Vector(*gsdofrowmap_));
-    if (!restartwithcontact)
-      reader.ReadVector(LagrMultUzawa(), "lagrmultold");
-    StoreNodalQuantities(MORTAR::StrategyBase::lmuzawa);
-  }
-
-  // store restart Mortar quantities
-  StoreDM("old");
-
-  if (friction_)
-  {
-    StoreNodalQuantities(MORTAR::StrategyBase::activeold);
-    StoreToOld(MORTAR::StrategyBase::dm);
-  }
-
-  // (re)setup active global Epetra_Maps
-  gactivenodes_ = Teuchos::null;
-  gactivedofs_ = Teuchos::null;
-  gactiven_ = Teuchos::null;
-  gactivet_ = Teuchos::null;
-  gslipnodes_ = Teuchos::null;
-  gslipdofs_ = Teuchos::null;
-  gslipt_ = Teuchos::null;
-
-  // update active sets of all interfaces
-  // (these maps are NOT allowed to be overlapping !!!)
-  for (int i = 0; i < (int) interface_.size(); ++i)
-  {
-    interface_[i]->BuildActiveSet();
-    gactivenodes_ = LINALG::MergeMap(gactivenodes_,
-        interface_[i]->ActiveNodes(), false);
-    gactivedofs_ = LINALG::MergeMap(gactivedofs_, interface_[i]->ActiveDofs(),
-        false);
-    gactiven_ = LINALG::MergeMap(gactiven_, interface_[i]->ActiveNDofs(),
-        false);
-    gactivet_ = LINALG::MergeMap(gactivet_, interface_[i]->ActiveTDofs(),
-        false);
-    if (friction_)
-    {
-      gslipnodes_ = LINALG::MergeMap(gslipnodes_, interface_[i]->SlipNodes(),
-          false);
-      gslipdofs_ = LINALG::MergeMap(gslipdofs_, interface_[i]->SlipDofs(),
-          false);
-      gslipt_ = LINALG::MergeMap(gslipt_, interface_[i]->SlipTDofs(), false);
-    }
-  }
-
-  // update flags for global contact status
-  if (gactivenodes_->NumGlobalElements())
-  {
-    isincontact_ = true;
-    wasincontact_ = true;
-    wasincontactlts_ = true;
-  }
-
-  // evaluate relative movement (jump)
-  // needed because it is not called in the predictor of the
-  // lagrange multiplier strategy
-  EvaluateRelMov();
-
-  // reset unbalance factors for redistribution
-  // (during restart the interface has been evaluated once)
-  tunbalance_.resize(0);
-  eunbalance_.resize(0);
-
-  return;
-}
-
 /*----------------------------------------------------------------------*
  |  Compute interface forces (for debugging only)             popp 02/08|
  *----------------------------------------------------------------------*/
Index: src/drt_contact/contact_abstract_strategy.H
===================================================================
--- src/drt_contact/contact_abstract_strategy.H	(revision 21208)
+++ src/drt_contact/contact_abstract_strategy.H	(working copy)
@@ -607,17 +607,6 @@
       Teuchos::RCP<Epetra_Vector>& weightedwear,
       Teuchos::RCP<Epetra_Vector>& realwear, bool forcedrestart = false);
 
-  /*!
-   \brief Perform a write restart
-
-   A write restart is initiated by the contact manager. However, the manager has no
-   direct access to the nodal quantities. Hence, all the restart action has to be
-   performed on the level of the contact algorithm, for short: here's the right place.
-
-   */
-  void DoReadRestart(IO::DiscretizationReader& reader,
-      Teuchos::RCP<Epetra_Vector> dis);
-
     //@}
 
     //! @name Empty functions if no augmented Lagrange formulation is used
Index: src/drt_contact/contact_lagrange_strategy.cpp
===================================================================
--- src/drt_contact/contact_lagrange_strategy.cpp	(revision 21208)
+++ src/drt_contact/contact_lagrange_strategy.cpp	(working copy)
@@ -17,7 +17,6 @@
 #include "friction_node.H"
 #include "../drt_mortar/mortar_utils.H"
 #include "../drt_inpar/inpar_contact.H"
-#include "../drt_io/io.H"
 #include "../linalg/linalg_multiply.H"
 #include "../linalg/linalg_utils.H"
 
Index: src/drt_mortar/mortar_strategy_base.H
===================================================================
--- src/drt_mortar/mortar_strategy_base.H	(revision 21208)
+++ src/drt_mortar/mortar_strategy_base.H	(working copy)
@@ -162,7 +162,6 @@
     virtual Teuchos::RCP<Epetra_Vector> ContactTanStress() = 0;
     virtual Teuchos::RCP<Epetra_Vector> ContactWear() = 0;
     virtual Teuchos::RCP<LINALG::SparseMatrix> DMatrix() = 0;
-    virtual void DoReadRestart(IO::DiscretizationReader& reader, Teuchos::RCP<Epetra_Vector> dis) = 0;
     virtual void DoWriteRestart(Teuchos::RCP<Epetra_Vector>& activetoggle,Teuchos::RCP<Epetra_Vector>& sliptoggle,Teuchos::RCP<Epetra_Vector>& weightedwear,Teuchos::RCP<Epetra_Vector>& realwear, bool forcedrestart = false) = 0;
     virtual void Evaluate(Teuchos::RCP<LINALG::SparseOperator>& kteff, Teuchos::RCP<Epetra_Vector>& feff, Teuchos::RCP<Epetra_Vector> dis) = 0;
     virtual void EvaluateMeshtying(Teuchos::RCP<LINALG::SparseOperator>& kteff, Teuchos::RCP<Epetra_Vector>& feff, Teuchos::RCP<Epetra_Vector> dis) = 0;
