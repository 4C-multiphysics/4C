Index: ccarat_linalg/src/drt_fem_general/drt_utils_gausspoints.H
===================================================================
--- ccarat_linalg/src/drt_fem_general/drt_utils_gausspoints.H	(revision 21908)
+++ ccarat_linalg/src/drt_fem_general/drt_utils_gausspoints.H	(working copy)
@@ -2,7 +2,6 @@
 #define DRT_UTILS_GAUSSPOINTS_H
 
 #include "drt_utils_fem_shapefunctions.H"
-#include "../drt_geometry/element_coordtrafo.H"
 
 namespace DRT
 {
@@ -195,7 +194,7 @@
 };
 
 /// remember calculated gauss points so we do not need to calculate again
-class GaussPointCache : public DRT::SingletonDestruction
+class GaussPointCache
 {
 public:
 
@@ -393,14 +392,14 @@
 
     GaussIntegration intpoints( gp );
 
-    ProjectGaussPointsLocalToGlobal<distype>( xie, intpoints, cgp );
+    ProjectGaussPoints<distype>( xie, intpoints, cgp );
 
     return cgp;
   }
 
-  /// Project the given Gauss points in local coordinate system of the element to its global coordinate system
+  /// Project the given Gauss integration rule over the given element coordinates
   template <DRT::Element::DiscretizationType distype>
-  static void ProjectGaussPointsLocalToGlobal( const LINALG::Matrix<DRT::UTILS::DisTypeToDim<distype>::dim,
+  static void ProjectGaussPoints( const LINALG::Matrix<DRT::UTILS::DisTypeToDim<distype>::dim,
                                         DRT::UTILS::DisTypeToNumNodePerEle<distype>::numNodePerElement> & xie,
                                   GaussIntegration& intpoints,
                                   Teuchos::RCP<CollectedGaussPoints>& cgp
@@ -439,51 +438,6 @@
     }
   }
 
-  /// Project the given Gauss points in global coordinate system of the element to its local coordinate system
-  template <DRT::Element::DiscretizationType distype>
-  static Teuchos::RCP<GaussPoints> ProjectGaussPointsGlobalToLocal( const LINALG::Matrix<DRT::UTILS::DisTypeToDim<distype>::dim,
-                                                                    DRT::UTILS::DisTypeToNumNodePerEle<distype>::numNodePerElement> & xie,
-                                                                    GaussIntegration& intpoints )
-  {
-    const int nsd = DRT::UTILS::DisTypeToDim<distype>::dim;
-    const int nen = DRT::UTILS::DisTypeToNumNodePerEle<distype>::numNodePerElement;
-
-    LINALG::Matrix<nen,1> funct;
-    LINALG::Matrix<nsd,nen> deriv;
-
-    LINALG::Matrix<nsd,nsd> xjm;
-    LINALG::Matrix<nsd,1> xi;
-
-    Teuchos::RCP<DRT::UTILS::CollectedGaussPoints> cgp = Teuchos::rcp( new
-                                    DRT::UTILS::CollectedGaussPoints( intpoints.NumPoints() ) );
-
-    for ( DRT::UTILS::GaussIntegration::iterator iquad=intpoints.begin();
-              iquad!=intpoints.end();
-              ++iquad )
-    {
-      LINALG::Matrix<nsd,1> glo( iquad.Point() );
-
-      bool insideele = GEO::currentToVolumeElementCoordinates(distype, xie, glo, xi);
-      if( not insideele )
-      {
-        dserror("Given Gauss points not inside the element?");
-      }
-
-      // cell shape functions and their first derivatives
-      DRT::UTILS::shape_function<distype>(xi,funct);
-      DRT::UTILS::shape_function_deriv1<distype>(xi,deriv);
-
-      // get transposed of the jacobian matrix d x / d \xi
-      // xjm(i,j) = deriv(i,k)*xyze(j,k)
-      xjm.MultiplyNT( deriv, xie );
-
-      double det = xjm.Determinant();
-
-      cgp->Append( xi, iquad.Weight()/det );
-    }
-    return cgp;
-  }
-
 private:
 
   /// internal collection
Index: ccarat_linalg/src/linalg/linalg_sparsematrix.H
===================================================================
--- ccarat_linalg/src/linalg/linalg_sparsematrix.H	(revision 21908)
+++ ccarat_linalg/src/linalg/linalg_sparsematrix.H	(working copy)
@@ -84,19 +84,6 @@
      */
     enum MatrixType {CRS_MATRIX, FE_MATRIX};
 
-    /// The following dummy templated constructors will catch all attempts to call any constructor with arguments
-    /// that require implicit casting. Therefore you have to instantiate this class with exactly the types
-    /// matching one of the constructors
-#if __cplusplus >= 201103L
-  template <typename... T> SparseMatrix(T...) = delete;
-#else
-  template <typename T0>                                                     SparseMatrix(T0)                 {BOOST_STATIC_ASSERT_MSG(sizeof(T0) == 0, "dummy templated constructor") BACI_ATTRIBUTE_UNUSED;}
-  template <typename T0, typename T1>                                        SparseMatrix(T0, T1)             {BOOST_STATIC_ASSERT_MSG(sizeof(T0) == 0, "dummy templated constructor") BACI_ATTRIBUTE_UNUSED;}
-  template <typename T0, typename T1, typename T2>                           SparseMatrix(T0, T1, T2)         {BOOST_STATIC_ASSERT_MSG(sizeof(T0) == 0, "dummy templated constructor") BACI_ATTRIBUTE_UNUSED;}
-  template <typename T0, typename T1, typename T2, typename T3>              SparseMatrix(T0, T1, T2, T3)     {BOOST_STATIC_ASSERT_MSG(sizeof(T0) == 0, "dummy templated constructor") BACI_ATTRIBUTE_UNUSED;}
-  template <typename T0, typename T1, typename T2, typename T3, typename T4> SparseMatrix(T0, T1, T2, T3, T4) {BOOST_STATIC_ASSERT_MSG(sizeof(T0) == 0, "dummy templated constructor") BACI_ATTRIBUTE_UNUSED;}
-#endif
-
     /// construction of sparse matrix
     SparseMatrix(
       Teuchos::RCP<Epetra_CrsGraph> crsgraph,
Index: ccarat_linalg/src/linalg/linalg_utils.cpp
===================================================================
--- ccarat_linalg/src/linalg/linalg_utils.cpp	(revision 21908)
+++ ccarat_linalg/src/linalg/linalg_utils.cpp	(working copy)
@@ -698,6 +698,9 @@
  *----------------------------------------------------------------------*/
 void LINALG::SymmetricInverse(Epetra_SerialDenseMatrix& A, const int dim)
 {
+#if 1
+  dserror("Check availability of BLAS/LAPACK routines for SymmetricInverse routine for a dense matrix!");
+#else
   if (A.M() != A.N())
     dserror("Matrix is not square");
   if (A.M() != dim)
@@ -724,6 +727,7 @@
   for (int i = 0; i < dim; ++i)
     for (int j = 0; j < i; ++j)
       A(j, i) = A(i, j);
+#endif
   return;
 }
 
@@ -930,6 +934,10 @@
 double LINALG::GeneralizedEigen(Epetra_SerialDenseMatrix& A,
     Epetra_SerialDenseMatrix& B)
 {
+#if 1
+  dserror("Check availability of BLAS/LAPACK routines for GeneralizedEigen routine for a dense matrix!");
+  return 0.0;
+#else
   Epetra_SerialDenseMatrix tmpA(A);
   Epetra_SerialDenseMatrix tmpB(B);
 
@@ -1134,6 +1142,7 @@
     }
   }
   return maxlambda;
+#endif
 }
 
 /*----------------------------------------------------------------------*
