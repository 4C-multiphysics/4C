Index: ccarat_interfaces/src/drt_contact/contact_interface.H
===================================================================
--- ccarat_interfaces/src/drt_contact/contact_interface.H	(revision 21911)
+++ ccarat_interfaces/src/drt_contact/contact_interface.H	(working copy)
@@ -543,21 +543,6 @@
   */
   virtual bool SplitActiveDofs();
 
-  /*!
-  \brief Assemble normal coupling weighted condition for poro contact
-
-  */
-  virtual void AssembleNCoup(Epetra_Vector& gglobal);
-
-  /*!
-  \brief Assemble linearisation of normal coupling weighted condition for poro contact
-
-  */
-  virtual void AssembleNCoupLin(LINALG::SparseMatrix& sglobal,
-      ADAPTER::Coupling& coupfs,
-      bool AssembleVelocityLin = false //if true velocity linearisation will be assembled into sglobal, otherwise lin. w.r.t. displacements!
-      );
-
   //@}
 
   //! @name Visualization and Debugging methods
@@ -571,12 +556,6 @@
                            const Epetra_Vector& fm);
 
   /*!
-  \brief Visualize contact stuff with gmsh
-
-  */
-  void VisualizeGmsh(const int step, const int iter);
-
-  /*!
   \brief Check normal/tangent derivatives with finite differences
 
   */
@@ -620,31 +599,11 @@
   void FDCheckTangLMDeriv();
 
   /*!
-  \brief Check stick condition derivatives with finite differences
-
-  */
-  virtual void FDCheckStickDeriv(LINALG::SparseMatrix& linstickLMglobal,
-                                 LINALG::SparseMatrix& linstickDISglobal);
-
-  /*!
-  \brief Check slip condition derivatives with finite differences
-
-  */
-  virtual void FDCheckSlipDeriv(LINALG::SparseMatrix& linslipLMglobal,
-                                LINALG::SparseMatrix& linslipDISglobal);
-
-  /*!
   \brief Check penalty approach with finite differences
 
   */
   void FDCheckPenaltyTracNor();
 
-  /*!
-  \brief Check frictional penalty traction with finite differences
-
-  */
-  virtual void FDCheckPenaltyTracFric();
-
   void AddGPTSforces(Teuchos::RCP<Epetra_FEVector> feff);
   void AddGPTSstiffness(Teuchos::RCP<LINALG::SparseMatrix> kteff);
 
Index: ccarat_interfaces/src/drt_contact/contact_interface.cpp
===================================================================
--- ccarat_interfaces/src/drt_contact/contact_interface.cpp	(revision 21911)
+++ ccarat_interfaces/src/drt_contact/contact_interface.cpp	(working copy)
@@ -33,7 +33,6 @@
 #include "../drt_lib/drt_utils_parmetis.H"
 #include "../linalg/linalg_utils.H"
 #include "../linalg/linalg_serialdensevector.H"
-#include "../drt_adapter/adapter_coupling.H"
 
 /*----------------------------------------------------------------------*
  |  ctor (public)                                            mwgee 10/07|
@@ -8748,130 +8747,8 @@
 }
 
 
-/*---------------------------------------------------------------------------*
- |  Assemble normal coupling weighted condition for poro contact   ager 07/14|
- *--------------------------------------------------------------------------*/
-void CONTACT::CoInterface::AssembleNCoup(Epetra_Vector& gglobal)
-{
-  // get out of here if not participating in interface
-  if (!lComm()) return;
-
-  // loop over proc's slave nodes of the interface for assembly
-  // use standard row map to assemble each node only once
-  for (int i=0;i<activenodes_->NumMyElements();++i)
-  {
-    int gid = activenodes_->GID(i);
-    DRT::Node* node = idiscret_->gNode(gid);
-    if (!node) dserror("ERROR: Cannot find node with gid %",gid);
-    CoNode* mrtnode = dynamic_cast<CoNode*>(node);
-
-    if (mrtnode->Owner() != Comm().MyPID())
-      dserror("ERROR: AssembleDMG: Node ownership inconsistency!");
-
-    /**************************************************** nCoup-vector ******/
-    if (mrtnode->CoPoroData().GetnCoup()!=0.0)
-    {
-      double nCoup = mrtnode->CoPoroData().GetnCoup();
-      if (DRT::INPUT::IntegralValue<int>(imortar_,"LM_NODAL_SCALE")==true &&
-          mrtnode->MoData().GetScale() != 0.0)
-        nCoup /= mrtnode->MoData().GetScale();
-
-      Epetra_SerialDenseVector gnode(1);
-      std::vector<int> lm(1);
-      std::vector<int> lmowner(1);
-
-      gnode(0) = nCoup;
-      lm[0] =  activen_->GID(i);
-
-      lmowner[0] = mrtnode->Owner();
-
-      LINALG::Assemble(gglobal,gnode,lm,lmowner);
-    }
-  }
-
-  return;
-}
-
 /*---------------------------------------------------------------------*
- |  Assemble linearisation of normal coupling                          |
- |          weighted condition for poro contact              ager 07/14|
  *--------------------------------------------------------------------*/
-void CONTACT::CoInterface::AssembleNCoupLin(LINALG::SparseMatrix& sglobal, ADAPTER::Coupling& coupfs,
-    bool AssembleVelocityLin)
-{
-  // get out of here if not participating in interface
-  if (!lComm())
-    return;
-
-  // nothing to do if no active nodes
-  if (activenodes_==Teuchos::null)
-    return;
-
-  Teuchos::RCP<const Epetra_Map> MasterDofMap_full;
-  Teuchos::RCP<const Epetra_Map> PermSlaveDofMap_full;
-
-  if (AssembleVelocityLin)
-  {
-    //store map on all processors, simple but expensive
-    MasterDofMap_full = LINALG::AllreduceEMap(*coupfs.MasterDofMap());
-    PermSlaveDofMap_full = LINALG::AllreduceEMap(*coupfs.PermSlaveDofMap());
-  }
-
-  for (int i=0;i<activenodes_->NumMyElements();++i)
-  {
-    int gid = activenodes_->GID(i);
-    DRT::Node* node = idiscret_->gNode(gid);
-    if (!node) dserror("ERROR: Cannot find node with gid %",gid);
-    CoNode* cnode = dynamic_cast<CoNode*>(node);
-
-    if (cnode->Owner() != Comm().MyPID())
-      dserror("ERROR: AssembleS: Node ownership inconsistency!");
-
-    std::map<int,double>::iterator colcurr;
-    int row = activen_->GID(i);
-
-    std::map<int,double>& dgmap = cnode->CoPoroData().GetDerivnCoup();
-    if (AssembleVelocityLin)
-    {//Assign fluid velocity linearization to matrix
-
-      dgmap = cnode->CoPoroData().GetVelDerivnCoup();
-        for (colcurr=dgmap.begin();colcurr!=dgmap.end();++colcurr)
-        {
-          int col = PermSlaveDofMap_full->GID(MasterDofMap_full->LID(colcurr->first));
-          double val = colcurr->second;
-
-          // do not assemble zeros into s matrix
-          if (abs(val)>1.0e-12) sglobal.Assemble(val,row,col);
-        }
-      //Assign pressure linearization to matrix
-      dgmap = cnode->CoPoroData().GetPresDerivnCoup();
-        for (colcurr=dgmap.begin();colcurr!=dgmap.end();++colcurr)
-        {
-          int col = PermSlaveDofMap_full->GID(MasterDofMap_full->LID(colcurr->first))+Dim();
-          double val = colcurr->second;
-
-          // do not assemble zeros into s matrix
-          if (abs(val)>1.0e-12) sglobal.Assemble(val,row,col);
-        }
-    }
-    else
-    {//Assign skeleton displacement linearization to matrix
-      for (colcurr=dgmap.begin();colcurr!=dgmap.end();++colcurr)
-      {
-        int col = colcurr->first;
-        double val = colcurr->second;
-
-        // do not assemble zeros into s matrix
-        if (abs(val)>1.0e-12) sglobal.Assemble(val,row,col);
-      }
-    }
-  }
-  return;
-}
-
-
-/*---------------------------------------------------------------------*
- *--------------------------------------------------------------------*/
 void CONTACT::CoInterface::AddGPTSforces(Teuchos::RCP<Epetra_FEVector> feff)
 {
   for (int i=0;i<mnodecolmap_->NumMyElements();++i)
Index: ccarat_interfaces/src/drt_contact/contact_wear_interface.H
===================================================================
--- ccarat_interfaces/src/drt_contact/contact_wear_interface.H	(revision 21911)
+++ ccarat_interfaces/src/drt_contact/contact_wear_interface.H	(working copy)
@@ -178,91 +178,6 @@
    virtual bool BuildActiveSetMaster();
 
    /*!
-   \brief Check mortar wear T derivatives with finite differences
-
-   */
-   void FDCheckMortarTDeriv();
-
-   /*!
-   \brief Check mortar wear T derivatives with finite differences (Master)
-
-   */
-   void FDCheckMortarT_Master_Deriv();
-
-   /*!
-   \brief Check mortar wear E derivatives with finite differences
-
-   */
-   void FDCheckMortarEDeriv();
-
-   /*!
-   \brief Check mortar wear E derivatives with finite differences (for master)
-
-   */
-   void FDCheckMortarE_Master_Deriv();
-
-   /*!
-   \brief Check mortar wear T derivatives with finite differences
-     --> for wear condition
-
-   */
-   void FDCheckDerivT_D(LINALG::SparseMatrix& lintdis);
-
-   /*!
-   \brief Check mortar wear T derivatives with finite differences
-     --> for wear condition (Master)
-
-   */
-   void FDCheckDerivT_D_Master(LINALG::SparseMatrix& lintdis);
-
-   /*!
-   \brief Check mortar wear E derivatives with finite differences
-     --> for wear condition
-
-   */
-   void FDCheckDerivE_D(LINALG::SparseMatrix& linedis);
-
-   /*!
-   \brief Check mortar wear E derivatives with finite differences
-     --> for wear condition (Master)
-
-   */
-   void FDCheckDerivE_D_Master(LINALG::SparseMatrix& linedis);
-   /*!
-   \brief Check weighted gap g derivatives with finite differences
-
-   */
-   void FDCheckGapDeriv();
-
-   /*!
-   \brief Check weighted gap g derivatives with finite differences
-
-   */
-   void FDCheckGapDeriv_W();
-
-   /*!
-   \brief Check weighted wear ~w derivatives with finite differences
-          derivation w.r.t. displ.
-
-   */
-   void FDCheckWearDeriv();
-
-   /*!
-   \brief Check weighted wear ~w derivatives with finite differences
-          derivation w.r.t. lagr.-mult.
-
-   */
-   void FDCheckWearDerivLm();
-
-   /*!
-   \brief Check slip condition derivatives with finite differences
-
-   */
-   virtual void FDCheckSlipDeriv(LINALG::SparseMatrix& linslipLMglobal,
-                                 LINALG::SparseMatrix& linslipDISglobal,
-                                 LINALG::SparseMatrix& linslipWglobal);
-
-   /*!
    \brief Assemble inactive rhs (incremental delta_w_)
    */
    virtual void AssembleInactiveWearRhs(Epetra_Vector& inactiverhs);
Index: ccarat_interfaces/src/drt_mortar/mortar_interface.H
===================================================================
--- ccarat_interfaces/src/drt_mortar/mortar_interface.H	(revision 21911)
+++ ccarat_interfaces/src/drt_mortar/mortar_interface.H	(working copy)
@@ -624,11 +624,6 @@
   //! @name Visualization and Debugging methods
 
   /*!
-  \brief Visualize mortar stuff with gmsh (may be overloaded)
-  */
-  virtual void VisualizeGmsh(const int step, const int iter);
-
-  /*!
   \brief Print shape function type (enum)
   */
   void PrintShapeFcn() { std::cout << shapefcn_ << std::endl; };
Index: ccarat_interfaces/src/drt_mortar/mortar_interface.cpp
===================================================================
--- ccarat_interfaces/src/drt_mortar/mortar_interface.cpp	(revision 21911)
+++ ccarat_interfaces/src/drt_mortar/mortar_interface.cpp	(working copy)
@@ -32,21 +32,13 @@
 #include "../linalg/linalg_serialdensevector.H"
 #include "../linalg/linalg_serialdensematrix.H"
 
-#include "../drt_io/io_control.H"
-#include "../drt_meshfree_discret/drt_meshfree_discret.H"
-
 #include "../drt_lib/drt_utils_parmetis.H"
 #include "../drt_lib/drt_utils.H"
-#include "../drt_lib/drt_globalproblem.H"
 
 #include <Teuchos_Time.hpp>
 #include <Epetra_Time.h>
 #include <Epetra_SerialComm.h>
 
-#include "../drt_particle/binning_strategy.H"
-#include "../drt_nurbs_discret/drt_nurbs_discret.H"
-#include "../drt_poroelast/poroelast_utils.H"
-
 #include "../drt_contact/contact_interpolator.H"
 
 /*----------------------------------------------------------------------*
@@ -77,33 +69,10 @@
     dserror("ERROR: Mortar problem must be 2D or 3D");
   procmap_.clear();
 
-  // build interface disretization
-  if (!nurbs_)
-  {
-    if (!imortar_.get("GEO_DECOUPLED", false))
-    {
-      // standard case
-      idiscret_ = Teuchos::rcp(
-          new DRT::Discretization((std::string) "mortar interface", com));
-    }
-    else
-    {
-      // adapt flags in meshfree params
-      Teuchos::RCP<Teuchos::ParameterList> meshfreeparams
-        = Teuchos::rcp(new Teuchos::ParameterList(DRT::Problem::Instance()->MeshfreeParams()));
-      meshfreeparams->set("TYPE", "GeoDecoupled");
+  // standard case
+  idiscret_ = Teuchos::rcp(
+      new DRT::Discretization((std::string) "mortar interface", com));
 
-      idiscret_ = Teuchos::rcp(
-          new DRT::MESHFREE::MeshfreeDiscretization((std::string) "mortar interface", com, *meshfreeparams));
-    }
-  }
-  else
-  {
-    idiscret_ = Teuchos::rcp(
-        new DRT::NURBS::NurbsDiscretization((std::string) "mortar interface",
-            com));
-  }
-
   // overwrite shape function type
   INPAR::MORTAR::ShapeFcn shapefcn = DRT::INPUT::IntegralValue<
       INPAR::MORTAR::ShapeFcn>(IParams(), "LM_SHAPEFCN");
@@ -281,7 +250,7 @@
 void MORTAR::MortarInterface::AddMortarPoint(
     Teuchos::RCP<MORTAR::MortarNode> mrtrnode)
 {
-  Teuchos::rcp_dynamic_cast<DRT::MESHFREE::MeshfreeDiscretization>(idiscret_, true)->AddPoint(mrtrnode);
+  dserror("Needed for MeshfreeDiscretization. Blame on us!");
   return;
 }
 
@@ -315,6 +284,9 @@
  *----------------------------------------------------------------------*/
 void MORTAR::MortarInterface::RemoveSingleInterfaceSide(bool slaveside)
 {
+#if 1
+  dserror("MortarInterface::RemoveSingleInterfaceSide not included in contact module");
+#else
   Teuchos::RCP<Epetra_Map> elecolmap;
   Teuchos::RCP<Epetra_Map> nodecolmap;
   Teuchos::RCP<Epetra_Map> pointcolmap;
@@ -402,7 +374,7 @@
         idiscret_->DeleteNode(gid);
     }
   }
-
+#endif
   return;
 }
 
@@ -543,10 +515,6 @@
   // make sure discretization is complete
   Discret().FillComplete(true, false, false);
 
-  //ghost also parent elements according to the ghosting strategy of the interface (atm just for poro)
-  if (newghosting && poro_)
-    POROELAST::UTILS::CreateVolumeGhosting(Discret());
-
   // need row and column maps of slave and master nodes / elements / dofs
   // separately so we can easily address them
   UpdateMasterSlaveSets();
@@ -851,6 +819,9 @@
  *----------------------------------------------------------------------*/
 void MORTAR::MortarInterface::BinningStrategy(Teuchos::RCP<Epetra_Map> initial_elecolmap, double vel)
 {
+#if 1
+  dserror("Support for binning strategy in contact module only upon request. Please contact AdCo Engineering GW GmbH.");
+#else
   // init XAABB
   LINALG::Matrix<3,2> XAABB(false);
   for(int dim=0; dim<3; ++dim)
@@ -955,7 +926,7 @@
 
   // fillcomplete interface
   FillComplete();
-
+#endif
   return;
 }
 
@@ -4271,6 +4242,9 @@
  *----------------------------------------------------------------------*/
 void MORTAR::MortarInterface::CreateVolumeGhosting(DRT::Discretization& idiscret,bool onlyslave)
 {
+#if 1
+  dserror("Not supported for contact module!");
+#else
   //**********************************************************************
   // Prerequisites of this funtion:
   // All Contact Elements need a set parent_id_ (member of faceelement!) before
@@ -4360,5 +4334,7 @@
       faceele->SetParentMasterElement(vele,faceele->FaceParentNumber());
     }
   }
+#endif
+  return;
 }
 
