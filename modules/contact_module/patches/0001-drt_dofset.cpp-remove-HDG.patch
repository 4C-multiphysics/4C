From 268827775d411d447a5c66de95a3435586f8d175 Mon Sep 17 00:00:00 2001
From: Tobias Wiesner <wiesner@lnm.mw.tum.de>
Date: Mon, 24 Nov 2014 15:09:29 +0100
Subject: [PATCH 01/16] drt_dofset.cpp: remove HDG

---
 src/drt_lib/drt_dofset.cpp |   72 --------------------------------------------
 1 files changed, 0 insertions(+), 72 deletions(-)

diff --git a/src/drt_lib/drt_dofset.cpp b/src/drt_lib/drt_dofset.cpp
index 106589a..c3037ac 100644
--- a/src/drt_lib/drt_dofset.cpp
+++ b/src/drt_lib/drt_dofset.cpp
@@ -18,7 +18,6 @@ Maintainer: Martin Kronbichler
 #include "drt_dofset.H"
 #include "drt_dofset_proxy.H"
 #include "drt_discret.H"
-#include "drt_discret_hdg.H"
 #include "drt_utils.H"
 
 #include "../linalg/linalg_utils.H"
@@ -170,10 +169,6 @@ int DRT::DofSet::AssignDegreesOfFreedom(const Discretization& dis, const unsigne
   // Get highest GID used so far and add one
   int count = MaxGIDinList(dis.Comm()) + 1;
 
-  // Check if we have a face discretization which supports degrees of freedom on faces
-  Teuchos::RCP<const DiscretizationHDG> facedis =
-    Teuchos::rcp_dynamic_cast<const DiscretizationHDG>(Teuchos::rcp(&dis,false));
-
   // Now this is tricky. We have to care for nodes, faces, and elements, both
   // row and column maps. In general both nodes, faces, and elements can have
   // dofs. In all cases these dofs might be shared with other nodes, faces,
@@ -193,14 +188,10 @@ int DRT::DofSet::AssignDegreesOfFreedom(const Discretization& dis, const unsigne
   // numdf for all nodes and elements
   numdfcolnodes_ = Teuchos::rcp(new Epetra_IntVector(*dis.NodeColMap()));
   numdfcolelements_ = Teuchos::rcp(new Epetra_IntVector(*dis.ElementColMap()));
-  if (facedis != Teuchos::null && facedis->FaceColMap() != NULL)
-    numdfcolfaces_ = Teuchos::rcp(new Epetra_IntVector(*facedis->FaceColMap()));
 
   // index of first dof for all nodes and elements
   idxcolnodes_ = Teuchos::rcp(new Epetra_IntVector(*dis.NodeColMap()));
   idxcolelements_ = Teuchos::rcp(new Epetra_IntVector(*dis.ElementColMap()));
-  if (facedis != Teuchos::null && facedis->FaceColMap() != NULL)
-    idxcolfaces_ = Teuchos::rcp(new Epetra_IntVector(*facedis->FaceColMap()));
 
   //////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////
@@ -483,63 +474,6 @@ int DRT::DofSet::AssignDegreesOfFreedom(const Discretization& dis, const unsigne
 
     //////////////////////////////////////////////////////////////////
 
-    // Now do it again for the faces
-    if (facedis != Teuchos::null && facedis->FaceRowMap() != NULL)
-    {
-      Epetra_IntVector numdfrowfaces(*facedis->FaceRowMap());
-      Epetra_IntVector idxrowfaces(*facedis->FaceRowMap());
-      int numcolelements = dis.NumMyColElements();
-
-      const int mypid = dis.Comm().MyPID();
-      for (int i=0; i<numcolelements; ++i)
-      {
-        DRT::FaceElement** faces = dis.lColElement(i)->Faces();
-        for (int face=0; face<dis.lColElement(i)->NumFace(); ++face)
-          if (faces[face]->Owner() == mypid) {
-            const int mylid = facedis->FaceRowMap()->LID(faces[face]->Id());
-            numdfrowfaces[mylid] = NumDofPerFace(*(dis.lColElement(i)),face);
-          }
-      }
-
-      int minfacegid = facedis->FaceRowMap()->MinAllGID();
-      int maxfacenumdf = numdfrowfaces.MaxValue();
-
-      for (int i=0; i<numcolelements; ++i)
-      {
-        DRT::FaceElement** faces = dis.lColElement(i)->Faces();
-        for (int face=0; face<dis.lColElement(i)->NumFace(); ++face)
-          if (faces[face]->Owner() == mypid)
-          {
-            const int gid = faces[face]->Id();
-            const int mylid = facedis->FaceRowMap()->LID(gid);
-            int numdf = numdfrowfaces[mylid];
-            int dof = count + ( gid-minfacegid )*maxfacenumdf;
-            idxrowfaces[mylid] = dof;
-            std::vector<int> & dofs = facedofset[gid];
-            // do not visit the same face more than once
-            if (dofs.empty())
-            {
-              dofs.reserve( numdf );
-              for ( int j=0; j<numdf; ++j )
-              {
-                dofs.push_back( dof+j );
-              }
-            }
-          }
-      }
-
-      Epetra_Import faceimporter( numdfcolfaces_->Map(), numdfrowfaces.Map() );
-      err = numdfcolfaces_->Import( numdfrowfaces, faceimporter, Insert );
-      if (err) dserror( "Import using importer returned err=%d", err );
-      err = idxcolfaces_->Import( idxrowfaces, faceimporter, Insert );
-      if (err) dserror( "Import using importer returned err=%d", err );
-
-      count = idxrowfaces.MaxValue() + maxfacenumdf;
-    }
-
-
-    //////////////////////////////////////////////////////////////////
-
     // Now do it again for the elements
     Epetra_IntVector numdfrowelements(*dis.ElementRowMap());
     Epetra_IntVector idxrowelements(*dis.ElementRowMap());
@@ -626,12 +560,6 @@ int DRT::DofSet::AssignDegreesOfFreedom(const Discretization& dis, const unsigne
   Exporter elementexporter( *dis.ElementRowMap(), *dis.ElementColMap(), dis.Comm() );
   elementexporter.Export( elementdofset );
 
-  if (facedis != Teuchos::null && facedis->FaceRowMap() != NULL)
-  {
-    Exporter faceexporter( *facedis->FaceRowMap(), *facedis->FaceColMap(), dis.Comm() );
-    faceexporter.Export( facedofset );
-  }
-
   for ( std::map<int,std::vector<int> >::iterator i=nodedofset.begin();
         i!=nodedofset.end();
         ++i )
-- 
1.7.7.6

